
Linting "ngx-quill"...
[{"filePath":"/home/migudel/Documentos/TFG/repos/articulo/ngx-quill/projects/ngx-quill/src/lib/quill-editor.component.ts","messages":[{"ruleId":"@angular-eslint/prefer-output-readonly","severity":2,"message":"Prefer to declare `@Output` as `readonly` since they are not supposed to be reassigned","line":125,"column":13,"nodeType":"Identifier","messageId":"preferOutputReadonly","endLine":125,"endColumn":28,"suggestions":[{"messageId":"suggestAddReadonlyModifier","fix":{"range":[3725,3725],"text":"readonly "},"desc":"Add `readonly` modifier"}]},{"ruleId":"@angular-eslint/prefer-output-readonly","severity":2,"message":"Prefer to declare `@Output` as `readonly` since they are not supposed to be reassigned","line":126,"column":13,"nodeType":"Identifier","messageId":"preferOutputReadonly","endLine":126,"endColumn":28,"suggestions":[{"messageId":"suggestAddReadonlyModifier","fix":{"range":[3785,3785],"text":"readonly "},"desc":"Add `readonly` modifier"}]},{"ruleId":"@angular-eslint/prefer-output-readonly","severity":2,"message":"Prefer to declare `@Output` as `readonly` since they are not supposed to be reassigned","line":127,"column":13,"nodeType":"Identifier","messageId":"preferOutputReadonly","endLine":127,"endColumn":29,"suggestions":[{"messageId":"suggestAddReadonlyModifier","fix":{"range":[3879,3879],"text":"readonly "},"desc":"Add `readonly` modifier"}]},{"ruleId":"@angular-eslint/prefer-output-readonly","severity":2,"message":"Prefer to declare `@Output` as `readonly` since they are not supposed to be reassigned","line":128,"column":13,"nodeType":"Identifier","messageId":"preferOutputReadonly","endLine":128,"endColumn":31,"suggestions":[{"messageId":"suggestAddReadonlyModifier","fix":{"range":[3944,3944],"text":"readonly "},"desc":"Add `readonly` modifier"}]},{"ruleId":"@angular-eslint/prefer-output-readonly","severity":2,"message":"Prefer to declare `@Output` as `readonly` since they are not supposed to be reassigned","line":129,"column":13,"nodeType":"Identifier","messageId":"preferOutputReadonly","endLine":129,"endColumn":20,"suggestions":[{"messageId":"suggestAddReadonlyModifier","fix":{"range":[4013,4013],"text":"readonly "},"desc":"Add `readonly` modifier"}]},{"ruleId":"@angular-eslint/prefer-output-readonly","severity":2,"message":"Prefer to declare `@Output` as `readonly` since they are not supposed to be reassigned","line":130,"column":13,"nodeType":"Identifier","messageId":"preferOutputReadonly","endLine":130,"endColumn":19,"suggestions":[{"messageId":"suggestAddReadonlyModifier","fix":{"range":[4061,4061],"text":"readonly "},"desc":"Add `readonly` modifier"}]},{"ruleId":"@angular-eslint/prefer-output-readonly","severity":2,"message":"Prefer to declare `@Output` as `readonly` since they are not supposed to be reassigned","line":131,"column":13,"nodeType":"Identifier","messageId":"preferOutputReadonly","endLine":131,"endColumn":26,"suggestions":[{"messageId":"suggestAddReadonlyModifier","fix":{"range":[4107,4107],"text":"readonly "},"desc":"Add `readonly` modifier"}]},{"ruleId":"@angular-eslint/prefer-output-readonly","severity":2,"message":"Prefer to declare `@Output` as `readonly` since they are not supposed to be reassigned","line":132,"column":13,"nodeType":"Identifier","messageId":"preferOutputReadonly","endLine":132,"endColumn":25,"suggestions":[{"messageId":"suggestAddReadonlyModifier","fix":{"range":[4161,4161],"text":"readonly "},"desc":"Add `readonly` modifier"}]},{"ruleId":"@angular-eslint/prefer-signals","severity":2,"message":"Properties declared using signals should be marked as `readonly` since they should not be reassigned","line":171,"column":3,"nodeType":"Identifier","messageId":"preferReadonlySignalProperties","endLine":171,"endColumn":14,"suggestions":[{"messageId":"suggestAddReadonlyModifier","fix":{"range":[5265,5265],"text":"readonly "},"desc":"Add `readonly` modifier"}]},{"ruleId":"@angular-eslint/prefer-signals","severity":2,"message":"Properties declared using signals should be marked as `readonly` since they should not be reassigned","line":194,"column":3,"nodeType":"Identifier","messageId":"preferReadonlySignalProperties","endLine":194,"endColumn":14,"suggestions":[{"messageId":"suggestAddReadonlyModifier","fix":{"range":[5962,5962],"text":"readonly "},"desc":"Add `readonly` modifier"}]},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":730,"column":1,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":763,"endColumn":3,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[537,22837],"text":", ChangeDetectionStrategy\n} from '@angular/core'\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop'\nimport { fromEvent, Subscription } from 'rxjs'\nimport { debounceTime, mergeMap } from 'rxjs/operators'\n\nimport { ControlValueAccessor, NG_VALIDATORS, NG_VALUE_ACCESSOR, Validator } from '@angular/forms'\n\nimport { CustomModule, CustomOption, defaultModules, QuillBeforeRender, QuillModules } from 'ngx-quill/config'\n\nimport type History from 'quill/modules/history'\nimport type Toolbar from 'quill/modules/toolbar'\nimport { getFormat, raf$ } from './helpers'\nimport { QuillService } from './quill.service'\n\nexport interface Range {\n  index: number\n  length: number\n}\n\nexport interface ContentChange {\n  content: DeltaType\n  delta: DeltaType\n  editor: QuillType\n  html: string | null\n  oldDelta: DeltaType\n  source: string\n  text: string\n}\n\nexport interface SelectionChange {\n  editor: QuillType\n  oldRange: Range | null\n  range: Range | null\n  source: string\n}\n\nexport interface Blur {\n  editor: QuillType\n  source: string\n}\n\nexport interface Focus {\n  editor: QuillType\n  source: string\n}\n\nexport type EditorChangeContent = ContentChange & { event: 'text-change' }\nexport type EditorChangeSelection = SelectionChange & { event: 'selection-change' }\n\n@Directive()\nexport abstract class QuillEditorBase implements AfterViewInit, ControlValueAccessor, OnChanges, OnInit, OnDestroy, Validator {\n  readonly format = input<'object' | 'html' | 'text' | 'json' | undefined>(\n    undefined\n  )\n  readonly theme = input<string | undefined>(undefined)\n  readonly modules = input<QuillModules | undefined>(undefined)\n  readonly debug = input<'warn' | 'log' | 'error' | false>(false)\n  readonly readOnly = input<boolean | undefined>(false)\n  readonly placeholder = input<string | undefined>(undefined)\n  readonly maxLength = input<number | undefined>(undefined)\n  readonly minLength = input<number | undefined>(undefined)\n  readonly required = input(false)\n  readonly formats = input<string[] | null | undefined>(undefined)\n  readonly customToolbarPosition = input<'top' | 'bottom'>('top')\n  readonly sanitize = input<boolean | undefined>(undefined)\n  readonly beforeRender = input<QuillBeforeRender>(undefined)\n  readonly styles = input<any>(null)\n  readonly registry = input<QuillOptions['registry']>(\n    undefined\n  )\n  readonly bounds = input<HTMLElement | string | undefined>(undefined)\n  readonly customOptions = input<CustomOption[]>([])\n  readonly customModules = input<CustomModule[]>([])\n  readonly trackChanges = input<'user' | 'all' | undefined>(undefined)\n  readonly classes = input<string | undefined>(undefined)\n  readonly trimOnValidation = input(false)\n  readonly linkPlaceholder = input<string | undefined>(undefined)\n  readonly compareValues = input(false)\n  readonly filterNull = input(false)\n  readonly debounceTime = input<number | undefined>(undefined)\n  /*\n  https://github.com/KillerCodeMonkey/ngx-quill/issues/1257 - fix null value set\n\n  provide default empty value\n  by default null\n\n  e.g. defaultEmptyValue=\"\" - empty string\n\n  <quill-editor\n    defaultEmptyValue=\"\"\n    formControlName=\"message\"\n  ></quill-editor>\n  */\n  readonly defaultEmptyValue = input<any>(null)\n\n  @Output() onEditorCreated = new EventEmitter<QuillType>()\n  @Output() onEditorChanged = new EventEmitter<EditorChangeContent | EditorChangeSelection>()\n  @Output() onContentChanged = new EventEmitter<ContentChange>()\n  @Output() onSelectionChanged = new EventEmitter<SelectionChange>()\n  @Output() onFocus = new EventEmitter<Focus>()\n  @Output() onBlur = new EventEmitter<Blur>()\n  @Output() onNativeFocus = new EventEmitter<Focus>()\n  @Output() onNativeBlur = new EventEmitter<Blur>()\n\n  quillEditor!: QuillType\n  editorElem!: HTMLElement\n  content: any\n  disabled = false // used to store initial value before ViewInit\n\n  readonly toolbarPosition = signal('top')\n\n  onModelChange: (modelValue?: any) => void\n  onModelTouched: () => void\n  onValidatorChanged: () => void\n\n  private subscription: Subscription | null = null\n  private quillSubscription: Subscription | null = null\n\n  private elementRef = inject(ElementRef)\n  private document = inject(DOCUMENT)\n\n  private cd = inject(ChangeDetectorRef)\n  private domSanitizer = inject(DomSanitizer)\n  private platformId = inject<string>(PLATFORM_ID)\n  private renderer = inject(Renderer2)\n  private zone = inject(NgZone)\n  private service = inject(QuillService)\n  private destroyRef = inject(DestroyRef)\n\n  static normalizeClassNames(classes: string): string[] {\n    const classList = classes.trim().split(' ')\n    return classList.reduce((prev: string[], cur: string) => {\n      const trimmed = cur.trim()\n      if (trimmed) {\n        prev.push(trimmed)\n      }\n\n      return prev\n    }, [])\n  }\n\n  valueGetter = input((quillEditor: QuillType): string | any => {\n    let html: string | null = quillEditor.getSemanticHTML()\n    if (this.isEmptyValue(html)) {\n      html = this.defaultEmptyValue()\n    }\n    let modelValue: string | DeltaType | null = html\n    const format = getFormat(this.format(), this.service.config.format)\n\n    if (format === 'text') {\n      modelValue = quillEditor.getText()\n    } else if (format === 'object') {\n      modelValue = quillEditor.getContents()\n    } else if (format === 'json') {\n      try {\n        modelValue = JSON.stringify(quillEditor.getContents())\n      } catch {\n        modelValue = quillEditor.getText()\n      }\n    }\n\n    return modelValue\n  })\n\n  valueSetter = input((quillEditor: QuillType, value: any): any => {\n    const format = getFormat(this.format(), this.service.config.format)\n    if (format === 'html') {\n      const sanitize = [true, false].includes(this.sanitize()) ? this.sanitize() : (this.service.config.sanitize || false)\n      if (sanitize) {\n        value = this.domSanitizer.sanitize(SecurityContext.HTML, value)\n      }\n      return quillEditor.clipboard.convert({ html: value })\n    } else if (format === 'json') {\n      try {\n        return JSON.parse(value)\n      } catch {\n        return [{ insert: value }]\n      }\n    }\n\n    return value\n  })\n\n  ngOnInit() {\n    this.toolbarPosition.set(this.customToolbarPosition())\n  }\n\n  ngAfterViewInit() {\n    if (isPlatformServer(this.platformId)) {\n      return\n    }\n\n    // The `quill-editor` component might be destroyed before the `quill` chunk is loaded and its code is executed\n    // this will lead to runtime exceptions, since the code will be executed on DOM nodes that don't exist within the tree.\n\n    this.quillSubscription = this.service.getQuill().pipe(\n      mergeMap((Quill) => this.service.beforeRender(Quill, this.customModules(), this.beforeRender()))\n    ).subscribe(Quill => {\n      this.editorElem = this.elementRef.nativeElement.querySelector(\n        '[quill-editor-element]'\n      )\n\n      const toolbarElem = this.elementRef.nativeElement.querySelector(\n        '[quill-editor-toolbar]'\n      )\n      const modules = Object.assign({}, this.modules() || this.service.config.modules)\n\n      if (toolbarElem) {\n        modules.toolbar = toolbarElem\n      } else if (modules.toolbar === undefined) {\n        modules.toolbar = defaultModules.toolbar\n      }\n\n      let placeholder = this.placeholder() !== undefined ? this.placeholder() : this.service.config.placeholder\n      if (placeholder === undefined) {\n        placeholder = 'Insert text here ...'\n      }\n\n      const styles = this.styles()\n      if (styles) {\n        Object.keys(styles).forEach((key: string) => {\n          this.renderer.setStyle(this.editorElem, key, styles[key])\n        })\n      }\n\n      if (this.classes()) {\n        this.addClasses(this.classes())\n      }\n\n      this.customOptions().forEach((customOption) => {\n        const newCustomOption = Quill.import(customOption.import)\n        newCustomOption.whitelist = customOption.whitelist\n        Quill.register(newCustomOption, true)\n      })\n\n      let bounds = this.bounds() && this.bounds() === 'self' ? this.editorElem : this.bounds()\n      if (!bounds) {\n        bounds = this.service.config.bounds ? this.service.config.bounds : this.document.body\n      }\n\n      let debug = this.debug()\n      if (!debug && debug !== false && this.service.config.debug) {\n        debug = this.service.config.debug\n      }\n\n      let readOnly = this.readOnly()\n      if (!readOnly && this.readOnly() !== false) {\n        readOnly = this.service.config.readOnly !== undefined ? this.service.config.readOnly : false\n      }\n\n      let formats = this.formats()\n      if (!formats && formats === undefined) {\n        formats = this.service.config.formats ? [...this.service.config.formats] : (this.service.config.formats === null ? null : undefined)\n      }\n\n      this.zone.runOutsideAngular(() => {\n        this.quillEditor = new Quill(this.editorElem, {\n          bounds,\n          debug,\n          formats,\n          modules,\n          placeholder,\n          readOnly,\n          registry: this.registry(),\n          theme: this.theme() || (this.service.config.theme ? this.service.config.theme : 'snow')\n        })\n\n        if (this.onNativeBlur.observed) {\n          // https://github.com/quilljs/quill/issues/2186#issuecomment-533401328\n          fromEvent(this.quillEditor.scroll.domNode, 'blur').pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => this.onNativeBlur.next({\n            editor: this.quillEditor,\n            source: 'dom'\n          }))\n          // https://github.com/quilljs/quill/issues/2186#issuecomment-803257538\n          const toolbar = this.quillEditor.getModule('toolbar') as Toolbar\n          if (toolbar.container) {\n            fromEvent(toolbar.container, 'mousedown').pipe(takeUntilDestroyed(this.destroyRef)).subscribe(e => e.preventDefault())\n          }\n        }\n\n        if (this.onNativeFocus.observed) {\n          fromEvent(this.quillEditor.scroll.domNode, 'focus').pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => this.onNativeFocus.next({\n            editor: this.quillEditor,\n            source: 'dom'\n          }))\n        }\n\n        // Set optional link placeholder, Quill has no native API for it so using workaround\n        if (this.linkPlaceholder()) {\n          const tooltip = (this.quillEditor as any)?.theme?.tooltip\n          const input = tooltip?.root?.querySelector('input[data-link]')\n          if (input?.dataset) {\n            input.dataset.link = this.linkPlaceholder()\n          }\n        }\n      })\n\n      if (this.content) {\n        const format = getFormat(this.format(), this.service.config.format)\n\n        if (format === 'text') {\n          this.quillEditor.setText(this.content, 'silent')\n        } else {\n          const valueSetter = this.valueSetter()\n          const newValue = valueSetter(this.quillEditor, this.content)\n          this.quillEditor.setContents(newValue, 'silent')\n        }\n\n        const history = this.quillEditor.getModule('history') as History\n        history.clear()\n      }\n\n      // initialize disabled status based on this.disabled as default value\n      this.setDisabledState()\n\n      this.addQuillEventListeners()\n\n      // The `requestAnimationFrame` triggers change detection. There's no sense to invoke the `requestAnimationFrame` if anyone is\n      // listening to the `onEditorCreated` event inside the template, for instance `<quill-view (onEditorCreated)=\"...\">`.\n      if (!this.onEditorCreated.observed && !this.onValidatorChanged) {\n        return\n      }\n\n      // The `requestAnimationFrame` will trigger change detection and `onEditorCreated` will also call `markDirty()`\n      // internally, since Angular wraps template event listeners into `listener` instruction. We're using the `requestAnimationFrame`\n      // to prevent the frame drop and avoid `ExpressionChangedAfterItHasBeenCheckedError` error.\n      raf$().pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => {\n        if (this.onValidatorChanged) {\n          this.onValidatorChanged()\n        }\n        this.onEditorCreated.emit(this.quillEditor)\n      })\n    })\n  }\n\n  selectionChangeHandler = (range: Range | null, oldRange: Range | null, source: string) => {\n    const trackChanges = this.trackChanges() || this.service.config.trackChanges\n    const shouldTriggerOnModelTouched = !range && !!this.onModelTouched && (source === 'user' || trackChanges && trackChanges === 'all')\n\n    // only emit changes when there's any listener\n    if (!this.onBlur.observed &&\n      !this.onFocus.observed &&\n      !this.onSelectionChanged.observed &&\n      !shouldTriggerOnModelTouched) {\n      return\n    }\n\n    this.zone.run(() => {\n      if (range === null) {\n        this.onBlur.emit({\n          editor: this.quillEditor,\n          source\n        })\n      } else if (oldRange === null) {\n        this.onFocus.emit({\n          editor: this.quillEditor,\n          source\n        })\n      }\n\n      this.onSelectionChanged.emit({\n        editor: this.quillEditor,\n        oldRange,\n        range,\n        source\n      })\n\n      if (shouldTriggerOnModelTouched) {\n        this.onModelTouched()\n      }\n\n      this.cd.markForCheck()\n    })\n  }\n\n  textChangeHandler = (delta: DeltaType, oldDelta: DeltaType, source: string): void => {\n    // only emit changes emitted by user interactions\n    const text = this.quillEditor.getText()\n    const content = this.quillEditor.getContents()\n\n    let html: string | null = this.quillEditor.getSemanticHTML()\n    if (this.isEmptyValue(html)) {\n      html = this.defaultEmptyValue()\n    }\n\n    const trackChanges = this.trackChanges() || this.service.config.trackChanges\n    const shouldTriggerOnModelChange = (source === 'user' || trackChanges && trackChanges === 'all') && !!this.onModelChange\n\n    // only emit changes when there's any listener\n    if (!this.onContentChanged.observed && !shouldTriggerOnModelChange) {\n      return\n    }\n\n    this.zone.run(() => {\n      if (shouldTriggerOnModelChange) {\n        const valueGetter = this.valueGetter()\n        this.onModelChange(\n          valueGetter(this.quillEditor)\n        )\n      }\n\n      this.onContentChanged.emit({\n        content,\n        delta,\n        editor: this.quillEditor,\n        html,\n        oldDelta,\n        source,\n        text\n      })\n\n      this.cd.markForCheck()\n    })\n  }\n\n  editorChangeHandler = (\n    event: 'text-change' | 'selection-change',\n    current: any | Range | null, old: any | Range | null, source: string\n  ): void => {\n    // only emit changes when there's any listener\n    if (!this.onEditorChanged.observed) {\n      return\n    }\n\n    // only emit changes emitted by user interactions\n    if (event === 'text-change') {\n      const text = this.quillEditor.getText()\n      const content = this.quillEditor.getContents()\n\n      let html: string | null = this.quillEditor.getSemanticHTML()\n      if (this.isEmptyValue(html)) {\n        html = this.defaultEmptyValue()\n      }\n\n      this.zone.run(() => {\n        this.onEditorChanged.emit({\n          content,\n          delta: current,\n          editor: this.quillEditor,\n          event,\n          html,\n          oldDelta: old,\n          source,\n          text\n        })\n\n        this.cd.markForCheck()\n      })\n    } else {\n      this.zone.run(() => {\n        this.onEditorChanged.emit({\n          editor: this.quillEditor,\n          event,\n          oldRange: old,\n          range: current,\n          source\n        })\n\n        this.cd.markForCheck()\n      })\n    }\n  }\n\n  ngOnDestroy() {\n    this.dispose()\n\n    this.quillSubscription?.unsubscribe()\n    this.quillSubscription = null\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (!this.quillEditor) {\n      return\n    }\n    if (changes.readOnly) {\n      this.quillEditor.enable(!changes.readOnly.currentValue)\n    }\n    if (changes.placeholder) {\n      this.quillEditor.root.dataset.placeholder =\n        changes.placeholder.currentValue\n    }\n    if (changes.styles) {\n      const currentStyling = changes.styles.currentValue\n      const previousStyling = changes.styles.previousValue\n\n      if (previousStyling) {\n        Object.keys(previousStyling).forEach((key: string) => {\n          this.renderer.removeStyle(this.editorElem, key)\n        })\n      }\n      if (currentStyling) {\n        Object.keys(currentStyling).forEach((key: string) => {\n          this.renderer.setStyle(this.editorElem, key, this.styles()[key])\n        })\n      }\n    }\n    if (changes.classes) {\n      const currentClasses = changes.classes.currentValue\n      const previousClasses = changes.classes.previousValue\n\n      if (previousClasses) {\n        this.removeClasses(previousClasses)\n      }\n\n      if (currentClasses) {\n        this.addClasses(currentClasses)\n      }\n    }\n    // We'd want to re-apply event listeners if the `debounceTime` binding changes to apply the\n    // `debounceTime` operator or vice-versa remove it.\n    if (changes.debounceTime) {\n      this.addQuillEventListeners()\n    }\n  }\n\n  addClasses(classList: string): void {\n    QuillEditorBase.normalizeClassNames(classList).forEach((c: string) => {\n      this.renderer.addClass(this.editorElem, c)\n    })\n  }\n\n  removeClasses(classList: string): void {\n    QuillEditorBase.normalizeClassNames(classList).forEach((c: string) => {\n      this.renderer.removeClass(this.editorElem, c)\n    })\n  }\n\n  writeValue(currentValue: any) {\n\n    // optional fix for https://github.com/angular/angular/issues/14988\n    if (this.filterNull() && currentValue === null) {\n      return\n    }\n\n    this.content = currentValue\n\n    if (!this.quillEditor) {\n      return\n    }\n\n    const format = getFormat(this.format(), this.service.config.format)\n    const valueSetter = this.valueSetter()\n    const newValue = valueSetter(this.quillEditor, currentValue)\n\n    if (this.compareValues()) {\n      const currentEditorValue = this.quillEditor.getContents()\n      if (JSON.stringify(currentEditorValue) === JSON.stringify(newValue)) {\n        return\n      }\n    }\n\n    if (currentValue) {\n      if (format === 'text') {\n        this.quillEditor.setText(currentValue)\n      } else {\n        this.quillEditor.setContents(newValue)\n      }\n      return\n    }\n    this.quillEditor.setText('')\n\n  }\n\n  setDisabledState(isDisabled: boolean = this.disabled): void {\n    // store initial value to set appropriate disabled status after ViewInit\n    this.disabled = isDisabled\n    if (this.quillEditor) {\n      if (isDisabled) {\n        this.quillEditor.disable()\n        this.renderer.setAttribute(this.elementRef.nativeElement, 'disabled', 'disabled')\n      } else {\n        if (!this.readOnly()) {\n          this.quillEditor.enable()\n        }\n        this.renderer.removeAttribute(this.elementRef.nativeElement, 'disabled')\n      }\n    }\n  }\n\n  registerOnChange(fn: (modelValue: any) => void): void {\n    this.onModelChange = fn\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onModelTouched = fn\n  }\n\n  registerOnValidatorChange(fn: () => void) {\n    this.onValidatorChanged = fn\n  }\n\n  validate() {\n    if (!this.quillEditor) {\n      return null\n    }\n\n    const err: {\n      minLengthError?: {\n        given: number\n        minLength: number\n      }\n      maxLengthError?: {\n        given: number\n        maxLength: number\n      }\n      requiredError?: { empty: boolean }\n    } = {}\n    let valid = true\n\n    const text = this.quillEditor.getText()\n    // trim text if wanted + handle special case that an empty editor contains a new line\n    const textLength = this.trimOnValidation() ? text.trim().length : (text.length === 1 && text.trim().length === 0 ? 0 : text.length - 1)\n    const deltaOperations = this.quillEditor.getContents().ops\n    const onlyEmptyOperation = !!deltaOperations && deltaOperations.length === 1 && ['\\n', ''].includes(deltaOperations[0].insert?.toString())\n\n    if (this.minLength() && textLength && textLength < this.minLength()) {\n      err.minLengthError = {\n        given: textLength,\n        minLength: this.minLength()\n      }\n\n      valid = false\n    }\n\n    if (this.maxLength() && textLength > this.maxLength()) {\n      err.maxLengthError = {\n        given: textLength,\n        maxLength: this.maxLength()\n      }\n\n      valid = false\n    }\n\n    if (this.required() && !textLength && onlyEmptyOperation) {\n      err.requiredError = {\n        empty: true\n      }\n\n      valid = false\n    }\n\n    return valid ? null : err\n  }\n\n  private addQuillEventListeners(): void {\n    this.dispose()\n\n    // We have to enter the `<root>` zone when adding event listeners, so `debounceTime` will spawn the\n    // `AsyncAction` there w/o triggering change detections. We still re-enter the Angular's zone through\n    // `zone.run` when we emit an event to the parent component.\n    this.zone.runOutsideAngular(() => {\n      this.subscription = new Subscription()\n\n      this.subscription.add(\n        // mark model as touched if editor lost focus\n        fromEvent(this.quillEditor, 'selection-change').subscribe(\n          ([range, oldRange, source]) => {\n            this.selectionChangeHandler(range as any, oldRange as any, source)\n          }\n        )\n      )\n\n      // The `fromEvent` supports passing JQuery-style event targets, the editor has `on` and `off` methods which\n      // will be invoked upon subscription and teardown.\n      let textChange$ = fromEvent(this.quillEditor, 'text-change')\n      let editorChange$ = fromEvent(this.quillEditor, 'editor-change')\n\n      if (typeof this.debounceTime() === 'number') {\n        textChange$ = textChange$.pipe(debounceTime(this.debounceTime()))\n        editorChange$ = editorChange$.pipe(debounceTime(this.debounceTime()))\n      }\n\n      this.subscription.add(\n        // update model if text changes\n        textChange$.subscribe(([delta, oldDelta, source]) => {\n          this.textChangeHandler(delta as any, oldDelta as any, source)\n        })\n      )\n\n      this.subscription.add(\n        // triggered if selection or text changed\n        editorChange$.subscribe(([event, current, old, source]) => {\n          this.editorChangeHandler(event as 'text-change' | 'selection-change', current, old, source)\n        })\n      )\n    })\n  }\n\n  private dispose(): void {\n    if (this.subscription !== null) {\n      this.subscription.unsubscribe()\n      this.subscription = null\n    }\n  }\n\n  private isEmptyValue(html: string | null) {\n    return html === '<p></p>' || html === '<div></div>' || html === '<p><br></p>' || html === '<div><br></div>'\n  }\n}\n\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/no-forward-ref","severity":2,"message":"Avoid using `forwardRef`","line":736,"column":20,"nodeType":"CallExpression","messageId":"noForwardRef","endLine":736,"endColumn":58},{"ruleId":"@angular-eslint/no-forward-ref","severity":2,"message":"Avoid using `forwardRef`","line":741,"column":20,"nodeType":"CallExpression","messageId":"noForwardRef","endLine":741,"endColumn":58},{"ruleId":"@angular-eslint/component-selector","severity":2,"message":"The selector should start with one of these prefixes: \"lib\" (https://angular.dev/style-guide#style-02-07)","line":744,"column":13,"nodeType":"Literal","messageId":"prefixFailure","endLine":744,"endColumn":27},{"ruleId":"@angular-eslint/component-max-inline-declarations","severity":2,"message":"`template` has too many lines (11). Maximum allowed is 3 (https://angular.dev/style-guide#style-05-04)","line":745,"column":13,"nodeType":"TemplateLiteral","messageId":"componentMaxInlineDeclarations","endLine":757,"endColumn":4}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DOCUMENT, isPlatformServer } from '@angular/common'\nimport { DomSanitizer } from '@angular/platform-browser'\n\nimport type QuillType from 'quill'\nimport type { QuillOptions } from 'quill'\nimport type DeltaType from 'quill-delta'\n\nimport {\n  AfterViewInit,\n  ChangeDetectorRef,\n  Component,\n  DestroyRef,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  forwardRef,\n  inject,\n  input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Output,\n  PLATFORM_ID,\n  Renderer2,\n  SecurityContext,\n  signal,\n  SimpleChanges,\n  ViewEncapsulation\n} from '@angular/core'\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop'\nimport { fromEvent, Subscription } from 'rxjs'\nimport { debounceTime, mergeMap } from 'rxjs/operators'\n\nimport { ControlValueAccessor, NG_VALIDATORS, NG_VALUE_ACCESSOR, Validator } from '@angular/forms'\n\nimport { CustomModule, CustomOption, defaultModules, QuillBeforeRender, QuillModules } from 'ngx-quill/config'\n\nimport type History from 'quill/modules/history'\nimport type Toolbar from 'quill/modules/toolbar'\nimport { getFormat, raf$ } from './helpers'\nimport { QuillService } from './quill.service'\n\nexport interface Range {\n  index: number\n  length: number\n}\n\nexport interface ContentChange {\n  content: DeltaType\n  delta: DeltaType\n  editor: QuillType\n  html: string | null\n  oldDelta: DeltaType\n  source: string\n  text: string\n}\n\nexport interface SelectionChange {\n  editor: QuillType\n  oldRange: Range | null\n  range: Range | null\n  source: string\n}\n\nexport interface Blur {\n  editor: QuillType\n  source: string\n}\n\nexport interface Focus {\n  editor: QuillType\n  source: string\n}\n\nexport type EditorChangeContent = ContentChange & { event: 'text-change' }\nexport type EditorChangeSelection = SelectionChange & { event: 'selection-change' }\n\n@Directive()\nexport abstract class QuillEditorBase implements AfterViewInit, ControlValueAccessor, OnChanges, OnInit, OnDestroy, Validator {\n  readonly format = input<'object' | 'html' | 'text' | 'json' | undefined>(\n    undefined\n  )\n  readonly theme = input<string | undefined>(undefined)\n  readonly modules = input<QuillModules | undefined>(undefined)\n  readonly debug = input<'warn' | 'log' | 'error' | false>(false)\n  readonly readOnly = input<boolean | undefined>(false)\n  readonly placeholder = input<string | undefined>(undefined)\n  readonly maxLength = input<number | undefined>(undefined)\n  readonly minLength = input<number | undefined>(undefined)\n  readonly required = input(false)\n  readonly formats = input<string[] | null | undefined>(undefined)\n  readonly customToolbarPosition = input<'top' | 'bottom'>('top')\n  readonly sanitize = input<boolean | undefined>(undefined)\n  readonly beforeRender = input<QuillBeforeRender>(undefined)\n  readonly styles = input<any>(null)\n  readonly registry = input<QuillOptions['registry']>(\n    undefined\n  )\n  readonly bounds = input<HTMLElement | string | undefined>(undefined)\n  readonly customOptions = input<CustomOption[]>([])\n  readonly customModules = input<CustomModule[]>([])\n  readonly trackChanges = input<'user' | 'all' | undefined>(undefined)\n  readonly classes = input<string | undefined>(undefined)\n  readonly trimOnValidation = input(false)\n  readonly linkPlaceholder = input<string | undefined>(undefined)\n  readonly compareValues = input(false)\n  readonly filterNull = input(false)\n  readonly debounceTime = input<number | undefined>(undefined)\n  /*\n  https://github.com/KillerCodeMonkey/ngx-quill/issues/1257 - fix null value set\n\n  provide default empty value\n  by default null\n\n  e.g. defaultEmptyValue=\"\" - empty string\n\n  <quill-editor\n    defaultEmptyValue=\"\"\n    formControlName=\"message\"\n  ></quill-editor>\n  */\n  readonly defaultEmptyValue = input<any>(null)\n\n  @Output() onEditorCreated = new EventEmitter<QuillType>()\n  @Output() onEditorChanged = new EventEmitter<EditorChangeContent | EditorChangeSelection>()\n  @Output() onContentChanged = new EventEmitter<ContentChange>()\n  @Output() onSelectionChanged = new EventEmitter<SelectionChange>()\n  @Output() onFocus = new EventEmitter<Focus>()\n  @Output() onBlur = new EventEmitter<Blur>()\n  @Output() onNativeFocus = new EventEmitter<Focus>()\n  @Output() onNativeBlur = new EventEmitter<Blur>()\n\n  quillEditor!: QuillType\n  editorElem!: HTMLElement\n  content: any\n  disabled = false // used to store initial value before ViewInit\n\n  readonly toolbarPosition = signal('top')\n\n  onModelChange: (modelValue?: any) => void\n  onModelTouched: () => void\n  onValidatorChanged: () => void\n\n  private subscription: Subscription | null = null\n  private quillSubscription: Subscription | null = null\n\n  private elementRef = inject(ElementRef)\n  private document = inject(DOCUMENT)\n\n  private cd = inject(ChangeDetectorRef)\n  private domSanitizer = inject(DomSanitizer)\n  private platformId = inject<string>(PLATFORM_ID)\n  private renderer = inject(Renderer2)\n  private zone = inject(NgZone)\n  private service = inject(QuillService)\n  private destroyRef = inject(DestroyRef)\n\n  static normalizeClassNames(classes: string): string[] {\n    const classList = classes.trim().split(' ')\n    return classList.reduce((prev: string[], cur: string) => {\n      const trimmed = cur.trim()\n      if (trimmed) {\n        prev.push(trimmed)\n      }\n\n      return prev\n    }, [])\n  }\n\n  valueGetter = input((quillEditor: QuillType): string | any => {\n    let html: string | null = quillEditor.getSemanticHTML()\n    if (this.isEmptyValue(html)) {\n      html = this.defaultEmptyValue()\n    }\n    let modelValue: string | DeltaType | null = html\n    const format = getFormat(this.format(), this.service.config.format)\n\n    if (format === 'text') {\n      modelValue = quillEditor.getText()\n    } else if (format === 'object') {\n      modelValue = quillEditor.getContents()\n    } else if (format === 'json') {\n      try {\n        modelValue = JSON.stringify(quillEditor.getContents())\n      } catch {\n        modelValue = quillEditor.getText()\n      }\n    }\n\n    return modelValue\n  })\n\n  valueSetter = input((quillEditor: QuillType, value: any): any => {\n    const format = getFormat(this.format(), this.service.config.format)\n    if (format === 'html') {\n      const sanitize = [true, false].includes(this.sanitize()) ? this.sanitize() : (this.service.config.sanitize || false)\n      if (sanitize) {\n        value = this.domSanitizer.sanitize(SecurityContext.HTML, value)\n      }\n      return quillEditor.clipboard.convert({ html: value })\n    } else if (format === 'json') {\n      try {\n        return JSON.parse(value)\n      } catch {\n        return [{ insert: value }]\n      }\n    }\n\n    return value\n  })\n\n  ngOnInit() {\n    this.toolbarPosition.set(this.customToolbarPosition())\n  }\n\n  ngAfterViewInit() {\n    if (isPlatformServer(this.platformId)) {\n      return\n    }\n\n    // The `quill-editor` component might be destroyed before the `quill` chunk is loaded and its code is executed\n    // this will lead to runtime exceptions, since the code will be executed on DOM nodes that don't exist within the tree.\n\n    this.quillSubscription = this.service.getQuill().pipe(\n      mergeMap((Quill) => this.service.beforeRender(Quill, this.customModules(), this.beforeRender()))\n    ).subscribe(Quill => {\n      this.editorElem = this.elementRef.nativeElement.querySelector(\n        '[quill-editor-element]'\n      )\n\n      const toolbarElem = this.elementRef.nativeElement.querySelector(\n        '[quill-editor-toolbar]'\n      )\n      const modules = Object.assign({}, this.modules() || this.service.config.modules)\n\n      if (toolbarElem) {\n        modules.toolbar = toolbarElem\n      } else if (modules.toolbar === undefined) {\n        modules.toolbar = defaultModules.toolbar\n      }\n\n      let placeholder = this.placeholder() !== undefined ? this.placeholder() : this.service.config.placeholder\n      if (placeholder === undefined) {\n        placeholder = 'Insert text here ...'\n      }\n\n      const styles = this.styles()\n      if (styles) {\n        Object.keys(styles).forEach((key: string) => {\n          this.renderer.setStyle(this.editorElem, key, styles[key])\n        })\n      }\n\n      if (this.classes()) {\n        this.addClasses(this.classes())\n      }\n\n      this.customOptions().forEach((customOption) => {\n        const newCustomOption = Quill.import(customOption.import)\n        newCustomOption.whitelist = customOption.whitelist\n        Quill.register(newCustomOption, true)\n      })\n\n      let bounds = this.bounds() && this.bounds() === 'self' ? this.editorElem : this.bounds()\n      if (!bounds) {\n        bounds = this.service.config.bounds ? this.service.config.bounds : this.document.body\n      }\n\n      let debug = this.debug()\n      if (!debug && debug !== false && this.service.config.debug) {\n        debug = this.service.config.debug\n      }\n\n      let readOnly = this.readOnly()\n      if (!readOnly && this.readOnly() !== false) {\n        readOnly = this.service.config.readOnly !== undefined ? this.service.config.readOnly : false\n      }\n\n      let formats = this.formats()\n      if (!formats && formats === undefined) {\n        formats = this.service.config.formats ? [...this.service.config.formats] : (this.service.config.formats === null ? null : undefined)\n      }\n\n      this.zone.runOutsideAngular(() => {\n        this.quillEditor = new Quill(this.editorElem, {\n          bounds,\n          debug,\n          formats,\n          modules,\n          placeholder,\n          readOnly,\n          registry: this.registry(),\n          theme: this.theme() || (this.service.config.theme ? this.service.config.theme : 'snow')\n        })\n\n        if (this.onNativeBlur.observed) {\n          // https://github.com/quilljs/quill/issues/2186#issuecomment-533401328\n          fromEvent(this.quillEditor.scroll.domNode, 'blur').pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => this.onNativeBlur.next({\n            editor: this.quillEditor,\n            source: 'dom'\n          }))\n          // https://github.com/quilljs/quill/issues/2186#issuecomment-803257538\n          const toolbar = this.quillEditor.getModule('toolbar') as Toolbar\n          if (toolbar.container) {\n            fromEvent(toolbar.container, 'mousedown').pipe(takeUntilDestroyed(this.destroyRef)).subscribe(e => e.preventDefault())\n          }\n        }\n\n        if (this.onNativeFocus.observed) {\n          fromEvent(this.quillEditor.scroll.domNode, 'focus').pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => this.onNativeFocus.next({\n            editor: this.quillEditor,\n            source: 'dom'\n          }))\n        }\n\n        // Set optional link placeholder, Quill has no native API for it so using workaround\n        if (this.linkPlaceholder()) {\n          const tooltip = (this.quillEditor as any)?.theme?.tooltip\n          const input = tooltip?.root?.querySelector('input[data-link]')\n          if (input?.dataset) {\n            input.dataset.link = this.linkPlaceholder()\n          }\n        }\n      })\n\n      if (this.content) {\n        const format = getFormat(this.format(), this.service.config.format)\n\n        if (format === 'text') {\n          this.quillEditor.setText(this.content, 'silent')\n        } else {\n          const valueSetter = this.valueSetter()\n          const newValue = valueSetter(this.quillEditor, this.content)\n          this.quillEditor.setContents(newValue, 'silent')\n        }\n\n        const history = this.quillEditor.getModule('history') as History\n        history.clear()\n      }\n\n      // initialize disabled status based on this.disabled as default value\n      this.setDisabledState()\n\n      this.addQuillEventListeners()\n\n      // The `requestAnimationFrame` triggers change detection. There's no sense to invoke the `requestAnimationFrame` if anyone is\n      // listening to the `onEditorCreated` event inside the template, for instance `<quill-view (onEditorCreated)=\"...\">`.\n      if (!this.onEditorCreated.observed && !this.onValidatorChanged) {\n        return\n      }\n\n      // The `requestAnimationFrame` will trigger change detection and `onEditorCreated` will also call `markDirty()`\n      // internally, since Angular wraps template event listeners into `listener` instruction. We're using the `requestAnimationFrame`\n      // to prevent the frame drop and avoid `ExpressionChangedAfterItHasBeenCheckedError` error.\n      raf$().pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => {\n        if (this.onValidatorChanged) {\n          this.onValidatorChanged()\n        }\n        this.onEditorCreated.emit(this.quillEditor)\n      })\n    })\n  }\n\n  selectionChangeHandler = (range: Range | null, oldRange: Range | null, source: string) => {\n    const trackChanges = this.trackChanges() || this.service.config.trackChanges\n    const shouldTriggerOnModelTouched = !range && !!this.onModelTouched && (source === 'user' || trackChanges && trackChanges === 'all')\n\n    // only emit changes when there's any listener\n    if (!this.onBlur.observed &&\n      !this.onFocus.observed &&\n      !this.onSelectionChanged.observed &&\n      !shouldTriggerOnModelTouched) {\n      return\n    }\n\n    this.zone.run(() => {\n      if (range === null) {\n        this.onBlur.emit({\n          editor: this.quillEditor,\n          source\n        })\n      } else if (oldRange === null) {\n        this.onFocus.emit({\n          editor: this.quillEditor,\n          source\n        })\n      }\n\n      this.onSelectionChanged.emit({\n        editor: this.quillEditor,\n        oldRange,\n        range,\n        source\n      })\n\n      if (shouldTriggerOnModelTouched) {\n        this.onModelTouched()\n      }\n\n      this.cd.markForCheck()\n    })\n  }\n\n  textChangeHandler = (delta: DeltaType, oldDelta: DeltaType, source: string): void => {\n    // only emit changes emitted by user interactions\n    const text = this.quillEditor.getText()\n    const content = this.quillEditor.getContents()\n\n    let html: string | null = this.quillEditor.getSemanticHTML()\n    if (this.isEmptyValue(html)) {\n      html = this.defaultEmptyValue()\n    }\n\n    const trackChanges = this.trackChanges() || this.service.config.trackChanges\n    const shouldTriggerOnModelChange = (source === 'user' || trackChanges && trackChanges === 'all') && !!this.onModelChange\n\n    // only emit changes when there's any listener\n    if (!this.onContentChanged.observed && !shouldTriggerOnModelChange) {\n      return\n    }\n\n    this.zone.run(() => {\n      if (shouldTriggerOnModelChange) {\n        const valueGetter = this.valueGetter()\n        this.onModelChange(\n          valueGetter(this.quillEditor)\n        )\n      }\n\n      this.onContentChanged.emit({\n        content,\n        delta,\n        editor: this.quillEditor,\n        html,\n        oldDelta,\n        source,\n        text\n      })\n\n      this.cd.markForCheck()\n    })\n  }\n\n  editorChangeHandler = (\n    event: 'text-change' | 'selection-change',\n    current: any | Range | null, old: any | Range | null, source: string\n  ): void => {\n    // only emit changes when there's any listener\n    if (!this.onEditorChanged.observed) {\n      return\n    }\n\n    // only emit changes emitted by user interactions\n    if (event === 'text-change') {\n      const text = this.quillEditor.getText()\n      const content = this.quillEditor.getContents()\n\n      let html: string | null = this.quillEditor.getSemanticHTML()\n      if (this.isEmptyValue(html)) {\n        html = this.defaultEmptyValue()\n      }\n\n      this.zone.run(() => {\n        this.onEditorChanged.emit({\n          content,\n          delta: current,\n          editor: this.quillEditor,\n          event,\n          html,\n          oldDelta: old,\n          source,\n          text\n        })\n\n        this.cd.markForCheck()\n      })\n    } else {\n      this.zone.run(() => {\n        this.onEditorChanged.emit({\n          editor: this.quillEditor,\n          event,\n          oldRange: old,\n          range: current,\n          source\n        })\n\n        this.cd.markForCheck()\n      })\n    }\n  }\n\n  ngOnDestroy() {\n    this.dispose()\n\n    this.quillSubscription?.unsubscribe()\n    this.quillSubscription = null\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (!this.quillEditor) {\n      return\n    }\n    if (changes.readOnly) {\n      this.quillEditor.enable(!changes.readOnly.currentValue)\n    }\n    if (changes.placeholder) {\n      this.quillEditor.root.dataset.placeholder =\n        changes.placeholder.currentValue\n    }\n    if (changes.styles) {\n      const currentStyling = changes.styles.currentValue\n      const previousStyling = changes.styles.previousValue\n\n      if (previousStyling) {\n        Object.keys(previousStyling).forEach((key: string) => {\n          this.renderer.removeStyle(this.editorElem, key)\n        })\n      }\n      if (currentStyling) {\n        Object.keys(currentStyling).forEach((key: string) => {\n          this.renderer.setStyle(this.editorElem, key, this.styles()[key])\n        })\n      }\n    }\n    if (changes.classes) {\n      const currentClasses = changes.classes.currentValue\n      const previousClasses = changes.classes.previousValue\n\n      if (previousClasses) {\n        this.removeClasses(previousClasses)\n      }\n\n      if (currentClasses) {\n        this.addClasses(currentClasses)\n      }\n    }\n    // We'd want to re-apply event listeners if the `debounceTime` binding changes to apply the\n    // `debounceTime` operator or vice-versa remove it.\n    if (changes.debounceTime) {\n      this.addQuillEventListeners()\n    }\n  }\n\n  addClasses(classList: string): void {\n    QuillEditorBase.normalizeClassNames(classList).forEach((c: string) => {\n      this.renderer.addClass(this.editorElem, c)\n    })\n  }\n\n  removeClasses(classList: string): void {\n    QuillEditorBase.normalizeClassNames(classList).forEach((c: string) => {\n      this.renderer.removeClass(this.editorElem, c)\n    })\n  }\n\n  writeValue(currentValue: any) {\n\n    // optional fix for https://github.com/angular/angular/issues/14988\n    if (this.filterNull() && currentValue === null) {\n      return\n    }\n\n    this.content = currentValue\n\n    if (!this.quillEditor) {\n      return\n    }\n\n    const format = getFormat(this.format(), this.service.config.format)\n    const valueSetter = this.valueSetter()\n    const newValue = valueSetter(this.quillEditor, currentValue)\n\n    if (this.compareValues()) {\n      const currentEditorValue = this.quillEditor.getContents()\n      if (JSON.stringify(currentEditorValue) === JSON.stringify(newValue)) {\n        return\n      }\n    }\n\n    if (currentValue) {\n      if (format === 'text') {\n        this.quillEditor.setText(currentValue)\n      } else {\n        this.quillEditor.setContents(newValue)\n      }\n      return\n    }\n    this.quillEditor.setText('')\n\n  }\n\n  setDisabledState(isDisabled: boolean = this.disabled): void {\n    // store initial value to set appropriate disabled status after ViewInit\n    this.disabled = isDisabled\n    if (this.quillEditor) {\n      if (isDisabled) {\n        this.quillEditor.disable()\n        this.renderer.setAttribute(this.elementRef.nativeElement, 'disabled', 'disabled')\n      } else {\n        if (!this.readOnly()) {\n          this.quillEditor.enable()\n        }\n        this.renderer.removeAttribute(this.elementRef.nativeElement, 'disabled')\n      }\n    }\n  }\n\n  registerOnChange(fn: (modelValue: any) => void): void {\n    this.onModelChange = fn\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onModelTouched = fn\n  }\n\n  registerOnValidatorChange(fn: () => void) {\n    this.onValidatorChanged = fn\n  }\n\n  validate() {\n    if (!this.quillEditor) {\n      return null\n    }\n\n    const err: {\n      minLengthError?: {\n        given: number\n        minLength: number\n      }\n      maxLengthError?: {\n        given: number\n        maxLength: number\n      }\n      requiredError?: { empty: boolean }\n    } = {}\n    let valid = true\n\n    const text = this.quillEditor.getText()\n    // trim text if wanted + handle special case that an empty editor contains a new line\n    const textLength = this.trimOnValidation() ? text.trim().length : (text.length === 1 && text.trim().length === 0 ? 0 : text.length - 1)\n    const deltaOperations = this.quillEditor.getContents().ops\n    const onlyEmptyOperation = !!deltaOperations && deltaOperations.length === 1 && ['\\n', ''].includes(deltaOperations[0].insert?.toString())\n\n    if (this.minLength() && textLength && textLength < this.minLength()) {\n      err.minLengthError = {\n        given: textLength,\n        minLength: this.minLength()\n      }\n\n      valid = false\n    }\n\n    if (this.maxLength() && textLength > this.maxLength()) {\n      err.maxLengthError = {\n        given: textLength,\n        maxLength: this.maxLength()\n      }\n\n      valid = false\n    }\n\n    if (this.required() && !textLength && onlyEmptyOperation) {\n      err.requiredError = {\n        empty: true\n      }\n\n      valid = false\n    }\n\n    return valid ? null : err\n  }\n\n  private addQuillEventListeners(): void {\n    this.dispose()\n\n    // We have to enter the `<root>` zone when adding event listeners, so `debounceTime` will spawn the\n    // `AsyncAction` there w/o triggering change detections. We still re-enter the Angular's zone through\n    // `zone.run` when we emit an event to the parent component.\n    this.zone.runOutsideAngular(() => {\n      this.subscription = new Subscription()\n\n      this.subscription.add(\n        // mark model as touched if editor lost focus\n        fromEvent(this.quillEditor, 'selection-change').subscribe(\n          ([range, oldRange, source]) => {\n            this.selectionChangeHandler(range as any, oldRange as any, source)\n          }\n        )\n      )\n\n      // The `fromEvent` supports passing JQuery-style event targets, the editor has `on` and `off` methods which\n      // will be invoked upon subscription and teardown.\n      let textChange$ = fromEvent(this.quillEditor, 'text-change')\n      let editorChange$ = fromEvent(this.quillEditor, 'editor-change')\n\n      if (typeof this.debounceTime() === 'number') {\n        textChange$ = textChange$.pipe(debounceTime(this.debounceTime()))\n        editorChange$ = editorChange$.pipe(debounceTime(this.debounceTime()))\n      }\n\n      this.subscription.add(\n        // update model if text changes\n        textChange$.subscribe(([delta, oldDelta, source]) => {\n          this.textChangeHandler(delta as any, oldDelta as any, source)\n        })\n      )\n\n      this.subscription.add(\n        // triggered if selection or text changed\n        editorChange$.subscribe(([event, current, old, source]) => {\n          this.editorChangeHandler(event as 'text-change' | 'selection-change', current, old, source)\n        })\n      )\n    })\n  }\n\n  private dispose(): void {\n    if (this.subscription !== null) {\n      this.subscription.unsubscribe()\n      this.subscription = null\n    }\n  }\n\n  private isEmptyValue(html: string | null) {\n    return html === '<p></p>' || html === '<div></div>' || html === '<p><br></p>' || html === '<div><br></div>'\n  }\n}\n\n@Component({\n  encapsulation: ViewEncapsulation.Emulated,\n  providers: [\n    {\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => QuillEditorComponent)\n    },\n    {\n      multi: true,\n      provide: NG_VALIDATORS,\n      useExisting: forwardRef(() => QuillEditorComponent)\n    }\n  ],\n  selector: 'quill-editor',\n  template: `\n    @if (toolbarPosition() !== 'top') {\n        <div quill-editor-element></div>\n    }\n\n    <ng-content select=\"[above-quill-editor-toolbar]\"></ng-content>\n    <ng-content select=\"[quill-editor-toolbar]\"></ng-content>\n    <ng-content select=\"[below-quill-editor-toolbar]\"></ng-content>\n\n    @if (toolbarPosition() === 'top') {\n        <div quill-editor-element></div>\n    }\n  `,\n  styles: `\n    :host {\n      display: inline-block;\n    }\n    `\n})\nexport class QuillEditorComponent extends QuillEditorBase { }\n","usedDeprecatedRules":[]},{"filePath":"/home/migudel/Documentos/TFG/repos/articulo/ngx-quill/projects/ngx-quill/src/lib/quill-view-html.component.ts","messages":[{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":14,"column":1,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":29,"endColumn":3,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[247,287],"text":", ChangeDetectionStrategy\n} from '@angular/core'\n\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/use-component-view-encapsulation","severity":2,"message":"Using `ViewEncapsulation.None` makes your styles global, which may have an unintended effect","line":16,"column":36,"nodeType":"Identifier","messageId":"useComponentViewEncapsulation","endLine":16,"endColumn":40,"suggestions":[{"messageId":"suggestRemoveViewEncapsulationNone","fix":{"range":[207,347],"text":",\n  input,\n  signal\n} from '@angular/core'\n\n@Component({\n  imports: [NgClass],\n  "},"desc":"Remove `ViewEncapsulation.None`"}]},{"ruleId":"@angular-eslint/component-selector","severity":2,"message":"The selector should start with one of these prefixes: \"lib\" (https://angular.dev/style-guide#style-02-07)","line":17,"column":13,"nodeType":"Literal","messageId":"prefixFailure","endLine":17,"endColumn":30},{"ruleId":"@angular-eslint/component-max-inline-declarations","severity":2,"message":"`template` has too many lines (4). Maximum allowed is 3 (https://angular.dev/style-guide#style-05-04)","line":23,"column":13,"nodeType":"TemplateLiteral","messageId":"componentMaxInlineDeclarations","endLine":28,"endColumn":2}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { DomSanitizer, SafeHtml } from '@angular/platform-browser'\nimport { QuillService } from './quill.service'\n\nimport { NgClass } from '@angular/common'\nimport {\n  Component,\n  OnChanges,\n  SimpleChanges,\n  ViewEncapsulation,\n  input,\n  signal\n} from '@angular/core'\n\n@Component({\n  imports: [NgClass],\n  encapsulation: ViewEncapsulation.None,\n  selector: 'quill-view-html',\n  styles: `\n.ql-container.ngx-quill-view-html {\n  border: 0;\n}\n`,\n  template: `\n  <div class=\"ql-container\" [ngClass]=\"themeClass()\">\n    <div class=\"ql-editor\" [innerHTML]=\"innerHTML()\">\n    </div>\n  </div>\n`\n})\nexport class QuillViewHTMLComponent implements OnChanges {\n  readonly content = input('')\n  readonly theme = input<string | undefined>(undefined)\n  readonly sanitize = input<boolean | undefined>(undefined)\n\n  readonly innerHTML = signal<SafeHtml>('')\n  readonly themeClass = signal('ql-snow')\n\n  constructor(\n    private sanitizer: DomSanitizer,\n    protected service: QuillService\n  ) {}\n\n  ngOnChanges(changes: SimpleChanges) {\n    if (changes.theme) {\n      const theme = changes.theme.currentValue || (this.service.config.theme ? this.service.config.theme : 'snow')\n      this.themeClass.set(`ql-${theme} ngx-quill-view-html`)\n    } else if (!this.theme()) {\n      const theme = this.service.config.theme ? this.service.config.theme : 'snow'\n      this.themeClass.set(`ql-${theme} ngx-quill-view-html`)\n    }\n    if (changes.content) {\n      const content = changes.content.currentValue\n      const sanitize = [true, false].includes(this.sanitize()) ? this.sanitize() : (this.service.config.sanitize || false)\n      const innerHTML = sanitize ? content : this.sanitizer.bypassSecurityTrustHtml(content)\n      this.innerHTML.set(innerHTML)\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/migudel/Documentos/TFG/repos/articulo/ngx-quill/projects/ngx-quill/src/lib/quill-view.component.ts","messages":[{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":33,"column":1,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":44,"endColumn":3,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[328,760],"text":", ChangeDetectionStrategy\n} from '@angular/core'\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop'\nimport { DomSanitizer } from '@angular/platform-browser'\nimport type { Subscription } from 'rxjs'\nimport { mergeMap } from 'rxjs/operators'\n\nimport { CustomModule, CustomOption, QuillBeforeRender, QuillModules } from 'ngx-quill/config'\n\nimport { getFormat, raf$ } from './helpers'\nimport { QuillService } from './quill.service'\n\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/use-component-view-encapsulation","severity":2,"message":"Using `ViewEncapsulation.None` makes your styles global, which may have an unintended effect","line":34,"column":36,"nodeType":"Identifier","messageId":"useComponentViewEncapsulation","endLine":34,"endColumn":40,"suggestions":[{"messageId":"suggestRemoveViewEncapsulationNone","fix":{"range":[288,798],"text":",\n  inject,\n  input\n} from '@angular/core'\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop'\nimport { DomSanitizer } from '@angular/platform-browser'\nimport type { Subscription } from 'rxjs'\nimport { mergeMap } from 'rxjs/operators'\n\nimport { CustomModule, CustomOption, QuillBeforeRender, QuillModules } from 'ngx-quill/config'\n\nimport { getFormat, raf$ } from './helpers'\nimport { QuillService } from './quill.service'\n\n@Component({\n  "},"desc":"Remove `ViewEncapsulation.None`"}]},{"ruleId":"@angular-eslint/component-selector","severity":2,"message":"The selector should start with one of these prefixes: \"lib\" (https://angular.dev/style-guide#style-02-07)","line":35,"column":13,"nodeType":"Literal","messageId":"prefixFailure","endLine":35,"endColumn":25},{"ruleId":"@angular-eslint/prefer-output-readonly","severity":2,"message":"Prefer to declare `@Output` as `readonly` since they are not supposed to be reassigned","line":60,"column":13,"nodeType":"Identifier","messageId":"preferOutputReadonly","endLine":60,"endColumn":28,"suggestions":[{"messageId":"suggestAddReadonlyModifier","fix":{"range":[1665,1665],"text":"readonly "},"desc":"Add `readonly` modifier"}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { isPlatformServer } from '@angular/common'\nimport type QuillType from 'quill'\n\nimport {\n  AfterViewInit,\n  Component,\n  DestroyRef,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Output,\n  PLATFORM_ID,\n  Renderer2,\n  SecurityContext,\n  SimpleChanges,\n  ViewEncapsulation,\n  inject,\n  input\n} from '@angular/core'\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop'\nimport { DomSanitizer } from '@angular/platform-browser'\nimport type { Subscription } from 'rxjs'\nimport { mergeMap } from 'rxjs/operators'\n\nimport { CustomModule, CustomOption, QuillBeforeRender, QuillModules } from 'ngx-quill/config'\n\nimport { getFormat, raf$ } from './helpers'\nimport { QuillService } from './quill.service'\n\n@Component({\n  encapsulation: ViewEncapsulation.None,\n  selector: 'quill-view',\n  styles: `\n.ql-container.ngx-quill-view {\n  border: 0;\n}\n`,\n  template: `\n  <div quill-view-element></div>\n`,\n})\nexport class QuillViewComponent implements AfterViewInit, OnChanges, OnDestroy {\n  readonly format = input<'object' | 'html' | 'text' | 'json' | undefined>(\n    undefined\n  )\n  readonly theme = input<string | undefined>(undefined)\n  readonly modules = input<QuillModules | undefined>(undefined)\n  readonly debug = input<'warn' | 'log' | 'error' | false>(false)\n  readonly formats = input<string[] | null | undefined>(undefined)\n  readonly sanitize = input<boolean | undefined>(undefined)\n  readonly beforeRender = input<QuillBeforeRender>()\n  readonly strict = input(true)\n  readonly content = input<any>()\n  readonly customModules = input<CustomModule[]>([])\n  readonly customOptions = input<CustomOption[]>([])\n\n  @Output() onEditorCreated = new EventEmitter<any>()\n\n  quillEditor!: QuillType\n  editorElem!: HTMLElement\n\n  private quillSubscription: Subscription | null = null\n\n  private destroyRef = inject(DestroyRef)\n\n  constructor(\n    public elementRef: ElementRef,\n    protected renderer: Renderer2,\n    protected zone: NgZone,\n    protected service: QuillService,\n    protected domSanitizer: DomSanitizer,\n    @Inject(PLATFORM_ID) protected platformId: any,\n  ) { }\n\n  valueSetter = (quillEditor: QuillType, value: any): any => {\n    const format = getFormat(this.format(), this.service.config.format)\n    let content = value\n    if (format === 'text') {\n      quillEditor.setText(content)\n    } else {\n      if (format === 'html') {\n        const sanitize = [true, false].includes(this.sanitize()) ? this.sanitize() : (this.service.config.sanitize || false)\n        if (sanitize) {\n          value = this.domSanitizer.sanitize(SecurityContext.HTML, value)\n        }\n        content = quillEditor.clipboard.convert({ html: value })\n      } else if (format === 'json') {\n        try {\n          content = JSON.parse(value)\n        } catch {\n          content = [{ insert: value }]\n        }\n      }\n      quillEditor.setContents(content)\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    if (!this.quillEditor) {\n      return\n    }\n    if (changes.content) {\n      this.valueSetter(this.quillEditor, changes.content.currentValue)\n    }\n  }\n\n  ngAfterViewInit() {\n    if (isPlatformServer(this.platformId)) {\n      return\n    }\n\n    this.quillSubscription = this.service.getQuill().pipe(\n      mergeMap((Quill) => this.service.beforeRender(Quill, this.customModules(), this.beforeRender()))\n    ).subscribe(Quill => {\n      const modules = Object.assign({}, this.modules() || this.service.config.modules)\n      modules.toolbar = false\n\n      this.customOptions().forEach((customOption) => {\n        const newCustomOption = Quill.import(customOption.import)\n        newCustomOption.whitelist = customOption.whitelist\n        Quill.register(newCustomOption, true)\n      })\n\n      let debug = this.debug()\n      if (!debug && debug !== false && this.service.config.debug) {\n        debug = this.service.config.debug\n      }\n\n      let formats = this.formats()\n      if (!formats && formats === undefined) {\n        formats = this.service.config.formats ? [...this.service.config.formats] : (this.service.config.formats === null ? null : undefined)\n      }\n      const theme = this.theme() || (this.service.config.theme ? this.service.config.theme : 'snow')\n\n      this.editorElem = this.elementRef.nativeElement.querySelector(\n        '[quill-view-element]'\n      ) as HTMLElement\n\n      this.zone.runOutsideAngular(() => {\n        this.quillEditor = new Quill(this.editorElem, {\n          debug,\n          formats,\n          modules,\n          readOnly: true,\n          strict: this.strict(),\n          theme\n        })\n      })\n\n      this.renderer.addClass(this.editorElem, 'ngx-quill-view')\n\n      if (this.content()) {\n        this.valueSetter(this.quillEditor, this.content())\n      }\n\n      // The `requestAnimationFrame` triggers change detection. There's no sense to invoke the `requestAnimationFrame` if anyone is\n      // listening to the `onEditorCreated` event inside the template, for instance `<quill-view (onEditorCreated)=\"...\">`.\n      if (!this.onEditorCreated.observed) {\n        return\n      }\n\n      // The `requestAnimationFrame` will trigger change detection and `onEditorCreated` will also call `markDirty()`\n      // internally, since Angular wraps template event listeners into `listener` instruction. We're using the `requestAnimationFrame`\n      // to prevent the frame drop and avoid `ExpressionChangedAfterItHasBeenCheckedError` error.\n      raf$().pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => {\n        this.onEditorCreated.emit(this.quillEditor)\n      })\n    })\n  }\n\n  ngOnDestroy(): void {\n    this.quillSubscription?.unsubscribe()\n    this.quillSubscription = null\n  }\n}\n","usedDeprecatedRules":[]}]
