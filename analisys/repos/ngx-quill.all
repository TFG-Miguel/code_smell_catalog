
Linting "ngx-quill"...
[{"filePath":"/home/migudel/Documents/GII/42C/TFG/develop/repos/ngx-quill/projects/ngx-quill/src/lib/quill-editor.component.spec.ts","messages":[{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":29,"column":1,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":53,"endColumn":3,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[40,657],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, fakeAsync, TestBed, tick } from '@angular/core/testing'\nimport { defer } from 'rxjs'\n\nimport { FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms'\n\nimport { QuillEditorComponent } from './quill-editor.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nwindow.setTimeout = ((cb) => {\n  cb()\n  return 0\n}) as any\n\n// const Quill = require('quill')\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/component-selector","severity":2,"message":"The selector should start with one of these prefixes: \"lib\" (https://angular.dev/style-guide#style-02-07)","line":31,"column":13,"nodeType":"Literal","messageId":"prefixFailure","endLine":31,"endColumn":25},{"ruleId":"@angular-eslint/component-max-inline-declarations","severity":2,"message":"`template` has too many lines (19). Maximum allowed is 3 (https://angular.dev/style-guide#style-05-04)","line":32,"column":13,"nodeType":"TemplateLiteral","messageId":"componentMaxInlineDeclarations","endLine":52,"endColumn":2},{"ruleId":"@angular-eslint/prefer-signals","severity":2,"message":"Use the `viewChild` function instead of the `ViewChild` decorator","line":55,"column":3,"nodeType":"Decorator","messageId":"preferQuerySignals","endLine":55,"endColumn":53},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":95,"column":1,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":135,"endColumn":3,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[40,2184],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, fakeAsync, TestBed, tick } from '@angular/core/testing'\nimport { defer } from 'rxjs'\n\nimport { FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms'\n\nimport { QuillEditorComponent } from './quill-editor.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nwindow.setTimeout = ((cb) => {\n  cb()\n  return 0\n}) as any\n\n// const Quill = require('quill')\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-test',\n  template: `\n<quill-editor\n  (onBlur)=\"blured = true\"\n  (onFocus)=\"focused = true\"\n  (onNativeBlur)=\"bluredNative = true\"\n  (onNativeFocus)=\"focusedNative = true\"\n  [(ngModel)]=\"title\"\n  [customOptions]=\"[{import: 'attributors/style/size', whitelist: ['14']}]\"\n  [styles]=\"style\"\n  [required]=\"required\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  [debounceTime]=\"debounceTime\"\n  [trimOnValidation]=\"trimOnValidation\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onEditorChanged)=\"handleEditorChange($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n  (onSelectionChanged)=\"handleSelection($event)\"\n></quill-editor>\n`\n})\nclass TestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editorComponent!: QuillEditorComponent\n  title: any = 'Hallo'\n  isReadOnly = false\n  required = false\n  minLength = 0\n  focused = false\n  blured = false\n  focusedNative = false\n  bluredNative = false\n  trimOnValidation = false\n  maxLength = 0\n  style: {\n    backgroundColor?: string\n    color?: string\n    height?: string\n  } | null = { height: '30px' }\n  editor: any\n  debounceTime: number\n\n  changed: any\n  changedEditor: any\n  selected: any\n\n  handleEditorCreated(event: any) {\n    this.editor = event\n  }\n\n  handleChange(event: any) {\n    this.changed = event\n  }\n\n  handleEditorChange(event: any) {\n    this.changedEditor = event\n  }\n\n  handleSelection(event: any) {\n    this.selected = event\n  }\n}\n\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/component-selector","severity":2,"message":"The selector should start with one of these prefixes: \"lib\" (https://angular.dev/style-guide#style-02-07)","line":97,"column":13,"nodeType":"Literal","messageId":"prefixFailure","endLine":97,"endColumn":33},{"ruleId":"@angular-eslint/component-max-inline-declarations","severity":2,"message":"`template` has too many lines (35). Maximum allowed is 3 (https://angular.dev/style-guide#style-05-04)","line":98,"column":13,"nodeType":"TemplateLiteral","messageId":"componentMaxInlineDeclarations","endLine":134,"endColumn":2},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":147,"column":1,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":153,"endColumn":3,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[40,3533],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, fakeAsync, TestBed, tick } from '@angular/core/testing'\nimport { defer } from 'rxjs'\n\nimport { FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms'\n\nimport { QuillEditorComponent } from './quill-editor.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nwindow.setTimeout = ((cb) => {\n  cb()\n  return 0\n}) as any\n\n// const Quill = require('quill')\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-test',\n  template: `\n<quill-editor\n  (onBlur)=\"blured = true\"\n  (onFocus)=\"focused = true\"\n  (onNativeBlur)=\"bluredNative = true\"\n  (onNativeFocus)=\"focusedNative = true\"\n  [(ngModel)]=\"title\"\n  [customOptions]=\"[{import: 'attributors/style/size', whitelist: ['14']}]\"\n  [styles]=\"style\"\n  [required]=\"required\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  [debounceTime]=\"debounceTime\"\n  [trimOnValidation]=\"trimOnValidation\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onEditorChanged)=\"handleEditorChange($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n  (onSelectionChanged)=\"handleSelection($event)\"\n></quill-editor>\n`\n})\nclass TestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editorComponent!: QuillEditorComponent\n  title: any = 'Hallo'\n  isReadOnly = false\n  required = false\n  minLength = 0\n  focused = false\n  blured = false\n  focusedNative = false\n  bluredNative = false\n  trimOnValidation = false\n  maxLength = 0\n  style: {\n    backgroundColor?: string\n    color?: string\n    height?: string\n  } | null = { height: '30px' }\n  editor: any\n  debounceTime: number\n\n  changed: any\n  changedEditor: any\n  selected: any\n\n  handleEditorCreated(event: any) {\n    this.editor = event\n  }\n\n  handleChange(event: any) {\n    this.changed = event\n  }\n\n  handleEditorChange(event: any) {\n    this.changedEditor = event\n  }\n\n  handleSelection(event: any) {\n    this.selected = event\n  }\n}\n\n@Component({\n  imports: [FormsModule, QuillModule],\n  selector: 'quill-toolbar-test',\n  template: `\n<quill-editor\n  [customToolbarPosition]=\"toolbarPosition\"\n  [(ngModel)]=\"title\" [required]=\"true\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n>\n  <div quill-editor-toolbar=\"true\">\n    <span class=\"ql-formats\">\n      <button class=\"ql-bold\" [title]=\"'Bold'\"></button>\n    </span>\n    <span class=\"ql-formats\">\n      <select class=\"ql-align\" [title]=\"'Aligment'\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n      <select class=\"ql-align\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n    </span>\n  </div>\n  <div above-quill-editor-toolbar=\"true\">\n    <span>above</span>\n  </div>\n  <div below-quill-editor-toolbar=\"true\">\n    <span>below</span>\n  </div>\n</quill-editor>\n`\n})\nclass TestToolbarComponent {\n  title = 'Hallo'\n  isReadOnly = false\n  minLength = 0\n  maxLength = 0\n  toolbarPosition = 'top'\n\n  handleEditorCreated() {return}\n  handleChange() {return}\n}\n\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/component-selector","severity":2,"message":"The selector should start with one of these prefixes: \"lib\" (https://angular.dev/style-guide#style-02-07)","line":149,"column":13,"nodeType":"Literal","messageId":"prefixFailure","endLine":149,"endColumn":34},{"ruleId":"@angular-eslint/prefer-signals","severity":2,"message":"Use the `viewChild` function instead of the `ViewChild` decorator","line":155,"column":3,"nodeType":"Decorator","messageId":"preferQuerySignals","endLine":155,"endColumn":53},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":160,"column":1,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":166,"endColumn":3,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[40,3919],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, fakeAsync, TestBed, tick } from '@angular/core/testing'\nimport { defer } from 'rxjs'\n\nimport { FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms'\n\nimport { QuillEditorComponent } from './quill-editor.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nwindow.setTimeout = ((cb) => {\n  cb()\n  return 0\n}) as any\n\n// const Quill = require('quill')\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-test',\n  template: `\n<quill-editor\n  (onBlur)=\"blured = true\"\n  (onFocus)=\"focused = true\"\n  (onNativeBlur)=\"bluredNative = true\"\n  (onNativeFocus)=\"focusedNative = true\"\n  [(ngModel)]=\"title\"\n  [customOptions]=\"[{import: 'attributors/style/size', whitelist: ['14']}]\"\n  [styles]=\"style\"\n  [required]=\"required\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  [debounceTime]=\"debounceTime\"\n  [trimOnValidation]=\"trimOnValidation\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onEditorChanged)=\"handleEditorChange($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n  (onSelectionChanged)=\"handleSelection($event)\"\n></quill-editor>\n`\n})\nclass TestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editorComponent!: QuillEditorComponent\n  title: any = 'Hallo'\n  isReadOnly = false\n  required = false\n  minLength = 0\n  focused = false\n  blured = false\n  focusedNative = false\n  bluredNative = false\n  trimOnValidation = false\n  maxLength = 0\n  style: {\n    backgroundColor?: string\n    color?: string\n    height?: string\n  } | null = { height: '30px' }\n  editor: any\n  debounceTime: number\n\n  changed: any\n  changedEditor: any\n  selected: any\n\n  handleEditorCreated(event: any) {\n    this.editor = event\n  }\n\n  handleChange(event: any) {\n    this.changed = event\n  }\n\n  handleEditorChange(event: any) {\n    this.changedEditor = event\n  }\n\n  handleSelection(event: any) {\n    this.selected = event\n  }\n}\n\n@Component({\n  imports: [FormsModule, QuillModule],\n  selector: 'quill-toolbar-test',\n  template: `\n<quill-editor\n  [customToolbarPosition]=\"toolbarPosition\"\n  [(ngModel)]=\"title\" [required]=\"true\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n>\n  <div quill-editor-toolbar=\"true\">\n    <span class=\"ql-formats\">\n      <button class=\"ql-bold\" [title]=\"'Bold'\"></button>\n    </span>\n    <span class=\"ql-formats\">\n      <select class=\"ql-align\" [title]=\"'Aligment'\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n      <select class=\"ql-align\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n    </span>\n  </div>\n  <div above-quill-editor-toolbar=\"true\">\n    <span>above</span>\n  </div>\n  <div below-quill-editor-toolbar=\"true\">\n    <span>below</span>\n  </div>\n</quill-editor>\n`\n})\nclass TestToolbarComponent {\n  title = 'Hallo'\n  isReadOnly = false\n  minLength = 0\n  maxLength = 0\n  toolbarPosition = 'top'\n\n  handleEditorCreated() {return}\n  handleChange() {return}\n}\n\n@Component({\n  imports: [QuillModule, ReactiveFormsModule],\n  selector: 'quill-reactive-test',\n  template: `\n    <quill-editor [formControl]='formControl' [minLength]='minLength'></quill-editor>\n`\n})\nclass ReactiveFormTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  formControl: FormControl = new FormControl('a')\n  minLength = 3\n}\n\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/component-selector","severity":2,"message":"The selector should start with one of these prefixes: \"lib\" (https://angular.dev/style-guide#style-02-07)","line":162,"column":13,"nodeType":"Literal","messageId":"prefixFailure","endLine":162,"endColumn":32},{"ruleId":"@angular-eslint/prefer-signals","severity":2,"message":"Use the `viewChild` function instead of the `ViewChild` decorator","line":168,"column":3,"nodeType":"Decorator","messageId":"preferQuerySignals","endLine":168,"endColumn":53},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":172,"column":1,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":178,"endColumn":3,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[40,4280],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, fakeAsync, TestBed, tick } from '@angular/core/testing'\nimport { defer } from 'rxjs'\n\nimport { FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms'\n\nimport { QuillEditorComponent } from './quill-editor.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nwindow.setTimeout = ((cb) => {\n  cb()\n  return 0\n}) as any\n\n// const Quill = require('quill')\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-test',\n  template: `\n<quill-editor\n  (onBlur)=\"blured = true\"\n  (onFocus)=\"focused = true\"\n  (onNativeBlur)=\"bluredNative = true\"\n  (onNativeFocus)=\"focusedNative = true\"\n  [(ngModel)]=\"title\"\n  [customOptions]=\"[{import: 'attributors/style/size', whitelist: ['14']}]\"\n  [styles]=\"style\"\n  [required]=\"required\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  [debounceTime]=\"debounceTime\"\n  [trimOnValidation]=\"trimOnValidation\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onEditorChanged)=\"handleEditorChange($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n  (onSelectionChanged)=\"handleSelection($event)\"\n></quill-editor>\n`\n})\nclass TestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editorComponent!: QuillEditorComponent\n  title: any = 'Hallo'\n  isReadOnly = false\n  required = false\n  minLength = 0\n  focused = false\n  blured = false\n  focusedNative = false\n  bluredNative = false\n  trimOnValidation = false\n  maxLength = 0\n  style: {\n    backgroundColor?: string\n    color?: string\n    height?: string\n  } | null = { height: '30px' }\n  editor: any\n  debounceTime: number\n\n  changed: any\n  changedEditor: any\n  selected: any\n\n  handleEditorCreated(event: any) {\n    this.editor = event\n  }\n\n  handleChange(event: any) {\n    this.changed = event\n  }\n\n  handleEditorChange(event: any) {\n    this.changedEditor = event\n  }\n\n  handleSelection(event: any) {\n    this.selected = event\n  }\n}\n\n@Component({\n  imports: [FormsModule, QuillModule],\n  selector: 'quill-toolbar-test',\n  template: `\n<quill-editor\n  [customToolbarPosition]=\"toolbarPosition\"\n  [(ngModel)]=\"title\" [required]=\"true\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n>\n  <div quill-editor-toolbar=\"true\">\n    <span class=\"ql-formats\">\n      <button class=\"ql-bold\" [title]=\"'Bold'\"></button>\n    </span>\n    <span class=\"ql-formats\">\n      <select class=\"ql-align\" [title]=\"'Aligment'\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n      <select class=\"ql-align\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n    </span>\n  </div>\n  <div above-quill-editor-toolbar=\"true\">\n    <span>above</span>\n  </div>\n  <div below-quill-editor-toolbar=\"true\">\n    <span>below</span>\n  </div>\n</quill-editor>\n`\n})\nclass TestToolbarComponent {\n  title = 'Hallo'\n  isReadOnly = false\n  minLength = 0\n  maxLength = 0\n  toolbarPosition = 'top'\n\n  handleEditorCreated() {return}\n  handleChange() {return}\n}\n\n@Component({\n  imports: [QuillModule, ReactiveFormsModule],\n  selector: 'quill-reactive-test',\n  template: `\n    <quill-editor [formControl]='formControl' [minLength]='minLength'></quill-editor>\n`\n})\nclass ReactiveFormTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  formControl: FormControl = new FormControl('a')\n  minLength = 3\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"[{path: 'modules/custom', implementation: impl}]\"></quill-editor>\n`\n})\nclass CustomModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  impl = CustomModule\n}\n\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/component-selector","severity":2,"message":"The selector should start with one of these prefixes: \"lib\" (https://angular.dev/style-guide#style-02-07)","line":174,"column":13,"nodeType":"Literal","messageId":"prefixFailure","endLine":174,"endColumn":38},{"ruleId":"@angular-eslint/prefer-signals","severity":2,"message":"Use the `viewChild` function instead of the `ViewChild` decorator","line":180,"column":3,"nodeType":"Decorator","messageId":"preferQuerySignals","endLine":180,"endColumn":53},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":189,"column":1,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":195,"endColumn":3,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[40,4733],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, fakeAsync, TestBed, tick } from '@angular/core/testing'\nimport { defer } from 'rxjs'\n\nimport { FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms'\n\nimport { QuillEditorComponent } from './quill-editor.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nwindow.setTimeout = ((cb) => {\n  cb()\n  return 0\n}) as any\n\n// const Quill = require('quill')\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-test',\n  template: `\n<quill-editor\n  (onBlur)=\"blured = true\"\n  (onFocus)=\"focused = true\"\n  (onNativeBlur)=\"bluredNative = true\"\n  (onNativeFocus)=\"focusedNative = true\"\n  [(ngModel)]=\"title\"\n  [customOptions]=\"[{import: 'attributors/style/size', whitelist: ['14']}]\"\n  [styles]=\"style\"\n  [required]=\"required\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  [debounceTime]=\"debounceTime\"\n  [trimOnValidation]=\"trimOnValidation\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onEditorChanged)=\"handleEditorChange($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n  (onSelectionChanged)=\"handleSelection($event)\"\n></quill-editor>\n`\n})\nclass TestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editorComponent!: QuillEditorComponent\n  title: any = 'Hallo'\n  isReadOnly = false\n  required = false\n  minLength = 0\n  focused = false\n  blured = false\n  focusedNative = false\n  bluredNative = false\n  trimOnValidation = false\n  maxLength = 0\n  style: {\n    backgroundColor?: string\n    color?: string\n    height?: string\n  } | null = { height: '30px' }\n  editor: any\n  debounceTime: number\n\n  changed: any\n  changedEditor: any\n  selected: any\n\n  handleEditorCreated(event: any) {\n    this.editor = event\n  }\n\n  handleChange(event: any) {\n    this.changed = event\n  }\n\n  handleEditorChange(event: any) {\n    this.changedEditor = event\n  }\n\n  handleSelection(event: any) {\n    this.selected = event\n  }\n}\n\n@Component({\n  imports: [FormsModule, QuillModule],\n  selector: 'quill-toolbar-test',\n  template: `\n<quill-editor\n  [customToolbarPosition]=\"toolbarPosition\"\n  [(ngModel)]=\"title\" [required]=\"true\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n>\n  <div quill-editor-toolbar=\"true\">\n    <span class=\"ql-formats\">\n      <button class=\"ql-bold\" [title]=\"'Bold'\"></button>\n    </span>\n    <span class=\"ql-formats\">\n      <select class=\"ql-align\" [title]=\"'Aligment'\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n      <select class=\"ql-align\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n    </span>\n  </div>\n  <div above-quill-editor-toolbar=\"true\">\n    <span>above</span>\n  </div>\n  <div below-quill-editor-toolbar=\"true\">\n    <span>below</span>\n  </div>\n</quill-editor>\n`\n})\nclass TestToolbarComponent {\n  title = 'Hallo'\n  isReadOnly = false\n  minLength = 0\n  maxLength = 0\n  toolbarPosition = 'top'\n\n  handleEditorCreated() {return}\n  handleChange() {return}\n}\n\n@Component({\n  imports: [QuillModule, ReactiveFormsModule],\n  selector: 'quill-reactive-test',\n  template: `\n    <quill-editor [formControl]='formControl' [minLength]='minLength'></quill-editor>\n`\n})\nclass ReactiveFormTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  formControl: FormControl = new FormControl('a')\n  minLength = 3\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"[{path: 'modules/custom', implementation: impl}]\"></quill-editor>\n`\n})\nclass CustomModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  impl = CustomModule\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-async-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"customModules\"></quill-editor>\n`\n})\nclass CustomAsynchronousModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  customModules = [\n    {\n      path: 'modules/custom',\n      implementation: defer(() => Promise.resolve(CustomModule))\n    }\n  ]\n}\n\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/component-selector","severity":2,"message":"The selector should start with one of these prefixes: \"lib\" (https://angular.dev/style-guide#style-02-07)","line":191,"column":13,"nodeType":"Literal","messageId":"prefixFailure","endLine":191,"endColumn":42},{"ruleId":"@angular-eslint/prefer-signals","severity":2,"message":"Use the `viewChild` function instead of the `ViewChild` decorator","line":197,"column":3,"nodeType":"Decorator","messageId":"preferQuerySignals","endLine":197,"endColumn":53},{"ruleId":"@angular-eslint/use-component-selector","severity":2,"message":"The selector of the component is mandatory","line":251,"column":5,"nodeType":"Decorator","messageId":"useComponentSelector","endLine":256,"endColumn":7},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":251,"column":5,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":256,"endColumn":7,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[40,6694],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, fakeAsync, TestBed, tick } from '@angular/core/testing'\nimport { defer } from 'rxjs'\n\nimport { FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms'\n\nimport { QuillEditorComponent } from './quill-editor.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nwindow.setTimeout = ((cb) => {\n  cb()\n  return 0\n}) as any\n\n// const Quill = require('quill')\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-test',\n  template: `\n<quill-editor\n  (onBlur)=\"blured = true\"\n  (onFocus)=\"focused = true\"\n  (onNativeBlur)=\"bluredNative = true\"\n  (onNativeFocus)=\"focusedNative = true\"\n  [(ngModel)]=\"title\"\n  [customOptions]=\"[{import: 'attributors/style/size', whitelist: ['14']}]\"\n  [styles]=\"style\"\n  [required]=\"required\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  [debounceTime]=\"debounceTime\"\n  [trimOnValidation]=\"trimOnValidation\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onEditorChanged)=\"handleEditorChange($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n  (onSelectionChanged)=\"handleSelection($event)\"\n></quill-editor>\n`\n})\nclass TestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editorComponent!: QuillEditorComponent\n  title: any = 'Hallo'\n  isReadOnly = false\n  required = false\n  minLength = 0\n  focused = false\n  blured = false\n  focusedNative = false\n  bluredNative = false\n  trimOnValidation = false\n  maxLength = 0\n  style: {\n    backgroundColor?: string\n    color?: string\n    height?: string\n  } | null = { height: '30px' }\n  editor: any\n  debounceTime: number\n\n  changed: any\n  changedEditor: any\n  selected: any\n\n  handleEditorCreated(event: any) {\n    this.editor = event\n  }\n\n  handleChange(event: any) {\n    this.changed = event\n  }\n\n  handleEditorChange(event: any) {\n    this.changedEditor = event\n  }\n\n  handleSelection(event: any) {\n    this.selected = event\n  }\n}\n\n@Component({\n  imports: [FormsModule, QuillModule],\n  selector: 'quill-toolbar-test',\n  template: `\n<quill-editor\n  [customToolbarPosition]=\"toolbarPosition\"\n  [(ngModel)]=\"title\" [required]=\"true\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n>\n  <div quill-editor-toolbar=\"true\">\n    <span class=\"ql-formats\">\n      <button class=\"ql-bold\" [title]=\"'Bold'\"></button>\n    </span>\n    <span class=\"ql-formats\">\n      <select class=\"ql-align\" [title]=\"'Aligment'\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n      <select class=\"ql-align\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n    </span>\n  </div>\n  <div above-quill-editor-toolbar=\"true\">\n    <span>above</span>\n  </div>\n  <div below-quill-editor-toolbar=\"true\">\n    <span>below</span>\n  </div>\n</quill-editor>\n`\n})\nclass TestToolbarComponent {\n  title = 'Hallo'\n  isReadOnly = false\n  minLength = 0\n  maxLength = 0\n  toolbarPosition = 'top'\n\n  handleEditorCreated() {return}\n  handleChange() {return}\n}\n\n@Component({\n  imports: [QuillModule, ReactiveFormsModule],\n  selector: 'quill-reactive-test',\n  template: `\n    <quill-editor [formControl]='formControl' [minLength]='minLength'></quill-editor>\n`\n})\nclass ReactiveFormTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  formControl: FormControl = new FormControl('a')\n  minLength = 3\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"[{path: 'modules/custom', implementation: impl}]\"></quill-editor>\n`\n})\nclass CustomModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  impl = CustomModule\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-async-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"customModules\"></quill-editor>\n`\n})\nclass CustomAsynchronousModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  customModules = [\n    {\n      path: 'modules/custom',\n      implementation: defer(() => Promise.resolve(CustomModule))\n    }\n  ]\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-link-placeholder-test',\n  template: `\n    <quill-editor [ngModel]=\"content\" [linkPlaceholder]=\"'https://test.de'\"></quill-editor>\n`\n})\nclass CustomLinkPlaceholderTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  content = ''\n}\n\ndescribe('Basic QuillEditorComponent', () => {\n  let fixture: ComponentFixture<QuillEditorComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n\n      ],\n      providers: QuillModule.forRoot().providers\n    })\n    fixture = TestBed.createComponent(QuillEditorComponent)\n  })\n\n  it('ngOnDestroy - removes listeners', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const spy = spyOn(fixture.componentInstance.quillEditor, 'off').and.callThrough()\n\n    fixture.componentInstance.ngOnDestroy()\n\n    expect(spy).toHaveBeenCalledTimes(3)\n    const quillEditor: any = fixture.componentInstance.quillEditor\n    expect(quillEditor.emitter._events['editor-change'].length).toBe(4)\n    expect(quillEditor.emitter._events['selection-change']).toBeInstanceOf(Object)\n    expect(quillEditor.emitter._events['text-change']).toBeFalsy()\n  })\n\n  it('should render toolbar', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('div.ql-toolbar.ql-snow').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n  })\n\n  it('should render text div', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('div.ql-container.ql-snow').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n  })\n})\n\ndescribe('Formats', () => {\n  describe('object', () => {\n    @Component({\n      changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/use-component-selector","severity":2,"message":"The selector of the component is mandatory","line":312,"column":5,"nodeType":"Decorator","messageId":"useComponentSelector","endLine":317,"endColumn":7},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":312,"column":5,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":317,"endColumn":7,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[40,8546],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, fakeAsync, TestBed, tick } from '@angular/core/testing'\nimport { defer } from 'rxjs'\n\nimport { FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms'\n\nimport { QuillEditorComponent } from './quill-editor.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nwindow.setTimeout = ((cb) => {\n  cb()\n  return 0\n}) as any\n\n// const Quill = require('quill')\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-test',\n  template: `\n<quill-editor\n  (onBlur)=\"blured = true\"\n  (onFocus)=\"focused = true\"\n  (onNativeBlur)=\"bluredNative = true\"\n  (onNativeFocus)=\"focusedNative = true\"\n  [(ngModel)]=\"title\"\n  [customOptions]=\"[{import: 'attributors/style/size', whitelist: ['14']}]\"\n  [styles]=\"style\"\n  [required]=\"required\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  [debounceTime]=\"debounceTime\"\n  [trimOnValidation]=\"trimOnValidation\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onEditorChanged)=\"handleEditorChange($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n  (onSelectionChanged)=\"handleSelection($event)\"\n></quill-editor>\n`\n})\nclass TestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editorComponent!: QuillEditorComponent\n  title: any = 'Hallo'\n  isReadOnly = false\n  required = false\n  minLength = 0\n  focused = false\n  blured = false\n  focusedNative = false\n  bluredNative = false\n  trimOnValidation = false\n  maxLength = 0\n  style: {\n    backgroundColor?: string\n    color?: string\n    height?: string\n  } | null = { height: '30px' }\n  editor: any\n  debounceTime: number\n\n  changed: any\n  changedEditor: any\n  selected: any\n\n  handleEditorCreated(event: any) {\n    this.editor = event\n  }\n\n  handleChange(event: any) {\n    this.changed = event\n  }\n\n  handleEditorChange(event: any) {\n    this.changedEditor = event\n  }\n\n  handleSelection(event: any) {\n    this.selected = event\n  }\n}\n\n@Component({\n  imports: [FormsModule, QuillModule],\n  selector: 'quill-toolbar-test',\n  template: `\n<quill-editor\n  [customToolbarPosition]=\"toolbarPosition\"\n  [(ngModel)]=\"title\" [required]=\"true\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n>\n  <div quill-editor-toolbar=\"true\">\n    <span class=\"ql-formats\">\n      <button class=\"ql-bold\" [title]=\"'Bold'\"></button>\n    </span>\n    <span class=\"ql-formats\">\n      <select class=\"ql-align\" [title]=\"'Aligment'\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n      <select class=\"ql-align\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n    </span>\n  </div>\n  <div above-quill-editor-toolbar=\"true\">\n    <span>above</span>\n  </div>\n  <div below-quill-editor-toolbar=\"true\">\n    <span>below</span>\n  </div>\n</quill-editor>\n`\n})\nclass TestToolbarComponent {\n  title = 'Hallo'\n  isReadOnly = false\n  minLength = 0\n  maxLength = 0\n  toolbarPosition = 'top'\n\n  handleEditorCreated() {return}\n  handleChange() {return}\n}\n\n@Component({\n  imports: [QuillModule, ReactiveFormsModule],\n  selector: 'quill-reactive-test',\n  template: `\n    <quill-editor [formControl]='formControl' [minLength]='minLength'></quill-editor>\n`\n})\nclass ReactiveFormTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  formControl: FormControl = new FormControl('a')\n  minLength = 3\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"[{path: 'modules/custom', implementation: impl}]\"></quill-editor>\n`\n})\nclass CustomModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  impl = CustomModule\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-async-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"customModules\"></quill-editor>\n`\n})\nclass CustomAsynchronousModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  customModules = [\n    {\n      path: 'modules/custom',\n      implementation: defer(() => Promise.resolve(CustomModule))\n    }\n  ]\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-link-placeholder-test',\n  template: `\n    <quill-editor [ngModel]=\"content\" [linkPlaceholder]=\"'https://test.de'\"></quill-editor>\n`\n})\nclass CustomLinkPlaceholderTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  content = ''\n}\n\ndescribe('Basic QuillEditorComponent', () => {\n  let fixture: ComponentFixture<QuillEditorComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n\n      ],\n      providers: QuillModule.forRoot().providers\n    })\n    fixture = TestBed.createComponent(QuillEditorComponent)\n  })\n\n  it('ngOnDestroy - removes listeners', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const spy = spyOn(fixture.componentInstance.quillEditor, 'off').and.callThrough()\n\n    fixture.componentInstance.ngOnDestroy()\n\n    expect(spy).toHaveBeenCalledTimes(3)\n    const quillEditor: any = fixture.componentInstance.quillEditor\n    expect(quillEditor.emitter._events['editor-change'].length).toBe(4)\n    expect(quillEditor.emitter._events['selection-change']).toBeInstanceOf(Object)\n    expect(quillEditor.emitter._events['text-change']).toBeFalsy()\n  })\n\n  it('should render toolbar', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('div.ql-toolbar.ql-snow').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n  })\n\n  it('should render text div', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('div.ql-container.ql-snow').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n  })\n})\n\ndescribe('Formats', () => {\n  describe('object', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"object\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class ObjectComponent {\n      title = [{\n        insert: 'Hello'\n      }]\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<ObjectComponent>\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(ObjectComponent) as ComponentFixture<ObjectComponent>\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n    it('should be set object', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hello\\n' }] }))\n    })\n\n    it('should update text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.title = [{ insert: '1234' }]\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: '1234\\n' }] }))\n    })\n\n    it('should update model if editor text changes', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      component.editor.setContents([{ insert: '123' }], 'user')\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.title)).toEqual(JSON.stringify({ ops: [{ insert: '123\\n' }] }))\n    })\n  })\n\n  describe('html', () => {\n    @Component({\n      changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/use-component-selector","severity":2,"message":"The selector of the component is mandatory","line":327,"column":5,"nodeType":"Decorator","messageId":"useComponentSelector","endLine":332,"endColumn":7},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":327,"column":5,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":332,"endColumn":7,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[40,8962],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, fakeAsync, TestBed, tick } from '@angular/core/testing'\nimport { defer } from 'rxjs'\n\nimport { FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms'\n\nimport { QuillEditorComponent } from './quill-editor.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nwindow.setTimeout = ((cb) => {\n  cb()\n  return 0\n}) as any\n\n// const Quill = require('quill')\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-test',\n  template: `\n<quill-editor\n  (onBlur)=\"blured = true\"\n  (onFocus)=\"focused = true\"\n  (onNativeBlur)=\"bluredNative = true\"\n  (onNativeFocus)=\"focusedNative = true\"\n  [(ngModel)]=\"title\"\n  [customOptions]=\"[{import: 'attributors/style/size', whitelist: ['14']}]\"\n  [styles]=\"style\"\n  [required]=\"required\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  [debounceTime]=\"debounceTime\"\n  [trimOnValidation]=\"trimOnValidation\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onEditorChanged)=\"handleEditorChange($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n  (onSelectionChanged)=\"handleSelection($event)\"\n></quill-editor>\n`\n})\nclass TestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editorComponent!: QuillEditorComponent\n  title: any = 'Hallo'\n  isReadOnly = false\n  required = false\n  minLength = 0\n  focused = false\n  blured = false\n  focusedNative = false\n  bluredNative = false\n  trimOnValidation = false\n  maxLength = 0\n  style: {\n    backgroundColor?: string\n    color?: string\n    height?: string\n  } | null = { height: '30px' }\n  editor: any\n  debounceTime: number\n\n  changed: any\n  changedEditor: any\n  selected: any\n\n  handleEditorCreated(event: any) {\n    this.editor = event\n  }\n\n  handleChange(event: any) {\n    this.changed = event\n  }\n\n  handleEditorChange(event: any) {\n    this.changedEditor = event\n  }\n\n  handleSelection(event: any) {\n    this.selected = event\n  }\n}\n\n@Component({\n  imports: [FormsModule, QuillModule],\n  selector: 'quill-toolbar-test',\n  template: `\n<quill-editor\n  [customToolbarPosition]=\"toolbarPosition\"\n  [(ngModel)]=\"title\" [required]=\"true\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n>\n  <div quill-editor-toolbar=\"true\">\n    <span class=\"ql-formats\">\n      <button class=\"ql-bold\" [title]=\"'Bold'\"></button>\n    </span>\n    <span class=\"ql-formats\">\n      <select class=\"ql-align\" [title]=\"'Aligment'\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n      <select class=\"ql-align\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n    </span>\n  </div>\n  <div above-quill-editor-toolbar=\"true\">\n    <span>above</span>\n  </div>\n  <div below-quill-editor-toolbar=\"true\">\n    <span>below</span>\n  </div>\n</quill-editor>\n`\n})\nclass TestToolbarComponent {\n  title = 'Hallo'\n  isReadOnly = false\n  minLength = 0\n  maxLength = 0\n  toolbarPosition = 'top'\n\n  handleEditorCreated() {return}\n  handleChange() {return}\n}\n\n@Component({\n  imports: [QuillModule, ReactiveFormsModule],\n  selector: 'quill-reactive-test',\n  template: `\n    <quill-editor [formControl]='formControl' [minLength]='minLength'></quill-editor>\n`\n})\nclass ReactiveFormTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  formControl: FormControl = new FormControl('a')\n  minLength = 3\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"[{path: 'modules/custom', implementation: impl}]\"></quill-editor>\n`\n})\nclass CustomModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  impl = CustomModule\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-async-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"customModules\"></quill-editor>\n`\n})\nclass CustomAsynchronousModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  customModules = [\n    {\n      path: 'modules/custom',\n      implementation: defer(() => Promise.resolve(CustomModule))\n    }\n  ]\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-link-placeholder-test',\n  template: `\n    <quill-editor [ngModel]=\"content\" [linkPlaceholder]=\"'https://test.de'\"></quill-editor>\n`\n})\nclass CustomLinkPlaceholderTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  content = ''\n}\n\ndescribe('Basic QuillEditorComponent', () => {\n  let fixture: ComponentFixture<QuillEditorComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n\n      ],\n      providers: QuillModule.forRoot().providers\n    })\n    fixture = TestBed.createComponent(QuillEditorComponent)\n  })\n\n  it('ngOnDestroy - removes listeners', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const spy = spyOn(fixture.componentInstance.quillEditor, 'off').and.callThrough()\n\n    fixture.componentInstance.ngOnDestroy()\n\n    expect(spy).toHaveBeenCalledTimes(3)\n    const quillEditor: any = fixture.componentInstance.quillEditor\n    expect(quillEditor.emitter._events['editor-change'].length).toBe(4)\n    expect(quillEditor.emitter._events['selection-change']).toBeInstanceOf(Object)\n    expect(quillEditor.emitter._events['text-change']).toBeFalsy()\n  })\n\n  it('should render toolbar', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('div.ql-toolbar.ql-snow').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n  })\n\n  it('should render text div', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('div.ql-container.ql-snow').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n  })\n})\n\ndescribe('Formats', () => {\n  describe('object', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"object\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class ObjectComponent {\n      title = [{\n        insert: 'Hello'\n      }]\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<ObjectComponent>\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(ObjectComponent) as ComponentFixture<ObjectComponent>\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n    it('should be set object', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hello\\n' }] }))\n    })\n\n    it('should update text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.title = [{ insert: '1234' }]\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: '1234\\n' }] }))\n    })\n\n    it('should update model if editor text changes', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      component.editor.setContents([{ insert: '123' }], 'user')\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.title)).toEqual(JSON.stringify({ ops: [{ insert: '123\\n' }] }))\n    })\n  })\n\n  describe('html', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"html\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class HTMLComponent {\n      title = '<p>Hallo<ol><li>ordered</li></ol><ul><li>unordered</li></ul></p>'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    @Component({\n      changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/use-component-selector","severity":2,"message":"The selector of the component is mandatory","line":396,"column":5,"nodeType":"Decorator","messageId":"useComponentSelector","endLine":401,"endColumn":7},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":396,"column":5,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":401,"endColumn":7,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[40,11362],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, fakeAsync, TestBed, tick } from '@angular/core/testing'\nimport { defer } from 'rxjs'\n\nimport { FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms'\n\nimport { QuillEditorComponent } from './quill-editor.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nwindow.setTimeout = ((cb) => {\n  cb()\n  return 0\n}) as any\n\n// const Quill = require('quill')\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-test',\n  template: `\n<quill-editor\n  (onBlur)=\"blured = true\"\n  (onFocus)=\"focused = true\"\n  (onNativeBlur)=\"bluredNative = true\"\n  (onNativeFocus)=\"focusedNative = true\"\n  [(ngModel)]=\"title\"\n  [customOptions]=\"[{import: 'attributors/style/size', whitelist: ['14']}]\"\n  [styles]=\"style\"\n  [required]=\"required\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  [debounceTime]=\"debounceTime\"\n  [trimOnValidation]=\"trimOnValidation\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onEditorChanged)=\"handleEditorChange($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n  (onSelectionChanged)=\"handleSelection($event)\"\n></quill-editor>\n`\n})\nclass TestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editorComponent!: QuillEditorComponent\n  title: any = 'Hallo'\n  isReadOnly = false\n  required = false\n  minLength = 0\n  focused = false\n  blured = false\n  focusedNative = false\n  bluredNative = false\n  trimOnValidation = false\n  maxLength = 0\n  style: {\n    backgroundColor?: string\n    color?: string\n    height?: string\n  } | null = { height: '30px' }\n  editor: any\n  debounceTime: number\n\n  changed: any\n  changedEditor: any\n  selected: any\n\n  handleEditorCreated(event: any) {\n    this.editor = event\n  }\n\n  handleChange(event: any) {\n    this.changed = event\n  }\n\n  handleEditorChange(event: any) {\n    this.changedEditor = event\n  }\n\n  handleSelection(event: any) {\n    this.selected = event\n  }\n}\n\n@Component({\n  imports: [FormsModule, QuillModule],\n  selector: 'quill-toolbar-test',\n  template: `\n<quill-editor\n  [customToolbarPosition]=\"toolbarPosition\"\n  [(ngModel)]=\"title\" [required]=\"true\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n>\n  <div quill-editor-toolbar=\"true\">\n    <span class=\"ql-formats\">\n      <button class=\"ql-bold\" [title]=\"'Bold'\"></button>\n    </span>\n    <span class=\"ql-formats\">\n      <select class=\"ql-align\" [title]=\"'Aligment'\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n      <select class=\"ql-align\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n    </span>\n  </div>\n  <div above-quill-editor-toolbar=\"true\">\n    <span>above</span>\n  </div>\n  <div below-quill-editor-toolbar=\"true\">\n    <span>below</span>\n  </div>\n</quill-editor>\n`\n})\nclass TestToolbarComponent {\n  title = 'Hallo'\n  isReadOnly = false\n  minLength = 0\n  maxLength = 0\n  toolbarPosition = 'top'\n\n  handleEditorCreated() {return}\n  handleChange() {return}\n}\n\n@Component({\n  imports: [QuillModule, ReactiveFormsModule],\n  selector: 'quill-reactive-test',\n  template: `\n    <quill-editor [formControl]='formControl' [minLength]='minLength'></quill-editor>\n`\n})\nclass ReactiveFormTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  formControl: FormControl = new FormControl('a')\n  minLength = 3\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"[{path: 'modules/custom', implementation: impl}]\"></quill-editor>\n`\n})\nclass CustomModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  impl = CustomModule\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-async-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"customModules\"></quill-editor>\n`\n})\nclass CustomAsynchronousModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  customModules = [\n    {\n      path: 'modules/custom',\n      implementation: defer(() => Promise.resolve(CustomModule))\n    }\n  ]\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-link-placeholder-test',\n  template: `\n    <quill-editor [ngModel]=\"content\" [linkPlaceholder]=\"'https://test.de'\"></quill-editor>\n`\n})\nclass CustomLinkPlaceholderTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  content = ''\n}\n\ndescribe('Basic QuillEditorComponent', () => {\n  let fixture: ComponentFixture<QuillEditorComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n\n      ],\n      providers: QuillModule.forRoot().providers\n    })\n    fixture = TestBed.createComponent(QuillEditorComponent)\n  })\n\n  it('ngOnDestroy - removes listeners', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const spy = spyOn(fixture.componentInstance.quillEditor, 'off').and.callThrough()\n\n    fixture.componentInstance.ngOnDestroy()\n\n    expect(spy).toHaveBeenCalledTimes(3)\n    const quillEditor: any = fixture.componentInstance.quillEditor\n    expect(quillEditor.emitter._events['editor-change'].length).toBe(4)\n    expect(quillEditor.emitter._events['selection-change']).toBeInstanceOf(Object)\n    expect(quillEditor.emitter._events['text-change']).toBeFalsy()\n  })\n\n  it('should render toolbar', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('div.ql-toolbar.ql-snow').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n  })\n\n  it('should render text div', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('div.ql-container.ql-snow').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n  })\n})\n\ndescribe('Formats', () => {\n  describe('object', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"object\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class ObjectComponent {\n      title = [{\n        insert: 'Hello'\n      }]\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<ObjectComponent>\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(ObjectComponent) as ComponentFixture<ObjectComponent>\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n    it('should be set object', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hello\\n' }] }))\n    })\n\n    it('should update text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.title = [{ insert: '1234' }]\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: '1234\\n' }] }))\n    })\n\n    it('should update model if editor text changes', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      component.editor.setContents([{ insert: '123' }], 'user')\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.title)).toEqual(JSON.stringify({ ops: [{ insert: '123\\n' }] }))\n    })\n  })\n\n  describe('html', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"html\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class HTMLComponent {\n      title = '<p>Hallo<ol><li>ordered</li></ol><ul><li>unordered</li></ul></p>'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" [sanitize]=\"true\" format=\"html\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class HTMLSanitizeComponent {\n      title = '<p>Hallo <img src=\"wroooong.jpg\" onerror=\"window.alert(\\'sanitize me\\')\"></p>'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<HTMLComponent>\n    let component: HTMLComponent\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule.forRoot()]\n      })\n\n      fixture = TestBed.createComponent(HTMLComponent) as ComponentFixture<HTMLComponent>\n      component = fixture.componentInstance\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n    it('should be set html', async () => {\n      expect(component.editor.getText().trim()).toEqual(`Hallo\nordered\nunordered`)\n    })\n\n    it('should update html', async () => {\n      component.title = '<p>test</p>'\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.editor.getText().trim()).toEqual('test')\n    })\n\n    it('should update model if editor html changes', async () => {\n      expect(component.title.trim()).toEqual('<p>Hallo<ol><li>ordered</li></ol><ul><li>unordered</li></ul></p>')\n      component.editor.setText('1234', 'user')\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.title.trim()).toEqual('<p>1234</p>')\n    })\n\n    it('should sanitize html', async () => {\n      const sanfixture = TestBed.createComponent(HTMLSanitizeComponent) as ComponentFixture<HTMLSanitizeComponent>\n      sanfixture.detectChanges()\n\n      await sanfixture.whenStable()\n      const incomponent = sanfixture.componentInstance\n\n      expect(JSON.stringify(incomponent.editor.getContents()))\n      .toEqual(JSON.stringify({ ops: [{ insert: 'Hallo ' }, { insert: { image: 'wroooong.jpg' } }, { insert: '\\n' }] }))\n\n      incomponent.title = '<p><img src=\"xxxx\" onerror=\"window.alert()\"></p>'\n      sanfixture.detectChanges()\n\n      await sanfixture.whenStable()\n      expect(JSON.stringify(incomponent.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: { image: 'xxxx' } }, { insert: '\\n' }] }))\n    })\n  })\n\n  describe('text', () => {\n    @Component({\n      changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":458,"column":5,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":464,"endColumn":7,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[40,13203],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, fakeAsync, TestBed, tick } from '@angular/core/testing'\nimport { defer } from 'rxjs'\n\nimport { FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms'\n\nimport { QuillEditorComponent } from './quill-editor.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nwindow.setTimeout = ((cb) => {\n  cb()\n  return 0\n}) as any\n\n// const Quill = require('quill')\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-test',\n  template: `\n<quill-editor\n  (onBlur)=\"blured = true\"\n  (onFocus)=\"focused = true\"\n  (onNativeBlur)=\"bluredNative = true\"\n  (onNativeFocus)=\"focusedNative = true\"\n  [(ngModel)]=\"title\"\n  [customOptions]=\"[{import: 'attributors/style/size', whitelist: ['14']}]\"\n  [styles]=\"style\"\n  [required]=\"required\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  [debounceTime]=\"debounceTime\"\n  [trimOnValidation]=\"trimOnValidation\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onEditorChanged)=\"handleEditorChange($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n  (onSelectionChanged)=\"handleSelection($event)\"\n></quill-editor>\n`\n})\nclass TestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editorComponent!: QuillEditorComponent\n  title: any = 'Hallo'\n  isReadOnly = false\n  required = false\n  minLength = 0\n  focused = false\n  blured = false\n  focusedNative = false\n  bluredNative = false\n  trimOnValidation = false\n  maxLength = 0\n  style: {\n    backgroundColor?: string\n    color?: string\n    height?: string\n  } | null = { height: '30px' }\n  editor: any\n  debounceTime: number\n\n  changed: any\n  changedEditor: any\n  selected: any\n\n  handleEditorCreated(event: any) {\n    this.editor = event\n  }\n\n  handleChange(event: any) {\n    this.changed = event\n  }\n\n  handleEditorChange(event: any) {\n    this.changedEditor = event\n  }\n\n  handleSelection(event: any) {\n    this.selected = event\n  }\n}\n\n@Component({\n  imports: [FormsModule, QuillModule],\n  selector: 'quill-toolbar-test',\n  template: `\n<quill-editor\n  [customToolbarPosition]=\"toolbarPosition\"\n  [(ngModel)]=\"title\" [required]=\"true\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n>\n  <div quill-editor-toolbar=\"true\">\n    <span class=\"ql-formats\">\n      <button class=\"ql-bold\" [title]=\"'Bold'\"></button>\n    </span>\n    <span class=\"ql-formats\">\n      <select class=\"ql-align\" [title]=\"'Aligment'\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n      <select class=\"ql-align\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n    </span>\n  </div>\n  <div above-quill-editor-toolbar=\"true\">\n    <span>above</span>\n  </div>\n  <div below-quill-editor-toolbar=\"true\">\n    <span>below</span>\n  </div>\n</quill-editor>\n`\n})\nclass TestToolbarComponent {\n  title = 'Hallo'\n  isReadOnly = false\n  minLength = 0\n  maxLength = 0\n  toolbarPosition = 'top'\n\n  handleEditorCreated() {return}\n  handleChange() {return}\n}\n\n@Component({\n  imports: [QuillModule, ReactiveFormsModule],\n  selector: 'quill-reactive-test',\n  template: `\n    <quill-editor [formControl]='formControl' [minLength]='minLength'></quill-editor>\n`\n})\nclass ReactiveFormTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  formControl: FormControl = new FormControl('a')\n  minLength = 3\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"[{path: 'modules/custom', implementation: impl}]\"></quill-editor>\n`\n})\nclass CustomModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  impl = CustomModule\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-async-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"customModules\"></quill-editor>\n`\n})\nclass CustomAsynchronousModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  customModules = [\n    {\n      path: 'modules/custom',\n      implementation: defer(() => Promise.resolve(CustomModule))\n    }\n  ]\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-link-placeholder-test',\n  template: `\n    <quill-editor [ngModel]=\"content\" [linkPlaceholder]=\"'https://test.de'\"></quill-editor>\n`\n})\nclass CustomLinkPlaceholderTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  content = ''\n}\n\ndescribe('Basic QuillEditorComponent', () => {\n  let fixture: ComponentFixture<QuillEditorComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n\n      ],\n      providers: QuillModule.forRoot().providers\n    })\n    fixture = TestBed.createComponent(QuillEditorComponent)\n  })\n\n  it('ngOnDestroy - removes listeners', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const spy = spyOn(fixture.componentInstance.quillEditor, 'off').and.callThrough()\n\n    fixture.componentInstance.ngOnDestroy()\n\n    expect(spy).toHaveBeenCalledTimes(3)\n    const quillEditor: any = fixture.componentInstance.quillEditor\n    expect(quillEditor.emitter._events['editor-change'].length).toBe(4)\n    expect(quillEditor.emitter._events['selection-change']).toBeInstanceOf(Object)\n    expect(quillEditor.emitter._events['text-change']).toBeFalsy()\n  })\n\n  it('should render toolbar', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('div.ql-toolbar.ql-snow').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n  })\n\n  it('should render text div', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('div.ql-container.ql-snow').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n  })\n})\n\ndescribe('Formats', () => {\n  describe('object', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"object\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class ObjectComponent {\n      title = [{\n        insert: 'Hello'\n      }]\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<ObjectComponent>\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(ObjectComponent) as ComponentFixture<ObjectComponent>\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n    it('should be set object', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hello\\n' }] }))\n    })\n\n    it('should update text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.title = [{ insert: '1234' }]\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: '1234\\n' }] }))\n    })\n\n    it('should update model if editor text changes', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      component.editor.setContents([{ insert: '123' }], 'user')\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.title)).toEqual(JSON.stringify({ ops: [{ insert: '123\\n' }] }))\n    })\n  })\n\n  describe('html', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"html\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class HTMLComponent {\n      title = '<p>Hallo<ol><li>ordered</li></ol><ul><li>unordered</li></ul></p>'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" [sanitize]=\"true\" format=\"html\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class HTMLSanitizeComponent {\n      title = '<p>Hallo <img src=\"wroooong.jpg\" onerror=\"window.alert(\\'sanitize me\\')\"></p>'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<HTMLComponent>\n    let component: HTMLComponent\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule.forRoot()]\n      })\n\n      fixture = TestBed.createComponent(HTMLComponent) as ComponentFixture<HTMLComponent>\n      component = fixture.componentInstance\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n    it('should be set html', async () => {\n      expect(component.editor.getText().trim()).toEqual(`Hallo\nordered\nunordered`)\n    })\n\n    it('should update html', async () => {\n      component.title = '<p>test</p>'\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.editor.getText().trim()).toEqual('test')\n    })\n\n    it('should update model if editor html changes', async () => {\n      expect(component.title.trim()).toEqual('<p>Hallo<ol><li>ordered</li></ol><ul><li>unordered</li></ul></p>')\n      component.editor.setText('1234', 'user')\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.title.trim()).toEqual('<p>1234</p>')\n    })\n\n    it('should sanitize html', async () => {\n      const sanfixture = TestBed.createComponent(HTMLSanitizeComponent) as ComponentFixture<HTMLSanitizeComponent>\n      sanfixture.detectChanges()\n\n      await sanfixture.whenStable()\n      const incomponent = sanfixture.componentInstance\n\n      expect(JSON.stringify(incomponent.editor.getContents()))\n      .toEqual(JSON.stringify({ ops: [{ insert: 'Hallo ' }, { insert: { image: 'wroooong.jpg' } }, { insert: '\\n' }] }))\n\n      incomponent.title = '<p><img src=\"xxxx\" onerror=\"window.alert()\"></p>'\n      sanfixture.detectChanges()\n\n      await sanfixture.whenStable()\n      expect(JSON.stringify(incomponent.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: { image: 'xxxx' } }, { insert: '\\n' }] }))\n    })\n  })\n\n  describe('text', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"text\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class TextComponent {\n      title = 'Hallo'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<TextComponent>\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(TextComponent) as ComponentFixture<TextComponent>\n      fixture.detectChanges()\n    })\n    it('should be set text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      expect(component.editor.getText().trim()).toEqual('Hallo')\n    })\n\n    it('should update text', async () => {\n      const component = fixture.componentInstance\n      component.title = 'test'\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(component.editor.getText().trim()).toEqual('test')\n    })\n\n    it('should update model if editor text changes', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.editor.setText('123', 'user')\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.title.trim()).toEqual('123')\n    })\n\n    it('should not update model if editor content changed by api', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.editor.setText('123')\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.title.trim()).toEqual('Hallo')\n    })\n  })\n\n  describe('json', () => {\n    @Component({\n      changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/component-selector","severity":2,"message":"The selector should start with one of these prefixes: \"lib\" (https://angular.dev/style-guide#style-02-07)","line":460,"column":17,"nodeType":"Literal","messageId":"prefixFailure","endLine":460,"endColumn":29},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":476,"column":5,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":482,"endColumn":7,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[40,13634],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, fakeAsync, TestBed, tick } from '@angular/core/testing'\nimport { defer } from 'rxjs'\n\nimport { FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms'\n\nimport { QuillEditorComponent } from './quill-editor.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nwindow.setTimeout = ((cb) => {\n  cb()\n  return 0\n}) as any\n\n// const Quill = require('quill')\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-test',\n  template: `\n<quill-editor\n  (onBlur)=\"blured = true\"\n  (onFocus)=\"focused = true\"\n  (onNativeBlur)=\"bluredNative = true\"\n  (onNativeFocus)=\"focusedNative = true\"\n  [(ngModel)]=\"title\"\n  [customOptions]=\"[{import: 'attributors/style/size', whitelist: ['14']}]\"\n  [styles]=\"style\"\n  [required]=\"required\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  [debounceTime]=\"debounceTime\"\n  [trimOnValidation]=\"trimOnValidation\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onEditorChanged)=\"handleEditorChange($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n  (onSelectionChanged)=\"handleSelection($event)\"\n></quill-editor>\n`\n})\nclass TestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editorComponent!: QuillEditorComponent\n  title: any = 'Hallo'\n  isReadOnly = false\n  required = false\n  minLength = 0\n  focused = false\n  blured = false\n  focusedNative = false\n  bluredNative = false\n  trimOnValidation = false\n  maxLength = 0\n  style: {\n    backgroundColor?: string\n    color?: string\n    height?: string\n  } | null = { height: '30px' }\n  editor: any\n  debounceTime: number\n\n  changed: any\n  changedEditor: any\n  selected: any\n\n  handleEditorCreated(event: any) {\n    this.editor = event\n  }\n\n  handleChange(event: any) {\n    this.changed = event\n  }\n\n  handleEditorChange(event: any) {\n    this.changedEditor = event\n  }\n\n  handleSelection(event: any) {\n    this.selected = event\n  }\n}\n\n@Component({\n  imports: [FormsModule, QuillModule],\n  selector: 'quill-toolbar-test',\n  template: `\n<quill-editor\n  [customToolbarPosition]=\"toolbarPosition\"\n  [(ngModel)]=\"title\" [required]=\"true\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n>\n  <div quill-editor-toolbar=\"true\">\n    <span class=\"ql-formats\">\n      <button class=\"ql-bold\" [title]=\"'Bold'\"></button>\n    </span>\n    <span class=\"ql-formats\">\n      <select class=\"ql-align\" [title]=\"'Aligment'\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n      <select class=\"ql-align\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n    </span>\n  </div>\n  <div above-quill-editor-toolbar=\"true\">\n    <span>above</span>\n  </div>\n  <div below-quill-editor-toolbar=\"true\">\n    <span>below</span>\n  </div>\n</quill-editor>\n`\n})\nclass TestToolbarComponent {\n  title = 'Hallo'\n  isReadOnly = false\n  minLength = 0\n  maxLength = 0\n  toolbarPosition = 'top'\n\n  handleEditorCreated() {return}\n  handleChange() {return}\n}\n\n@Component({\n  imports: [QuillModule, ReactiveFormsModule],\n  selector: 'quill-reactive-test',\n  template: `\n    <quill-editor [formControl]='formControl' [minLength]='minLength'></quill-editor>\n`\n})\nclass ReactiveFormTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  formControl: FormControl = new FormControl('a')\n  minLength = 3\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"[{path: 'modules/custom', implementation: impl}]\"></quill-editor>\n`\n})\nclass CustomModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  impl = CustomModule\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-async-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"customModules\"></quill-editor>\n`\n})\nclass CustomAsynchronousModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  customModules = [\n    {\n      path: 'modules/custom',\n      implementation: defer(() => Promise.resolve(CustomModule))\n    }\n  ]\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-link-placeholder-test',\n  template: `\n    <quill-editor [ngModel]=\"content\" [linkPlaceholder]=\"'https://test.de'\"></quill-editor>\n`\n})\nclass CustomLinkPlaceholderTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  content = ''\n}\n\ndescribe('Basic QuillEditorComponent', () => {\n  let fixture: ComponentFixture<QuillEditorComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n\n      ],\n      providers: QuillModule.forRoot().providers\n    })\n    fixture = TestBed.createComponent(QuillEditorComponent)\n  })\n\n  it('ngOnDestroy - removes listeners', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const spy = spyOn(fixture.componentInstance.quillEditor, 'off').and.callThrough()\n\n    fixture.componentInstance.ngOnDestroy()\n\n    expect(spy).toHaveBeenCalledTimes(3)\n    const quillEditor: any = fixture.componentInstance.quillEditor\n    expect(quillEditor.emitter._events['editor-change'].length).toBe(4)\n    expect(quillEditor.emitter._events['selection-change']).toBeInstanceOf(Object)\n    expect(quillEditor.emitter._events['text-change']).toBeFalsy()\n  })\n\n  it('should render toolbar', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('div.ql-toolbar.ql-snow').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n  })\n\n  it('should render text div', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('div.ql-container.ql-snow').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n  })\n})\n\ndescribe('Formats', () => {\n  describe('object', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"object\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class ObjectComponent {\n      title = [{\n        insert: 'Hello'\n      }]\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<ObjectComponent>\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(ObjectComponent) as ComponentFixture<ObjectComponent>\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n    it('should be set object', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hello\\n' }] }))\n    })\n\n    it('should update text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.title = [{ insert: '1234' }]\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: '1234\\n' }] }))\n    })\n\n    it('should update model if editor text changes', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      component.editor.setContents([{ insert: '123' }], 'user')\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.title)).toEqual(JSON.stringify({ ops: [{ insert: '123\\n' }] }))\n    })\n  })\n\n  describe('html', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"html\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class HTMLComponent {\n      title = '<p>Hallo<ol><li>ordered</li></ol><ul><li>unordered</li></ul></p>'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" [sanitize]=\"true\" format=\"html\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class HTMLSanitizeComponent {\n      title = '<p>Hallo <img src=\"wroooong.jpg\" onerror=\"window.alert(\\'sanitize me\\')\"></p>'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<HTMLComponent>\n    let component: HTMLComponent\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule.forRoot()]\n      })\n\n      fixture = TestBed.createComponent(HTMLComponent) as ComponentFixture<HTMLComponent>\n      component = fixture.componentInstance\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n    it('should be set html', async () => {\n      expect(component.editor.getText().trim()).toEqual(`Hallo\nordered\nunordered`)\n    })\n\n    it('should update html', async () => {\n      component.title = '<p>test</p>'\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.editor.getText().trim()).toEqual('test')\n    })\n\n    it('should update model if editor html changes', async () => {\n      expect(component.title.trim()).toEqual('<p>Hallo<ol><li>ordered</li></ol><ul><li>unordered</li></ul></p>')\n      component.editor.setText('1234', 'user')\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.title.trim()).toEqual('<p>1234</p>')\n    })\n\n    it('should sanitize html', async () => {\n      const sanfixture = TestBed.createComponent(HTMLSanitizeComponent) as ComponentFixture<HTMLSanitizeComponent>\n      sanfixture.detectChanges()\n\n      await sanfixture.whenStable()\n      const incomponent = sanfixture.componentInstance\n\n      expect(JSON.stringify(incomponent.editor.getContents()))\n      .toEqual(JSON.stringify({ ops: [{ insert: 'Hallo ' }, { insert: { image: 'wroooong.jpg' } }, { insert: '\\n' }] }))\n\n      incomponent.title = '<p><img src=\"xxxx\" onerror=\"window.alert()\"></p>'\n      sanfixture.detectChanges()\n\n      await sanfixture.whenStable()\n      expect(JSON.stringify(incomponent.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: { image: 'xxxx' } }, { insert: '\\n' }] }))\n    })\n  })\n\n  describe('text', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"text\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class TextComponent {\n      title = 'Hallo'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<TextComponent>\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(TextComponent) as ComponentFixture<TextComponent>\n      fixture.detectChanges()\n    })\n    it('should be set text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      expect(component.editor.getText().trim()).toEqual('Hallo')\n    })\n\n    it('should update text', async () => {\n      const component = fixture.componentInstance\n      component.title = 'test'\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(component.editor.getText().trim()).toEqual('test')\n    })\n\n    it('should update model if editor text changes', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.editor.setText('123', 'user')\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.title.trim()).toEqual('123')\n    })\n\n    it('should not update model if editor content changed by api', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.editor.setText('123')\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.title.trim()).toEqual('Hallo')\n    })\n  })\n\n  describe('json', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      selector: 'json-valid',\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"json\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class JSONComponent {\n      title = JSON.stringify([{\n        insert: 'Hallo'\n      }])\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    @Component({\n      changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/component-selector","severity":2,"message":"The selector should start with one of these prefixes: \"lib\" (https://angular.dev/style-guide#style-02-07)","line":478,"column":17,"nodeType":"Literal","messageId":"prefixFailure","endLine":478,"endColumn":37},{"ruleId":"@angular-eslint/use-component-selector","severity":2,"message":"The selector of the component is mandatory","line":554,"column":3,"nodeType":"Decorator","messageId":"useComponentSelector","endLine":564,"endColumn":5},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":554,"column":3,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":564,"endColumn":5,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[40,16062],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, fakeAsync, TestBed, tick } from '@angular/core/testing'\nimport { defer } from 'rxjs'\n\nimport { FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms'\n\nimport { QuillEditorComponent } from './quill-editor.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nwindow.setTimeout = ((cb) => {\n  cb()\n  return 0\n}) as any\n\n// const Quill = require('quill')\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-test',\n  template: `\n<quill-editor\n  (onBlur)=\"blured = true\"\n  (onFocus)=\"focused = true\"\n  (onNativeBlur)=\"bluredNative = true\"\n  (onNativeFocus)=\"focusedNative = true\"\n  [(ngModel)]=\"title\"\n  [customOptions]=\"[{import: 'attributors/style/size', whitelist: ['14']}]\"\n  [styles]=\"style\"\n  [required]=\"required\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  [debounceTime]=\"debounceTime\"\n  [trimOnValidation]=\"trimOnValidation\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onEditorChanged)=\"handleEditorChange($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n  (onSelectionChanged)=\"handleSelection($event)\"\n></quill-editor>\n`\n})\nclass TestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editorComponent!: QuillEditorComponent\n  title: any = 'Hallo'\n  isReadOnly = false\n  required = false\n  minLength = 0\n  focused = false\n  blured = false\n  focusedNative = false\n  bluredNative = false\n  trimOnValidation = false\n  maxLength = 0\n  style: {\n    backgroundColor?: string\n    color?: string\n    height?: string\n  } | null = { height: '30px' }\n  editor: any\n  debounceTime: number\n\n  changed: any\n  changedEditor: any\n  selected: any\n\n  handleEditorCreated(event: any) {\n    this.editor = event\n  }\n\n  handleChange(event: any) {\n    this.changed = event\n  }\n\n  handleEditorChange(event: any) {\n    this.changedEditor = event\n  }\n\n  handleSelection(event: any) {\n    this.selected = event\n  }\n}\n\n@Component({\n  imports: [FormsModule, QuillModule],\n  selector: 'quill-toolbar-test',\n  template: `\n<quill-editor\n  [customToolbarPosition]=\"toolbarPosition\"\n  [(ngModel)]=\"title\" [required]=\"true\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n>\n  <div quill-editor-toolbar=\"true\">\n    <span class=\"ql-formats\">\n      <button class=\"ql-bold\" [title]=\"'Bold'\"></button>\n    </span>\n    <span class=\"ql-formats\">\n      <select class=\"ql-align\" [title]=\"'Aligment'\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n      <select class=\"ql-align\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n    </span>\n  </div>\n  <div above-quill-editor-toolbar=\"true\">\n    <span>above</span>\n  </div>\n  <div below-quill-editor-toolbar=\"true\">\n    <span>below</span>\n  </div>\n</quill-editor>\n`\n})\nclass TestToolbarComponent {\n  title = 'Hallo'\n  isReadOnly = false\n  minLength = 0\n  maxLength = 0\n  toolbarPosition = 'top'\n\n  handleEditorCreated() {return}\n  handleChange() {return}\n}\n\n@Component({\n  imports: [QuillModule, ReactiveFormsModule],\n  selector: 'quill-reactive-test',\n  template: `\n    <quill-editor [formControl]='formControl' [minLength]='minLength'></quill-editor>\n`\n})\nclass ReactiveFormTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  formControl: FormControl = new FormControl('a')\n  minLength = 3\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"[{path: 'modules/custom', implementation: impl}]\"></quill-editor>\n`\n})\nclass CustomModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  impl = CustomModule\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-async-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"customModules\"></quill-editor>\n`\n})\nclass CustomAsynchronousModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  customModules = [\n    {\n      path: 'modules/custom',\n      implementation: defer(() => Promise.resolve(CustomModule))\n    }\n  ]\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-link-placeholder-test',\n  template: `\n    <quill-editor [ngModel]=\"content\" [linkPlaceholder]=\"'https://test.de'\"></quill-editor>\n`\n})\nclass CustomLinkPlaceholderTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  content = ''\n}\n\ndescribe('Basic QuillEditorComponent', () => {\n  let fixture: ComponentFixture<QuillEditorComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n\n      ],\n      providers: QuillModule.forRoot().providers\n    })\n    fixture = TestBed.createComponent(QuillEditorComponent)\n  })\n\n  it('ngOnDestroy - removes listeners', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const spy = spyOn(fixture.componentInstance.quillEditor, 'off').and.callThrough()\n\n    fixture.componentInstance.ngOnDestroy()\n\n    expect(spy).toHaveBeenCalledTimes(3)\n    const quillEditor: any = fixture.componentInstance.quillEditor\n    expect(quillEditor.emitter._events['editor-change'].length).toBe(4)\n    expect(quillEditor.emitter._events['selection-change']).toBeInstanceOf(Object)\n    expect(quillEditor.emitter._events['text-change']).toBeFalsy()\n  })\n\n  it('should render toolbar', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('div.ql-toolbar.ql-snow').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n  })\n\n  it('should render text div', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('div.ql-container.ql-snow').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n  })\n})\n\ndescribe('Formats', () => {\n  describe('object', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"object\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class ObjectComponent {\n      title = [{\n        insert: 'Hello'\n      }]\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<ObjectComponent>\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(ObjectComponent) as ComponentFixture<ObjectComponent>\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n    it('should be set object', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hello\\n' }] }))\n    })\n\n    it('should update text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.title = [{ insert: '1234' }]\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: '1234\\n' }] }))\n    })\n\n    it('should update model if editor text changes', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      component.editor.setContents([{ insert: '123' }], 'user')\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.title)).toEqual(JSON.stringify({ ops: [{ insert: '123\\n' }] }))\n    })\n  })\n\n  describe('html', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"html\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class HTMLComponent {\n      title = '<p>Hallo<ol><li>ordered</li></ol><ul><li>unordered</li></ul></p>'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" [sanitize]=\"true\" format=\"html\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class HTMLSanitizeComponent {\n      title = '<p>Hallo <img src=\"wroooong.jpg\" onerror=\"window.alert(\\'sanitize me\\')\"></p>'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<HTMLComponent>\n    let component: HTMLComponent\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule.forRoot()]\n      })\n\n      fixture = TestBed.createComponent(HTMLComponent) as ComponentFixture<HTMLComponent>\n      component = fixture.componentInstance\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n    it('should be set html', async () => {\n      expect(component.editor.getText().trim()).toEqual(`Hallo\nordered\nunordered`)\n    })\n\n    it('should update html', async () => {\n      component.title = '<p>test</p>'\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.editor.getText().trim()).toEqual('test')\n    })\n\n    it('should update model if editor html changes', async () => {\n      expect(component.title.trim()).toEqual('<p>Hallo<ol><li>ordered</li></ol><ul><li>unordered</li></ul></p>')\n      component.editor.setText('1234', 'user')\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.title.trim()).toEqual('<p>1234</p>')\n    })\n\n    it('should sanitize html', async () => {\n      const sanfixture = TestBed.createComponent(HTMLSanitizeComponent) as ComponentFixture<HTMLSanitizeComponent>\n      sanfixture.detectChanges()\n\n      await sanfixture.whenStable()\n      const incomponent = sanfixture.componentInstance\n\n      expect(JSON.stringify(incomponent.editor.getContents()))\n      .toEqual(JSON.stringify({ ops: [{ insert: 'Hallo ' }, { insert: { image: 'wroooong.jpg' } }, { insert: '\\n' }] }))\n\n      incomponent.title = '<p><img src=\"xxxx\" onerror=\"window.alert()\"></p>'\n      sanfixture.detectChanges()\n\n      await sanfixture.whenStable()\n      expect(JSON.stringify(incomponent.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: { image: 'xxxx' } }, { insert: '\\n' }] }))\n    })\n  })\n\n  describe('text', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"text\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class TextComponent {\n      title = 'Hallo'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<TextComponent>\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(TextComponent) as ComponentFixture<TextComponent>\n      fixture.detectChanges()\n    })\n    it('should be set text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      expect(component.editor.getText().trim()).toEqual('Hallo')\n    })\n\n    it('should update text', async () => {\n      const component = fixture.componentInstance\n      component.title = 'test'\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(component.editor.getText().trim()).toEqual('test')\n    })\n\n    it('should update model if editor text changes', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.editor.setText('123', 'user')\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.title.trim()).toEqual('123')\n    })\n\n    it('should not update model if editor content changed by api', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.editor.setText('123')\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.title.trim()).toEqual('Hallo')\n    })\n  })\n\n  describe('json', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      selector: 'json-valid',\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"json\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class JSONComponent {\n      title = JSON.stringify([{\n        insert: 'Hallo'\n      }])\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    @Component({\n      imports: [QuillModule, FormsModule],\n      selector: 'quill-json-invalid',\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"json\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class JSONInvalidComponent {\n      title = JSON.stringify([{\n        insert: 'Hallo'\n      }]) + '{'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<JSONComponent>\n    let component: JSONComponent\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule.forRoot()]\n      })\n\n      fixture = TestBed.createComponent(JSONComponent) as ComponentFixture<JSONComponent>\n      component = fixture.componentInstance\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n\n    it('should set json string', async () => {\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hallo\\n' }] }))\n    })\n\n    it('should update json string', async () => {\n      component.title = JSON.stringify([{\n        insert: 'Hallo 123'\n      }])\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hallo 123\\n' }] }))\n    })\n\n    it('should update model if editor changes', async () => {\n      component.editor.setContents([{\n        insert: 'Hallo 123'\n      }], 'user')\n      fixture.detectChanges()\n      await fixture.whenStable()\n\n      expect(component.title).toEqual(JSON.stringify({ ops: [{ insert: 'Hallo 123\\n' }] }))\n    })\n\n    it('should set as text if invalid JSON', async () => {\n      const infixture = TestBed.createComponent(JSONInvalidComponent) as ComponentFixture<JSONInvalidComponent>\n      infixture.detectChanges()\n      await infixture.whenStable()\n      const incomponent = infixture.componentInstance\n      expect(incomponent.editor.getText().trim()).toEqual(JSON.stringify([{\n        insert: 'Hallo'\n      }]) + '{')\n\n      incomponent.title = JSON.stringify([{\n        insert: 'Hallo 1234'\n      }]) + '{'\n      infixture.detectChanges()\n      await infixture.whenStable()\n      expect(incomponent.editor.getText().trim()).toEqual(JSON.stringify([{\n        insert: 'Hallo 1234'\n      }]) + '{')\n    })\n  })\n})\n\ndescribe('Dynamic styles', () => {\n  @Component({\n    changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/component-max-inline-declarations","severity":2,"message":"`template` has too many lines (6). Maximum allowed is 3 (https://angular.dev/style-guide#style-05-04)","line":556,"column":15,"nodeType":"TemplateLiteral","messageId":"componentMaxInlineDeclarations","endLine":563,"endColumn":4},{"ruleId":"@angular-eslint/use-component-selector","severity":2,"message":"The selector of the component is mandatory","line":608,"column":3,"nodeType":"Decorator","messageId":"useComponentSelector","endLine":618,"endColumn":5},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":608,"column":3,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":618,"endColumn":5,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[40,17390],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, fakeAsync, TestBed, tick } from '@angular/core/testing'\nimport { defer } from 'rxjs'\n\nimport { FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms'\n\nimport { QuillEditorComponent } from './quill-editor.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nwindow.setTimeout = ((cb) => {\n  cb()\n  return 0\n}) as any\n\n// const Quill = require('quill')\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-test',\n  template: `\n<quill-editor\n  (onBlur)=\"blured = true\"\n  (onFocus)=\"focused = true\"\n  (onNativeBlur)=\"bluredNative = true\"\n  (onNativeFocus)=\"focusedNative = true\"\n  [(ngModel)]=\"title\"\n  [customOptions]=\"[{import: 'attributors/style/size', whitelist: ['14']}]\"\n  [styles]=\"style\"\n  [required]=\"required\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  [debounceTime]=\"debounceTime\"\n  [trimOnValidation]=\"trimOnValidation\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onEditorChanged)=\"handleEditorChange($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n  (onSelectionChanged)=\"handleSelection($event)\"\n></quill-editor>\n`\n})\nclass TestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editorComponent!: QuillEditorComponent\n  title: any = 'Hallo'\n  isReadOnly = false\n  required = false\n  minLength = 0\n  focused = false\n  blured = false\n  focusedNative = false\n  bluredNative = false\n  trimOnValidation = false\n  maxLength = 0\n  style: {\n    backgroundColor?: string\n    color?: string\n    height?: string\n  } | null = { height: '30px' }\n  editor: any\n  debounceTime: number\n\n  changed: any\n  changedEditor: any\n  selected: any\n\n  handleEditorCreated(event: any) {\n    this.editor = event\n  }\n\n  handleChange(event: any) {\n    this.changed = event\n  }\n\n  handleEditorChange(event: any) {\n    this.changedEditor = event\n  }\n\n  handleSelection(event: any) {\n    this.selected = event\n  }\n}\n\n@Component({\n  imports: [FormsModule, QuillModule],\n  selector: 'quill-toolbar-test',\n  template: `\n<quill-editor\n  [customToolbarPosition]=\"toolbarPosition\"\n  [(ngModel)]=\"title\" [required]=\"true\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n>\n  <div quill-editor-toolbar=\"true\">\n    <span class=\"ql-formats\">\n      <button class=\"ql-bold\" [title]=\"'Bold'\"></button>\n    </span>\n    <span class=\"ql-formats\">\n      <select class=\"ql-align\" [title]=\"'Aligment'\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n      <select class=\"ql-align\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n    </span>\n  </div>\n  <div above-quill-editor-toolbar=\"true\">\n    <span>above</span>\n  </div>\n  <div below-quill-editor-toolbar=\"true\">\n    <span>below</span>\n  </div>\n</quill-editor>\n`\n})\nclass TestToolbarComponent {\n  title = 'Hallo'\n  isReadOnly = false\n  minLength = 0\n  maxLength = 0\n  toolbarPosition = 'top'\n\n  handleEditorCreated() {return}\n  handleChange() {return}\n}\n\n@Component({\n  imports: [QuillModule, ReactiveFormsModule],\n  selector: 'quill-reactive-test',\n  template: `\n    <quill-editor [formControl]='formControl' [minLength]='minLength'></quill-editor>\n`\n})\nclass ReactiveFormTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  formControl: FormControl = new FormControl('a')\n  minLength = 3\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"[{path: 'modules/custom', implementation: impl}]\"></quill-editor>\n`\n})\nclass CustomModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  impl = CustomModule\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-async-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"customModules\"></quill-editor>\n`\n})\nclass CustomAsynchronousModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  customModules = [\n    {\n      path: 'modules/custom',\n      implementation: defer(() => Promise.resolve(CustomModule))\n    }\n  ]\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-link-placeholder-test',\n  template: `\n    <quill-editor [ngModel]=\"content\" [linkPlaceholder]=\"'https://test.de'\"></quill-editor>\n`\n})\nclass CustomLinkPlaceholderTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  content = ''\n}\n\ndescribe('Basic QuillEditorComponent', () => {\n  let fixture: ComponentFixture<QuillEditorComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n\n      ],\n      providers: QuillModule.forRoot().providers\n    })\n    fixture = TestBed.createComponent(QuillEditorComponent)\n  })\n\n  it('ngOnDestroy - removes listeners', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const spy = spyOn(fixture.componentInstance.quillEditor, 'off').and.callThrough()\n\n    fixture.componentInstance.ngOnDestroy()\n\n    expect(spy).toHaveBeenCalledTimes(3)\n    const quillEditor: any = fixture.componentInstance.quillEditor\n    expect(quillEditor.emitter._events['editor-change'].length).toBe(4)\n    expect(quillEditor.emitter._events['selection-change']).toBeInstanceOf(Object)\n    expect(quillEditor.emitter._events['text-change']).toBeFalsy()\n  })\n\n  it('should render toolbar', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('div.ql-toolbar.ql-snow').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n  })\n\n  it('should render text div', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('div.ql-container.ql-snow').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n  })\n})\n\ndescribe('Formats', () => {\n  describe('object', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"object\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class ObjectComponent {\n      title = [{\n        insert: 'Hello'\n      }]\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<ObjectComponent>\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(ObjectComponent) as ComponentFixture<ObjectComponent>\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n    it('should be set object', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hello\\n' }] }))\n    })\n\n    it('should update text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.title = [{ insert: '1234' }]\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: '1234\\n' }] }))\n    })\n\n    it('should update model if editor text changes', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      component.editor.setContents([{ insert: '123' }], 'user')\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.title)).toEqual(JSON.stringify({ ops: [{ insert: '123\\n' }] }))\n    })\n  })\n\n  describe('html', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"html\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class HTMLComponent {\n      title = '<p>Hallo<ol><li>ordered</li></ol><ul><li>unordered</li></ul></p>'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" [sanitize]=\"true\" format=\"html\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class HTMLSanitizeComponent {\n      title = '<p>Hallo <img src=\"wroooong.jpg\" onerror=\"window.alert(\\'sanitize me\\')\"></p>'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<HTMLComponent>\n    let component: HTMLComponent\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule.forRoot()]\n      })\n\n      fixture = TestBed.createComponent(HTMLComponent) as ComponentFixture<HTMLComponent>\n      component = fixture.componentInstance\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n    it('should be set html', async () => {\n      expect(component.editor.getText().trim()).toEqual(`Hallo\nordered\nunordered`)\n    })\n\n    it('should update html', async () => {\n      component.title = '<p>test</p>'\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.editor.getText().trim()).toEqual('test')\n    })\n\n    it('should update model if editor html changes', async () => {\n      expect(component.title.trim()).toEqual('<p>Hallo<ol><li>ordered</li></ol><ul><li>unordered</li></ul></p>')\n      component.editor.setText('1234', 'user')\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.title.trim()).toEqual('<p>1234</p>')\n    })\n\n    it('should sanitize html', async () => {\n      const sanfixture = TestBed.createComponent(HTMLSanitizeComponent) as ComponentFixture<HTMLSanitizeComponent>\n      sanfixture.detectChanges()\n\n      await sanfixture.whenStable()\n      const incomponent = sanfixture.componentInstance\n\n      expect(JSON.stringify(incomponent.editor.getContents()))\n      .toEqual(JSON.stringify({ ops: [{ insert: 'Hallo ' }, { insert: { image: 'wroooong.jpg' } }, { insert: '\\n' }] }))\n\n      incomponent.title = '<p><img src=\"xxxx\" onerror=\"window.alert()\"></p>'\n      sanfixture.detectChanges()\n\n      await sanfixture.whenStable()\n      expect(JSON.stringify(incomponent.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: { image: 'xxxx' } }, { insert: '\\n' }] }))\n    })\n  })\n\n  describe('text', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"text\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class TextComponent {\n      title = 'Hallo'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<TextComponent>\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(TextComponent) as ComponentFixture<TextComponent>\n      fixture.detectChanges()\n    })\n    it('should be set text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      expect(component.editor.getText().trim()).toEqual('Hallo')\n    })\n\n    it('should update text', async () => {\n      const component = fixture.componentInstance\n      component.title = 'test'\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(component.editor.getText().trim()).toEqual('test')\n    })\n\n    it('should update model if editor text changes', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.editor.setText('123', 'user')\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.title.trim()).toEqual('123')\n    })\n\n    it('should not update model if editor content changed by api', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.editor.setText('123')\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.title.trim()).toEqual('Hallo')\n    })\n  })\n\n  describe('json', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      selector: 'json-valid',\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"json\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class JSONComponent {\n      title = JSON.stringify([{\n        insert: 'Hallo'\n      }])\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    @Component({\n      imports: [QuillModule, FormsModule],\n      selector: 'quill-json-invalid',\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"json\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class JSONInvalidComponent {\n      title = JSON.stringify([{\n        insert: 'Hallo'\n      }]) + '{'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<JSONComponent>\n    let component: JSONComponent\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule.forRoot()]\n      })\n\n      fixture = TestBed.createComponent(JSONComponent) as ComponentFixture<JSONComponent>\n      component = fixture.componentInstance\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n\n    it('should set json string', async () => {\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hallo\\n' }] }))\n    })\n\n    it('should update json string', async () => {\n      component.title = JSON.stringify([{\n        insert: 'Hallo 123'\n      }])\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hallo 123\\n' }] }))\n    })\n\n    it('should update model if editor changes', async () => {\n      component.editor.setContents([{\n        insert: 'Hallo 123'\n      }], 'user')\n      fixture.detectChanges()\n      await fixture.whenStable()\n\n      expect(component.title).toEqual(JSON.stringify({ ops: [{ insert: 'Hallo 123\\n' }] }))\n    })\n\n    it('should set as text if invalid JSON', async () => {\n      const infixture = TestBed.createComponent(JSONInvalidComponent) as ComponentFixture<JSONInvalidComponent>\n      infixture.detectChanges()\n      await infixture.whenStable()\n      const incomponent = infixture.componentInstance\n      expect(incomponent.editor.getText().trim()).toEqual(JSON.stringify([{\n        insert: 'Hallo'\n      }]) + '{')\n\n      incomponent.title = JSON.stringify([{\n        insert: 'Hallo 1234'\n      }]) + '{'\n      infixture.detectChanges()\n      await infixture.whenStable()\n      expect(incomponent.editor.getText().trim()).toEqual(JSON.stringify([{\n        insert: 'Hallo 1234'\n      }]) + '{')\n    })\n  })\n})\n\ndescribe('Dynamic styles', () => {\n  @Component({\n    imports: [QuillModule, FormsModule],\n    template: `\n  <quill-editor\n    [bounds]=\"'self'\"\n    [(ngModel)]=\"title\"\n    format=\"text\"\n    [styles]=\"style\"\n    (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n  `\n  })\n  class StylingComponent {\n    title = 'Hallo'\n    style = {\n      backgroundColor: 'red'\n    }\n    editor: any\n\n    handleEditorCreated(event: any) {\n      this.editor = event\n    }\n  }\n\n  let fixture: ComponentFixture<StylingComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [FormsModule, QuillModule],\n      providers: QuillModule.forRoot().providers\n    })\n\n    fixture = TestBed.createComponent(StylingComponent) as ComponentFixture<StylingComponent>\n    fixture.detectChanges()\n  })\n\n  it('set inital styles', async () => {\n    const component = fixture.componentInstance\n    await fixture.whenStable()\n    expect(component.editor.container.style.backgroundColor).toEqual('red')\n  })\n\n  it('set style', async () => {\n    const component = fixture.componentInstance\n    await fixture.whenStable()\n    component.style = {\n      backgroundColor: 'gray'\n    }\n    fixture.detectChanges()\n    await fixture.whenStable()\n    expect(component.editor.container.style.backgroundColor).toEqual('gray')\n  })\n})\n\ndescribe('Dynamic classes', () => {\n  @Component({\n    changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/component-max-inline-declarations","severity":2,"message":"`template` has too many lines (6). Maximum allowed is 3 (https://angular.dev/style-guide#style-05-04)","line":610,"column":15,"nodeType":"TemplateLiteral","messageId":"componentMaxInlineDeclarations","endLine":617,"endColumn":4},{"ruleId":"@angular-eslint/use-component-selector","severity":2,"message":"The selector of the component is mandatory","line":1423,"column":3,"nodeType":"Decorator","messageId":"useComponentSelector","endLine":1428,"endColumn":5},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":1423,"column":3,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":1428,"endColumn":5,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[40,46108],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, fakeAsync, TestBed, tick } from '@angular/core/testing'\nimport { defer } from 'rxjs'\n\nimport { FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms'\n\nimport { QuillEditorComponent } from './quill-editor.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nwindow.setTimeout = ((cb) => {\n  cb()\n  return 0\n}) as any\n\n// const Quill = require('quill')\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-test',\n  template: `\n<quill-editor\n  (onBlur)=\"blured = true\"\n  (onFocus)=\"focused = true\"\n  (onNativeBlur)=\"bluredNative = true\"\n  (onNativeFocus)=\"focusedNative = true\"\n  [(ngModel)]=\"title\"\n  [customOptions]=\"[{import: 'attributors/style/size', whitelist: ['14']}]\"\n  [styles]=\"style\"\n  [required]=\"required\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  [debounceTime]=\"debounceTime\"\n  [trimOnValidation]=\"trimOnValidation\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onEditorChanged)=\"handleEditorChange($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n  (onSelectionChanged)=\"handleSelection($event)\"\n></quill-editor>\n`\n})\nclass TestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editorComponent!: QuillEditorComponent\n  title: any = 'Hallo'\n  isReadOnly = false\n  required = false\n  minLength = 0\n  focused = false\n  blured = false\n  focusedNative = false\n  bluredNative = false\n  trimOnValidation = false\n  maxLength = 0\n  style: {\n    backgroundColor?: string\n    color?: string\n    height?: string\n  } | null = { height: '30px' }\n  editor: any\n  debounceTime: number\n\n  changed: any\n  changedEditor: any\n  selected: any\n\n  handleEditorCreated(event: any) {\n    this.editor = event\n  }\n\n  handleChange(event: any) {\n    this.changed = event\n  }\n\n  handleEditorChange(event: any) {\n    this.changedEditor = event\n  }\n\n  handleSelection(event: any) {\n    this.selected = event\n  }\n}\n\n@Component({\n  imports: [FormsModule, QuillModule],\n  selector: 'quill-toolbar-test',\n  template: `\n<quill-editor\n  [customToolbarPosition]=\"toolbarPosition\"\n  [(ngModel)]=\"title\" [required]=\"true\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n>\n  <div quill-editor-toolbar=\"true\">\n    <span class=\"ql-formats\">\n      <button class=\"ql-bold\" [title]=\"'Bold'\"></button>\n    </span>\n    <span class=\"ql-formats\">\n      <select class=\"ql-align\" [title]=\"'Aligment'\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n      <select class=\"ql-align\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n    </span>\n  </div>\n  <div above-quill-editor-toolbar=\"true\">\n    <span>above</span>\n  </div>\n  <div below-quill-editor-toolbar=\"true\">\n    <span>below</span>\n  </div>\n</quill-editor>\n`\n})\nclass TestToolbarComponent {\n  title = 'Hallo'\n  isReadOnly = false\n  minLength = 0\n  maxLength = 0\n  toolbarPosition = 'top'\n\n  handleEditorCreated() {return}\n  handleChange() {return}\n}\n\n@Component({\n  imports: [QuillModule, ReactiveFormsModule],\n  selector: 'quill-reactive-test',\n  template: `\n    <quill-editor [formControl]='formControl' [minLength]='minLength'></quill-editor>\n`\n})\nclass ReactiveFormTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  formControl: FormControl = new FormControl('a')\n  minLength = 3\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"[{path: 'modules/custom', implementation: impl}]\"></quill-editor>\n`\n})\nclass CustomModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  impl = CustomModule\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-async-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"customModules\"></quill-editor>\n`\n})\nclass CustomAsynchronousModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  customModules = [\n    {\n      path: 'modules/custom',\n      implementation: defer(() => Promise.resolve(CustomModule))\n    }\n  ]\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-link-placeholder-test',\n  template: `\n    <quill-editor [ngModel]=\"content\" [linkPlaceholder]=\"'https://test.de'\"></quill-editor>\n`\n})\nclass CustomLinkPlaceholderTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  content = ''\n}\n\ndescribe('Basic QuillEditorComponent', () => {\n  let fixture: ComponentFixture<QuillEditorComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n\n      ],\n      providers: QuillModule.forRoot().providers\n    })\n    fixture = TestBed.createComponent(QuillEditorComponent)\n  })\n\n  it('ngOnDestroy - removes listeners', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const spy = spyOn(fixture.componentInstance.quillEditor, 'off').and.callThrough()\n\n    fixture.componentInstance.ngOnDestroy()\n\n    expect(spy).toHaveBeenCalledTimes(3)\n    const quillEditor: any = fixture.componentInstance.quillEditor\n    expect(quillEditor.emitter._events['editor-change'].length).toBe(4)\n    expect(quillEditor.emitter._events['selection-change']).toBeInstanceOf(Object)\n    expect(quillEditor.emitter._events['text-change']).toBeFalsy()\n  })\n\n  it('should render toolbar', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('div.ql-toolbar.ql-snow').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n  })\n\n  it('should render text div', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('div.ql-container.ql-snow').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n  })\n})\n\ndescribe('Formats', () => {\n  describe('object', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"object\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class ObjectComponent {\n      title = [{\n        insert: 'Hello'\n      }]\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<ObjectComponent>\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(ObjectComponent) as ComponentFixture<ObjectComponent>\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n    it('should be set object', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hello\\n' }] }))\n    })\n\n    it('should update text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.title = [{ insert: '1234' }]\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: '1234\\n' }] }))\n    })\n\n    it('should update model if editor text changes', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      component.editor.setContents([{ insert: '123' }], 'user')\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.title)).toEqual(JSON.stringify({ ops: [{ insert: '123\\n' }] }))\n    })\n  })\n\n  describe('html', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"html\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class HTMLComponent {\n      title = '<p>Hallo<ol><li>ordered</li></ol><ul><li>unordered</li></ul></p>'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" [sanitize]=\"true\" format=\"html\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class HTMLSanitizeComponent {\n      title = '<p>Hallo <img src=\"wroooong.jpg\" onerror=\"window.alert(\\'sanitize me\\')\"></p>'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<HTMLComponent>\n    let component: HTMLComponent\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule.forRoot()]\n      })\n\n      fixture = TestBed.createComponent(HTMLComponent) as ComponentFixture<HTMLComponent>\n      component = fixture.componentInstance\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n    it('should be set html', async () => {\n      expect(component.editor.getText().trim()).toEqual(`Hallo\nordered\nunordered`)\n    })\n\n    it('should update html', async () => {\n      component.title = '<p>test</p>'\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.editor.getText().trim()).toEqual('test')\n    })\n\n    it('should update model if editor html changes', async () => {\n      expect(component.title.trim()).toEqual('<p>Hallo<ol><li>ordered</li></ol><ul><li>unordered</li></ul></p>')\n      component.editor.setText('1234', 'user')\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.title.trim()).toEqual('<p>1234</p>')\n    })\n\n    it('should sanitize html', async () => {\n      const sanfixture = TestBed.createComponent(HTMLSanitizeComponent) as ComponentFixture<HTMLSanitizeComponent>\n      sanfixture.detectChanges()\n\n      await sanfixture.whenStable()\n      const incomponent = sanfixture.componentInstance\n\n      expect(JSON.stringify(incomponent.editor.getContents()))\n      .toEqual(JSON.stringify({ ops: [{ insert: 'Hallo ' }, { insert: { image: 'wroooong.jpg' } }, { insert: '\\n' }] }))\n\n      incomponent.title = '<p><img src=\"xxxx\" onerror=\"window.alert()\"></p>'\n      sanfixture.detectChanges()\n\n      await sanfixture.whenStable()\n      expect(JSON.stringify(incomponent.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: { image: 'xxxx' } }, { insert: '\\n' }] }))\n    })\n  })\n\n  describe('text', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"text\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class TextComponent {\n      title = 'Hallo'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<TextComponent>\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(TextComponent) as ComponentFixture<TextComponent>\n      fixture.detectChanges()\n    })\n    it('should be set text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      expect(component.editor.getText().trim()).toEqual('Hallo')\n    })\n\n    it('should update text', async () => {\n      const component = fixture.componentInstance\n      component.title = 'test'\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(component.editor.getText().trim()).toEqual('test')\n    })\n\n    it('should update model if editor text changes', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.editor.setText('123', 'user')\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.title.trim()).toEqual('123')\n    })\n\n    it('should not update model if editor content changed by api', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.editor.setText('123')\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.title.trim()).toEqual('Hallo')\n    })\n  })\n\n  describe('json', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      selector: 'json-valid',\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"json\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class JSONComponent {\n      title = JSON.stringify([{\n        insert: 'Hallo'\n      }])\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    @Component({\n      imports: [QuillModule, FormsModule],\n      selector: 'quill-json-invalid',\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"json\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class JSONInvalidComponent {\n      title = JSON.stringify([{\n        insert: 'Hallo'\n      }]) + '{'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<JSONComponent>\n    let component: JSONComponent\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule.forRoot()]\n      })\n\n      fixture = TestBed.createComponent(JSONComponent) as ComponentFixture<JSONComponent>\n      component = fixture.componentInstance\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n\n    it('should set json string', async () => {\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hallo\\n' }] }))\n    })\n\n    it('should update json string', async () => {\n      component.title = JSON.stringify([{\n        insert: 'Hallo 123'\n      }])\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hallo 123\\n' }] }))\n    })\n\n    it('should update model if editor changes', async () => {\n      component.editor.setContents([{\n        insert: 'Hallo 123'\n      }], 'user')\n      fixture.detectChanges()\n      await fixture.whenStable()\n\n      expect(component.title).toEqual(JSON.stringify({ ops: [{ insert: 'Hallo 123\\n' }] }))\n    })\n\n    it('should set as text if invalid JSON', async () => {\n      const infixture = TestBed.createComponent(JSONInvalidComponent) as ComponentFixture<JSONInvalidComponent>\n      infixture.detectChanges()\n      await infixture.whenStable()\n      const incomponent = infixture.componentInstance\n      expect(incomponent.editor.getText().trim()).toEqual(JSON.stringify([{\n        insert: 'Hallo'\n      }]) + '{')\n\n      incomponent.title = JSON.stringify([{\n        insert: 'Hallo 1234'\n      }]) + '{'\n      infixture.detectChanges()\n      await infixture.whenStable()\n      expect(incomponent.editor.getText().trim()).toEqual(JSON.stringify([{\n        insert: 'Hallo 1234'\n      }]) + '{')\n    })\n  })\n})\n\ndescribe('Dynamic styles', () => {\n  @Component({\n    imports: [QuillModule, FormsModule],\n    template: `\n  <quill-editor\n    [bounds]=\"'self'\"\n    [(ngModel)]=\"title\"\n    format=\"text\"\n    [styles]=\"style\"\n    (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n  `\n  })\n  class StylingComponent {\n    title = 'Hallo'\n    style = {\n      backgroundColor: 'red'\n    }\n    editor: any\n\n    handleEditorCreated(event: any) {\n      this.editor = event\n    }\n  }\n\n  let fixture: ComponentFixture<StylingComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [FormsModule, QuillModule],\n      providers: QuillModule.forRoot().providers\n    })\n\n    fixture = TestBed.createComponent(StylingComponent) as ComponentFixture<StylingComponent>\n    fixture.detectChanges()\n  })\n\n  it('set inital styles', async () => {\n    const component = fixture.componentInstance\n    await fixture.whenStable()\n    expect(component.editor.container.style.backgroundColor).toEqual('red')\n  })\n\n  it('set style', async () => {\n    const component = fixture.componentInstance\n    await fixture.whenStable()\n    component.style = {\n      backgroundColor: 'gray'\n    }\n    fixture.detectChanges()\n    await fixture.whenStable()\n    expect(component.editor.container.style.backgroundColor).toEqual('gray')\n  })\n})\n\ndescribe('Dynamic classes', () => {\n  @Component({\n    imports: [QuillModule, FormsModule],\n    template: `\n  <quill-editor\n    [bounds]=\"'self'\"\n    [(ngModel)]=\"title\"\n    format=\"text\"\n    [classes]=\"classes\"\n    (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n  `\n  })\n  class ClassesComponent {\n    title = 'Hallo'\n    classes = 'test-class1 test-class2'\n    editor: any\n    constructor(public renderer2: Renderer2) {\n    }\n    handleEditorCreated(event: any) {\n      this.editor = event\n    }\n  }\n\n  let fixture: ComponentFixture<ClassesComponent>\n\n  beforeEach(async () => {\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [FormsModule, QuillModule.forRoot()]\n    })\n\n    fixture = TestBed.createComponent(ClassesComponent) as ComponentFixture<ClassesComponent>\n    fixture.detectChanges()\n    await fixture.whenStable()\n  })\n\n  it('should set initial classes', async () => {\n    const component = fixture.componentInstance\n    expect(component.editor.container.classList.contains('test-class1')).toBe(true)\n    expect(component.editor.container.classList.contains('test-class2')).toBe(true)\n  })\n\n  it('should set class', async () => {\n    const component = fixture.componentInstance\n\n    component.classes = 'test-class2 test-class3'\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(component.editor.container.classList.contains('test-class1')).toBe(false)\n    expect(component.editor.container.classList.contains('test-class2')).toBe(true)\n    expect(component.editor.container.classList.contains('test-class3')).toBe(true)\n  })\n})\n\ndescribe('class normalization function', () => {\n  it('should trim white space', () => {\n    const classList = QuillEditorComponent.normalizeClassNames('test-class  ')\n\n    expect(classList).toEqual(['test-class'])\n  })\n\n  it('should not return empty strings as class names', () => {\n    const classList = QuillEditorComponent.normalizeClassNames('test-class   test-class2')\n\n    expect(classList).toEqual(['test-class', 'test-class2'])\n  })\n})\n\ndescribe('Reactive forms integration', () => {\n  let fixture: ComponentFixture<ReactiveFormTestComponent>\n\n  beforeEach(async () => {\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [FormsModule, ReactiveFormsModule, QuillModule],\n      providers: QuillModule.forRoot().providers\n    })\n\n    fixture = TestBed.createComponent(ReactiveFormTestComponent) as ComponentFixture<ReactiveFormTestComponent>\n    fixture.detectChanges()\n    await fixture.whenStable()\n  })\n\n  it('should be disabled', () => {\n    const component = fixture.componentInstance\n    component.formControl.disable()\n    expect((component.editor.quillEditor as any).container.classList.contains('ql-disabled')).toBeTruthy()\n  })\n\n  it('has \"disabled\" attribute', () => {\n    const component = fixture.componentInstance\n    component.formControl.disable()\n    expect(fixture.nativeElement.children[0].attributes.disabled).toBeDefined()\n  })\n\n  it('should re-enable', () => {\n    const component = fixture.componentInstance\n    component.formControl.disable()\n\n    component.formControl.enable()\n\n    expect((component.editor.quillEditor as any).container.classList.contains('ql-disabled')).toBeFalsy()\n    expect(fixture.nativeElement.children[0].attributes.disabled).not.toBeDefined()\n  })\n\n  it('should leave form pristine when content of editor changed programmatically', async () => {\n    const values: (string | null)[] = []\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.componentInstance.formControl.valueChanges.subscribe((value: string) => values.push(value))\n    fixture.componentInstance.formControl.patchValue('1234')\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(fixture.nativeElement.querySelector('div.ql-editor').textContent).toEqual('1234')\n    expect(fixture.componentInstance.formControl.value).toEqual('1234')\n    expect(fixture.componentInstance.formControl.pristine).toBeTruthy()\n    expect(values).toEqual(['1234'])\n  })\n\n  it('should mark form dirty when content of editor changed by user', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    fixture.componentInstance.editor.quillEditor.setText('1234', 'user')\n    fixture.detectChanges()\n    await fixture.whenStable()\n    expect(fixture.nativeElement.querySelector('div.ql-editor').textContent).toEqual('1234')\n    expect(fixture.componentInstance.formControl.dirty).toBeTruthy()\n    expect(fixture.componentInstance.formControl.value).toEqual('<p>1234</p>')\n  })\n\n  it('should validate initial content and do not mark it as invalid', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(fixture.nativeElement.querySelector('div.ql-editor').textContent).toEqual('a')\n    expect(fixture.componentInstance.formControl.pristine).toBeTruthy()\n    expect(fixture.componentInstance.formControl.value).toEqual('a')\n    expect(fixture.componentInstance.formControl.invalid).toBeTruthy()\n  })\n\n  it('should write the defaultEmptyValue when editor is emptied', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.componentInstance.editor.quillEditor.setText('', 'user')\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    // default empty value is null\n    expect(fixture.componentInstance.formControl.value).toEqual(null)\n  })\n})\n\ndescribe('Advanced QuillEditorComponent', () => {\n  let fixture: ComponentFixture<TestComponent>\n\n  beforeEach(async () => {\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [FormsModule, QuillModule],\n      providers: QuillModule.forRoot().providers\n    }).compileComponents()\n\n    fixture = TestBed.createComponent(TestComponent) as ComponentFixture<TestComponent>\n\n    spyOn(Quill, 'import').and.callThrough()\n    spyOn(Quill, 'register').and.callThrough()\n  })\n\n  it('should set editor settings', async () => {\n    const editorElem = fixture.debugElement.children[0]\n    const editorCmp = fixture.debugElement.children[0].componentInstance\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(editorCmp.readOnly()).toBe(false)\n\n    fixture.componentInstance.isReadOnly = true\n\n    expect(Quill.import).toHaveBeenCalledWith('attributors/style/size')\n    expect(Quill.register).toHaveBeenCalled()\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(editorCmp.readOnly()).toBe(true)\n    expect(editorElem.nativeElement.querySelectorAll('div.ql-container.ql-disabled').length).toBe(1)\n    expect(editorElem.nativeElement.querySelector('div[quill-editor-element]').style.height).toBe('30px')\n  })\n\n  it('should update editor style', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const editorElem = fixture.debugElement.children[0]\n\n    fixture.componentInstance.style = { backgroundColor: 'red' }\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(editorElem.nativeElement.querySelector('div[quill-editor-element]').style.backgroundColor).toBe('red')\n    expect(editorElem.nativeElement.querySelector('div[quill-editor-element]').style.height).toEqual('')\n  })\n\n  it('should update editor style to null and readd styling', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const editorElem = fixture.debugElement.children[0]\n\n    fixture.componentInstance.style = null\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.componentInstance.style = { color: 'red' }\n    expect(editorElem.nativeElement.querySelector('div[quill-editor-element]').style.height).toEqual('')\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(editorElem.nativeElement.querySelector('div[quill-editor-element]').style.color).toBe('red')\n  })\n\n  it('should not update editor style if nothing changed', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const editorElem = fixture.debugElement.children[0]\n\n    fixture.componentInstance.isReadOnly = true\n    fixture.detectChanges()\n\n    await fixture.whenStable\n    expect(editorElem.nativeElement.querySelector('div[quill-editor-element]').style.height).toEqual('30px')\n  })\n\n  it('should set touched state correctly', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const editorFixture = fixture.debugElement.children[0]\n\n    editorFixture.componentInstance.quillEditor.setSelection(0, 5)\n    fixture.detectChanges()\n    await fixture.whenStable()\n    editorFixture.componentInstance.quillEditor.setSelection(null)\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(editorFixture.nativeElement.className).toMatch('ng-untouched')\n\n    editorFixture.componentInstance.quillEditor.setSelection(0, 5, 'user')\n    fixture.detectChanges()\n    await fixture.whenStable()\n    editorFixture.componentInstance.quillEditor.setSelection(null, 'user')\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(editorFixture.nativeElement.className).toMatch('ng-touched')\n  })\n\n  it('should set required state correctly', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    // get editor component\n    const editorElement = fixture.debugElement.children[0].nativeElement\n\n    fixture.componentInstance.title = ''\n    fixture.detectChanges()\n    await fixture.whenStable()\n    expect(editorElement.className).toMatch('ng-valid')\n  })\n\n  it('should emit onEditorCreated with editor instance',  async () => {\n    fixture.componentInstance.editorComponent.onValidatorChanged = () => { return }\n\n    spyOn(fixture.componentInstance, 'handleEditorCreated')\n\n    fixture.detectChanges()\n    spyOn(fixture.componentInstance.editorComponent, 'onValidatorChanged')\n\n    await fixture.whenStable()\n\n    const editorComponent = fixture.debugElement.children[0].componentInstance\n    expect(fixture.componentInstance.handleEditorCreated).toHaveBeenCalledWith(editorComponent.quillEditor)\n    expect(fixture.componentInstance.editorComponent.onValidatorChanged).toHaveBeenCalled()\n  })\n\n  it('should emit onContentChanged when content of editor changed + editor changed', async () => {\n    spyOn(fixture.componentInstance, 'handleChange').and.callThrough()\n    spyOn(fixture.componentInstance, 'handleEditorChange').and.callThrough()\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const editorFixture = fixture.debugElement.children[0]\n    editorFixture.componentInstance.quillEditor.setText('1234', 'user')\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(fixture.componentInstance.handleChange).toHaveBeenCalledWith(fixture.componentInstance.changed)\n    expect(fixture.componentInstance.handleEditorChange).toHaveBeenCalledWith(fixture.componentInstance.changedEditor)\n  })\n\n  it('should emit onContentChanged with a delay after content of editor changed + editor changed', fakeAsync(() => {\n    fixture.componentInstance.debounceTime = 400\n    spyOn(fixture.componentInstance, 'handleChange').and.callThrough()\n    spyOn(fixture.componentInstance, 'handleEditorChange').and.callThrough()\n\n    fixture.detectChanges()\n    tick()\n\n    const editorFixture = fixture.debugElement.children[0]\n    editorFixture.componentInstance.quillEditor.setText('foo', 'bar')\n    fixture.detectChanges()\n    tick()\n\n    expect(fixture.componentInstance.handleChange).not.toHaveBeenCalled()\n    expect(fixture.componentInstance.handleEditorChange).not.toHaveBeenCalled()\n\n    tick(400)\n\n    expect(fixture.componentInstance.handleChange).toHaveBeenCalledWith(fixture.componentInstance.changed)\n    expect(fixture.componentInstance.handleEditorChange).toHaveBeenCalledWith(fixture.componentInstance.changedEditor)\n  }))\n\n  it('should emit onContentChanged once after editor content changed twice within debounce interval + editor changed',\n    fakeAsync(() => {\n      fixture.componentInstance.debounceTime = 400\n      spyOn(fixture.componentInstance, 'handleChange').and.callThrough()\n      spyOn(fixture.componentInstance, 'handleEditorChange').and.callThrough()\n\n      fixture.detectChanges()\n      tick()\n\n      const editorFixture = fixture.debugElement.children[0]\n      editorFixture.componentInstance.quillEditor.setText('foo', 'bar')\n      fixture.detectChanges()\n      tick(200)\n\n      editorFixture.componentInstance.quillEditor.setText('baz', 'bar')\n      fixture.detectChanges()\n      tick(400)\n\n      expect(fixture.componentInstance.handleChange).toHaveBeenCalledTimes(1)\n      expect(fixture.componentInstance.handleChange).toHaveBeenCalledWith(fixture.componentInstance.changed)\n      expect(fixture.componentInstance.handleEditorChange).toHaveBeenCalledTimes(1)\n      expect(fixture.componentInstance.handleEditorChange).toHaveBeenCalledWith(fixture.componentInstance.changedEditor)\n    })\n  )\n\n  it(`should adjust the debounce time if the value of 'debounceTime' changes`, fakeAsync(() => {\n    fixture.componentInstance.debounceTime = 400\n    const handleChangeSpy = spyOn(fixture.componentInstance, 'handleChange').and.callThrough()\n    const handleEditorChangeSpy = spyOn(fixture.componentInstance, 'handleEditorChange').and.callThrough()\n\n    fixture.detectChanges()\n    tick()\n\n    const editorFixture = fixture.debugElement.children[0]\n    editorFixture.componentInstance.quillEditor.setText('foo', 'bar')\n    fixture.detectChanges()\n    tick()\n\n    expect(fixture.componentInstance.handleChange).not.toHaveBeenCalled()\n    expect(fixture.componentInstance.handleEditorChange).not.toHaveBeenCalled()\n\n    tick(400)\n\n    expect(fixture.componentInstance.handleChange).toHaveBeenCalledWith(fixture.componentInstance.changed)\n    expect(fixture.componentInstance.handleEditorChange).toHaveBeenCalledWith(fixture.componentInstance.changedEditor)\n    handleChangeSpy.calls.reset()\n    handleEditorChangeSpy.calls.reset()\n\n    fixture.componentInstance.debounceTime = 200\n    fixture.detectChanges()\n    tick()\n\n    editorFixture.componentInstance.quillEditor.setText('baz', 'foo')\n    fixture.detectChanges()\n    tick()\n\n    expect(fixture.componentInstance.handleChange).not.toHaveBeenCalled()\n    expect(fixture.componentInstance.handleEditorChange).not.toHaveBeenCalled()\n\n    tick(200)\n\n    expect(fixture.componentInstance.handleChange).toHaveBeenCalledWith(fixture.componentInstance.changed)\n    expect(fixture.componentInstance.handleEditorChange).toHaveBeenCalledWith(fixture.componentInstance.changedEditor)\n  }))\n\n  it('should unsubscribe from Quill events on destroy', async () => {\n    fixture.componentInstance.debounceTime = 400\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const editorFixture = fixture.debugElement.children[0]\n    const quillOffSpy = spyOn(editorFixture.componentInstance.quillEditor, 'off').and.callThrough()\n    editorFixture.componentInstance.quillEditor.setText('baz', 'bar')\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.destroy()\n\n    expect(quillOffSpy).toHaveBeenCalledTimes(3)\n    expect(editorFixture.componentInstance.subscription).toEqual(null)\n    expect(quillOffSpy).toHaveBeenCalledWith('text-change', jasmine.any(Function))\n    expect(quillOffSpy).toHaveBeenCalledWith('editor-change', jasmine.any(Function))\n    expect(quillOffSpy).toHaveBeenCalledWith('selection-change', jasmine.any(Function))\n  })\n\n  it('should emit onSelectionChanged when selection changed + editor changed', async () => {\n    spyOn(fixture.componentInstance, 'handleSelection').and.callThrough()\n    spyOn(fixture.componentInstance, 'handleEditorChange').and.callThrough()\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const editorFixture = fixture.debugElement.children[0]\n\n    editorFixture.componentInstance.quillEditor.focus()\n    editorFixture.componentInstance.quillEditor.blur()\n    fixture.detectChanges()\n\n    expect(fixture.componentInstance.handleSelection).toHaveBeenCalledWith(fixture.componentInstance.selected)\n    expect(fixture.componentInstance.handleEditorChange).toHaveBeenCalledWith(fixture.componentInstance.changedEditor)\n  })\n\n  it('should emit onFocus when focused', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const editorFixture = fixture.debugElement.children[0]\n\n    editorFixture.componentInstance.quillEditor.focus()\n    fixture.detectChanges()\n\n    expect(fixture.componentInstance.focused).toBe(true)\n  })\n\n  it('should emit onNativeFocus when scroll container receives focus', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const editorFixture = fixture.debugElement.children[0]\n\n    editorFixture.componentInstance.quillEditor.scroll.domNode.focus()\n    fixture.detectChanges()\n\n    expect(fixture.componentInstance.focusedNative).toBe(true)\n  })\n\n  it('should emit onBlur when blured', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const editorFixture = fixture.debugElement.children[0]\n\n    editorFixture.componentInstance.quillEditor.focus()\n    editorFixture.componentInstance.quillEditor.blur()\n    fixture.detectChanges()\n\n    expect(fixture.componentInstance.blured).toBe(true)\n  })\n\n  it('should emit onNativeBlur when scroll container receives blur', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const editorFixture = fixture.debugElement.children[0]\n\n    editorFixture.componentInstance.quillEditor.scroll.domNode.focus()\n    editorFixture.componentInstance.quillEditor.scroll.domNode.blur()\n    fixture.detectChanges()\n\n    expect(fixture.componentInstance.bluredNative).toBe(true)\n  })\n\n  it('should validate minlength', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    // get editor component\n    const editorComponent = fixture.debugElement.children[0].componentInstance\n    const editorElement = fixture.debugElement.children[0].nativeElement\n\n    expect(editorElement.className).toMatch('ng-valid')\n\n    // set minlength\n    fixture.componentInstance.minLength = 8\n    fixture.detectChanges()\n    await fixture.whenStable()\n    expect(editorComponent.minLength()).toBe(8)\n\n    fixture.componentInstance.title = 'Hallo1'\n    fixture.detectChanges()\n    await fixture.whenStable()\n    fixture.detectChanges()\n    await fixture.whenStable()\n    expect(editorElement.className).toMatch('ng-invalid')\n  })\n\n  it('should set valid minlength if model is empty', async () => {\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    // get editor component\n    const editorComponent = fixture.debugElement.children[0].componentInstance\n    const editorElement = fixture.debugElement.children[0].nativeElement\n\n    // set min length\n    fixture.componentInstance.minLength = 2\n    // change text\n    editorComponent.quillEditor.setText('', 'user')\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.detectChanges()\n    expect(editorElement.className).toMatch('ng-valid')\n  })\n\n  it('should validate maxlength', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    // get editor component\n    const editorComponent = fixture.debugElement.children[0].componentInstance\n    const editorElement = fixture.debugElement.children[0].nativeElement\n\n    expect(fixture.debugElement.children[0].nativeElement.className).toMatch('ng-valid')\n\n    fixture.componentInstance.maxLength = 3\n    fixture.componentInstance.title = '1234'\n    fixture.detectChanges()\n\n    await fixture.whenStable()\n    fixture.detectChanges()\n\n    expect(editorComponent.maxLength()).toBe(3)\n    expect(editorElement.className).toMatch('ng-invalid')\n  })\n\n  it('should validate maxlength and minlength', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    // get editor component\n    const editorElement = fixture.debugElement.children[0].nativeElement\n\n    expect(fixture.debugElement.children[0].nativeElement.className).toMatch('ng-valid')\n\n    fixture.componentInstance.minLength = 3\n    fixture.componentInstance.maxLength = 5\n    fixture.componentInstance.title = '123456'\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.detectChanges()\n    expect(editorElement.className).toMatch('ng-invalid')\n\n    fixture.componentInstance.title = '1234'\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n    fixture.detectChanges()\n    expect(editorElement.className).toMatch('ng-valid')\n  })\n\n  it('should validate maxlength and minlength with trimming white spaces', async () => {\n    // get editor component\n    const editorElement = fixture.debugElement.children[0].nativeElement\n    fixture.componentInstance.trimOnValidation = true\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(fixture.debugElement.children[0].nativeElement.className).toMatch('ng-valid')\n\n    fixture.componentInstance.minLength = 3\n    fixture.componentInstance.maxLength = 5\n    fixture.componentInstance.title = '  1234567  '\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.detectChanges()\n    expect(editorElement.className).toMatch('ng-invalid')\n\n    fixture.componentInstance.title = '  1234  '\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n    fixture.detectChanges()\n\n    expect(editorElement.className).toMatch('ng-valid')\n  })\n\n  it('should validate required', async () => {\n    // get editor component\n    const editorElement = fixture.debugElement.children[0].nativeElement\n    const editorComponent = fixture.debugElement.children[0].componentInstance\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(fixture.debugElement.children[0].nativeElement.className).toMatch('ng-valid')\n    expect(editorComponent.required()).toBeFalsy()\n\n    fixture.componentInstance.required = true\n    fixture.componentInstance.title = ''\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n    fixture.detectChanges()\n\n    expect(editorComponent.required()).toBeTruthy()\n    expect(editorElement.className).toMatch('ng-invalid')\n\n    fixture.componentInstance.title = '1'\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.detectChanges()\n    expect(editorElement.className).toMatch('ng-valid')\n\n    fixture.componentInstance.title = '<img src=\"test.jpg\">'\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.detectChanges()\n    expect(editorElement.className).toMatch('ng-valid')\n  })\n\n  it('should add custom toolbar', async () => {\n    // get editor component\n    const toolbarFixture = TestBed.createComponent(TestToolbarComponent) as ComponentFixture<TestToolbarComponent>\n\n    toolbarFixture.detectChanges()\n    await toolbarFixture.whenStable()\n\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[0].attributes['above-quill-editor-toolbar']).toBeDefined()\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[1].attributes['quill-editor-toolbar']).toBeDefined()\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[2].attributes['below-quill-editor-toolbar']).toBeDefined()\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[3].attributes['quill-editor-element']).toBeDefined()\n\n    const editorComponent = toolbarFixture.debugElement.children[0].componentInstance\n    expect(editorComponent.required()).toBe(true)\n    expect(editorComponent.customToolbarPosition()).toEqual('top')\n  })\n\n  it('should add custom toolbar at the end', async () => {\n    // get editor component\n    const toolbarFixture = TestBed.createComponent(TestToolbarComponent) as ComponentFixture<TestToolbarComponent>\n    toolbarFixture.componentInstance.toolbarPosition = 'bottom'\n\n    toolbarFixture.detectChanges()\n    await toolbarFixture.whenStable()\n\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[0].attributes['quill-editor-element']).toBeDefined()\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[1].attributes['above-quill-editor-toolbar']).toBeDefined()\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[2].attributes['quill-editor-toolbar']).toBeDefined()\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[3].attributes['below-quill-editor-toolbar']).toBeDefined()\n\n    const editorComponent = toolbarFixture.debugElement.children[0].componentInstance\n    expect(editorComponent.customToolbarPosition()).toEqual('bottom')\n  })\n\n  it('should render custom link placeholder', async () => {\n    const linkFixture = TestBed.createComponent(CustomLinkPlaceholderTestComponent) as ComponentFixture<CustomLinkPlaceholderTestComponent>\n\n    linkFixture.detectChanges()\n    await linkFixture.whenStable()\n\n    const el = linkFixture.nativeElement.querySelector('input[data-link]')\n\n    expect(el.dataset.link).toBe('https://test.de')\n  })\n})\n\ndescribe('QuillEditor - base config', () => {\n  let fixture: ComponentFixture<TestComponent>\n  let registerSpy: jasmine.Spy\n  let importSpy: jasmine.Spy\n\n  beforeAll(() => {\n    importSpy = spyOn(Quill, 'import').and.callThrough()\n    registerSpy = spyOn(Quill, 'register').and.callThrough()\n  })\n\n  beforeEach(async () => {\n\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [FormsModule, QuillModule],\n      providers: QuillModule.forRoot({\n        customModules: [{\n          path: 'modules/custom',\n          implementation: CustomModule\n        }],\n        customOptions: [{\n          import: 'attributors/style/size',\n          whitelist: ['14']\n        }],\n        suppressGlobalRegisterWarning: true,\n        bounds: 'body',\n        debug: false,\n        format: 'object',\n        formats: ['bold'],\n        modules: {\n          toolbar: [\n            ['bold']\n          ]\n        },\n        placeholder: 'placeholder',\n        readOnly: true,\n        theme: 'snow',\n        trackChanges: 'all'\n      }).providers\n    }).compileComponents()\n\n    fixture = TestBed.createComponent(TestComponent)\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(registerSpy).toHaveBeenCalledWith('modules/custom', CustomModule, true)\n    expect(importSpy).toHaveBeenCalledWith('attributors/style/size')\n  })\n\n  it('renders editor with config',  async () => {\n\n    const editor = fixture.componentInstance.editor as Quill\n\n    expect(fixture.nativeElement.querySelector('.ql-toolbar').querySelectorAll('button').length).toBe(1)\n    expect(fixture.nativeElement.querySelector('.ql-toolbar').querySelector('button.ql-bold')).toBeDefined()\n\n    editor.updateContents([{\n      insert: 'content',\n      attributes: {\n        bold: true,\n        italic: true\n      }\n    }] as any, 'api')\n    fixture.detectChanges()\n\n    expect(JSON.stringify(fixture.componentInstance.title))\n      .toEqual(JSON.stringify({ ops: [{ attributes: { bold: true },\ninsert: 'content' }, { insert: '\\n' }] }))\n    expect(editor.root.dataset.placeholder).toEqual('placeholder')\n    expect(registerSpy).toHaveBeenCalledWith(\n      jasmine.objectContaining({ attrName: 'size',\nkeyName: 'font-size',\nscope: 5,\nwhitelist: ['14'] }), true, true\n    )\n\n    expect(fixture.componentInstance.editorComponent.quillEditor['options'].modules.toolbar)\n      .toEqual(jasmine.objectContaining({\n        container: [\n          ['bold']\n        ]\n      }))\n  })\n})\n\ndescribe('QuillEditor - customModules', () => {\n  let fixture: ComponentFixture<CustomModuleTestComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [FormsModule, QuillModule],\n      providers: QuillModule.forRoot().providers\n    }).compileComponents()\n  })\n\n  it('renders editor with config', async () => {\n    const spy = spyOn(Quill, 'register').and.callThrough()\n    fixture = TestBed.createComponent(CustomModuleTestComponent)\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(spy).toHaveBeenCalled()\n    expect(fixture.componentInstance.editor.quillEditor['options'].modules.custom).toBeDefined()\n  })\n})\n\ndescribe('QuillEditor - customModules (asynchronous)', () => {\n  let fixture: ComponentFixture<CustomAsynchronousModuleTestComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [FormsModule, QuillModule],\n      providers: QuillModule.forRoot().providers\n    }).compileComponents()\n  })\n\n  it('renders editor with config', async () => {\n    const spy = spyOn(Quill, 'register').and.callThrough()\n    fixture = TestBed.createComponent(CustomAsynchronousModuleTestComponent)\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(spy).toHaveBeenCalled()\n    expect(fixture.componentInstance.editor.quillEditor['options'].modules.custom).toBeDefined()\n  })\n})\n\ndescribe('QuillEditor - defaultEmptyValue', () => {\n  @Component({\n    changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/prefer-signals","severity":2,"message":"Use the `viewChild` function instead of the `ViewChild` decorator","line":1430,"column":5,"nodeType":"Decorator","messageId":"preferQuerySignals","endLine":1430,"endColumn":55},{"ruleId":"@angular-eslint/use-component-selector","severity":2,"message":"The selector of the component is mandatory","line":1453,"column":3,"nodeType":"Decorator","messageId":"useComponentSelector","endLine":1458,"endColumn":5},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":1453,"column":3,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":1458,"endColumn":5,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[40,46942],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, fakeAsync, TestBed, tick } from '@angular/core/testing'\nimport { defer } from 'rxjs'\n\nimport { FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms'\n\nimport { QuillEditorComponent } from './quill-editor.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nwindow.setTimeout = ((cb) => {\n  cb()\n  return 0\n}) as any\n\n// const Quill = require('quill')\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-test',\n  template: `\n<quill-editor\n  (onBlur)=\"blured = true\"\n  (onFocus)=\"focused = true\"\n  (onNativeBlur)=\"bluredNative = true\"\n  (onNativeFocus)=\"focusedNative = true\"\n  [(ngModel)]=\"title\"\n  [customOptions]=\"[{import: 'attributors/style/size', whitelist: ['14']}]\"\n  [styles]=\"style\"\n  [required]=\"required\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  [debounceTime]=\"debounceTime\"\n  [trimOnValidation]=\"trimOnValidation\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onEditorChanged)=\"handleEditorChange($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n  (onSelectionChanged)=\"handleSelection($event)\"\n></quill-editor>\n`\n})\nclass TestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editorComponent!: QuillEditorComponent\n  title: any = 'Hallo'\n  isReadOnly = false\n  required = false\n  minLength = 0\n  focused = false\n  blured = false\n  focusedNative = false\n  bluredNative = false\n  trimOnValidation = false\n  maxLength = 0\n  style: {\n    backgroundColor?: string\n    color?: string\n    height?: string\n  } | null = { height: '30px' }\n  editor: any\n  debounceTime: number\n\n  changed: any\n  changedEditor: any\n  selected: any\n\n  handleEditorCreated(event: any) {\n    this.editor = event\n  }\n\n  handleChange(event: any) {\n    this.changed = event\n  }\n\n  handleEditorChange(event: any) {\n    this.changedEditor = event\n  }\n\n  handleSelection(event: any) {\n    this.selected = event\n  }\n}\n\n@Component({\n  imports: [FormsModule, QuillModule],\n  selector: 'quill-toolbar-test',\n  template: `\n<quill-editor\n  [customToolbarPosition]=\"toolbarPosition\"\n  [(ngModel)]=\"title\" [required]=\"true\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n>\n  <div quill-editor-toolbar=\"true\">\n    <span class=\"ql-formats\">\n      <button class=\"ql-bold\" [title]=\"'Bold'\"></button>\n    </span>\n    <span class=\"ql-formats\">\n      <select class=\"ql-align\" [title]=\"'Aligment'\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n      <select class=\"ql-align\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n    </span>\n  </div>\n  <div above-quill-editor-toolbar=\"true\">\n    <span>above</span>\n  </div>\n  <div below-quill-editor-toolbar=\"true\">\n    <span>below</span>\n  </div>\n</quill-editor>\n`\n})\nclass TestToolbarComponent {\n  title = 'Hallo'\n  isReadOnly = false\n  minLength = 0\n  maxLength = 0\n  toolbarPosition = 'top'\n\n  handleEditorCreated() {return}\n  handleChange() {return}\n}\n\n@Component({\n  imports: [QuillModule, ReactiveFormsModule],\n  selector: 'quill-reactive-test',\n  template: `\n    <quill-editor [formControl]='formControl' [minLength]='minLength'></quill-editor>\n`\n})\nclass ReactiveFormTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  formControl: FormControl = new FormControl('a')\n  minLength = 3\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"[{path: 'modules/custom', implementation: impl}]\"></quill-editor>\n`\n})\nclass CustomModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  impl = CustomModule\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-async-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"customModules\"></quill-editor>\n`\n})\nclass CustomAsynchronousModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  customModules = [\n    {\n      path: 'modules/custom',\n      implementation: defer(() => Promise.resolve(CustomModule))\n    }\n  ]\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-link-placeholder-test',\n  template: `\n    <quill-editor [ngModel]=\"content\" [linkPlaceholder]=\"'https://test.de'\"></quill-editor>\n`\n})\nclass CustomLinkPlaceholderTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  content = ''\n}\n\ndescribe('Basic QuillEditorComponent', () => {\n  let fixture: ComponentFixture<QuillEditorComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n\n      ],\n      providers: QuillModule.forRoot().providers\n    })\n    fixture = TestBed.createComponent(QuillEditorComponent)\n  })\n\n  it('ngOnDestroy - removes listeners', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const spy = spyOn(fixture.componentInstance.quillEditor, 'off').and.callThrough()\n\n    fixture.componentInstance.ngOnDestroy()\n\n    expect(spy).toHaveBeenCalledTimes(3)\n    const quillEditor: any = fixture.componentInstance.quillEditor\n    expect(quillEditor.emitter._events['editor-change'].length).toBe(4)\n    expect(quillEditor.emitter._events['selection-change']).toBeInstanceOf(Object)\n    expect(quillEditor.emitter._events['text-change']).toBeFalsy()\n  })\n\n  it('should render toolbar', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('div.ql-toolbar.ql-snow').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n  })\n\n  it('should render text div', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('div.ql-container.ql-snow').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n  })\n})\n\ndescribe('Formats', () => {\n  describe('object', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"object\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class ObjectComponent {\n      title = [{\n        insert: 'Hello'\n      }]\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<ObjectComponent>\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(ObjectComponent) as ComponentFixture<ObjectComponent>\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n    it('should be set object', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hello\\n' }] }))\n    })\n\n    it('should update text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.title = [{ insert: '1234' }]\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: '1234\\n' }] }))\n    })\n\n    it('should update model if editor text changes', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      component.editor.setContents([{ insert: '123' }], 'user')\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.title)).toEqual(JSON.stringify({ ops: [{ insert: '123\\n' }] }))\n    })\n  })\n\n  describe('html', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"html\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class HTMLComponent {\n      title = '<p>Hallo<ol><li>ordered</li></ol><ul><li>unordered</li></ul></p>'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" [sanitize]=\"true\" format=\"html\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class HTMLSanitizeComponent {\n      title = '<p>Hallo <img src=\"wroooong.jpg\" onerror=\"window.alert(\\'sanitize me\\')\"></p>'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<HTMLComponent>\n    let component: HTMLComponent\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule.forRoot()]\n      })\n\n      fixture = TestBed.createComponent(HTMLComponent) as ComponentFixture<HTMLComponent>\n      component = fixture.componentInstance\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n    it('should be set html', async () => {\n      expect(component.editor.getText().trim()).toEqual(`Hallo\nordered\nunordered`)\n    })\n\n    it('should update html', async () => {\n      component.title = '<p>test</p>'\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.editor.getText().trim()).toEqual('test')\n    })\n\n    it('should update model if editor html changes', async () => {\n      expect(component.title.trim()).toEqual('<p>Hallo<ol><li>ordered</li></ol><ul><li>unordered</li></ul></p>')\n      component.editor.setText('1234', 'user')\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.title.trim()).toEqual('<p>1234</p>')\n    })\n\n    it('should sanitize html', async () => {\n      const sanfixture = TestBed.createComponent(HTMLSanitizeComponent) as ComponentFixture<HTMLSanitizeComponent>\n      sanfixture.detectChanges()\n\n      await sanfixture.whenStable()\n      const incomponent = sanfixture.componentInstance\n\n      expect(JSON.stringify(incomponent.editor.getContents()))\n      .toEqual(JSON.stringify({ ops: [{ insert: 'Hallo ' }, { insert: { image: 'wroooong.jpg' } }, { insert: '\\n' }] }))\n\n      incomponent.title = '<p><img src=\"xxxx\" onerror=\"window.alert()\"></p>'\n      sanfixture.detectChanges()\n\n      await sanfixture.whenStable()\n      expect(JSON.stringify(incomponent.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: { image: 'xxxx' } }, { insert: '\\n' }] }))\n    })\n  })\n\n  describe('text', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"text\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class TextComponent {\n      title = 'Hallo'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<TextComponent>\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(TextComponent) as ComponentFixture<TextComponent>\n      fixture.detectChanges()\n    })\n    it('should be set text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      expect(component.editor.getText().trim()).toEqual('Hallo')\n    })\n\n    it('should update text', async () => {\n      const component = fixture.componentInstance\n      component.title = 'test'\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(component.editor.getText().trim()).toEqual('test')\n    })\n\n    it('should update model if editor text changes', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.editor.setText('123', 'user')\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.title.trim()).toEqual('123')\n    })\n\n    it('should not update model if editor content changed by api', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.editor.setText('123')\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.title.trim()).toEqual('Hallo')\n    })\n  })\n\n  describe('json', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      selector: 'json-valid',\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"json\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class JSONComponent {\n      title = JSON.stringify([{\n        insert: 'Hallo'\n      }])\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    @Component({\n      imports: [QuillModule, FormsModule],\n      selector: 'quill-json-invalid',\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"json\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class JSONInvalidComponent {\n      title = JSON.stringify([{\n        insert: 'Hallo'\n      }]) + '{'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<JSONComponent>\n    let component: JSONComponent\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule.forRoot()]\n      })\n\n      fixture = TestBed.createComponent(JSONComponent) as ComponentFixture<JSONComponent>\n      component = fixture.componentInstance\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n\n    it('should set json string', async () => {\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hallo\\n' }] }))\n    })\n\n    it('should update json string', async () => {\n      component.title = JSON.stringify([{\n        insert: 'Hallo 123'\n      }])\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hallo 123\\n' }] }))\n    })\n\n    it('should update model if editor changes', async () => {\n      component.editor.setContents([{\n        insert: 'Hallo 123'\n      }], 'user')\n      fixture.detectChanges()\n      await fixture.whenStable()\n\n      expect(component.title).toEqual(JSON.stringify({ ops: [{ insert: 'Hallo 123\\n' }] }))\n    })\n\n    it('should set as text if invalid JSON', async () => {\n      const infixture = TestBed.createComponent(JSONInvalidComponent) as ComponentFixture<JSONInvalidComponent>\n      infixture.detectChanges()\n      await infixture.whenStable()\n      const incomponent = infixture.componentInstance\n      expect(incomponent.editor.getText().trim()).toEqual(JSON.stringify([{\n        insert: 'Hallo'\n      }]) + '{')\n\n      incomponent.title = JSON.stringify([{\n        insert: 'Hallo 1234'\n      }]) + '{'\n      infixture.detectChanges()\n      await infixture.whenStable()\n      expect(incomponent.editor.getText().trim()).toEqual(JSON.stringify([{\n        insert: 'Hallo 1234'\n      }]) + '{')\n    })\n  })\n})\n\ndescribe('Dynamic styles', () => {\n  @Component({\n    imports: [QuillModule, FormsModule],\n    template: `\n  <quill-editor\n    [bounds]=\"'self'\"\n    [(ngModel)]=\"title\"\n    format=\"text\"\n    [styles]=\"style\"\n    (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n  `\n  })\n  class StylingComponent {\n    title = 'Hallo'\n    style = {\n      backgroundColor: 'red'\n    }\n    editor: any\n\n    handleEditorCreated(event: any) {\n      this.editor = event\n    }\n  }\n\n  let fixture: ComponentFixture<StylingComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [FormsModule, QuillModule],\n      providers: QuillModule.forRoot().providers\n    })\n\n    fixture = TestBed.createComponent(StylingComponent) as ComponentFixture<StylingComponent>\n    fixture.detectChanges()\n  })\n\n  it('set inital styles', async () => {\n    const component = fixture.componentInstance\n    await fixture.whenStable()\n    expect(component.editor.container.style.backgroundColor).toEqual('red')\n  })\n\n  it('set style', async () => {\n    const component = fixture.componentInstance\n    await fixture.whenStable()\n    component.style = {\n      backgroundColor: 'gray'\n    }\n    fixture.detectChanges()\n    await fixture.whenStable()\n    expect(component.editor.container.style.backgroundColor).toEqual('gray')\n  })\n})\n\ndescribe('Dynamic classes', () => {\n  @Component({\n    imports: [QuillModule, FormsModule],\n    template: `\n  <quill-editor\n    [bounds]=\"'self'\"\n    [(ngModel)]=\"title\"\n    format=\"text\"\n    [classes]=\"classes\"\n    (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n  `\n  })\n  class ClassesComponent {\n    title = 'Hallo'\n    classes = 'test-class1 test-class2'\n    editor: any\n    constructor(public renderer2: Renderer2) {\n    }\n    handleEditorCreated(event: any) {\n      this.editor = event\n    }\n  }\n\n  let fixture: ComponentFixture<ClassesComponent>\n\n  beforeEach(async () => {\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [FormsModule, QuillModule.forRoot()]\n    })\n\n    fixture = TestBed.createComponent(ClassesComponent) as ComponentFixture<ClassesComponent>\n    fixture.detectChanges()\n    await fixture.whenStable()\n  })\n\n  it('should set initial classes', async () => {\n    const component = fixture.componentInstance\n    expect(component.editor.container.classList.contains('test-class1')).toBe(true)\n    expect(component.editor.container.classList.contains('test-class2')).toBe(true)\n  })\n\n  it('should set class', async () => {\n    const component = fixture.componentInstance\n\n    component.classes = 'test-class2 test-class3'\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(component.editor.container.classList.contains('test-class1')).toBe(false)\n    expect(component.editor.container.classList.contains('test-class2')).toBe(true)\n    expect(component.editor.container.classList.contains('test-class3')).toBe(true)\n  })\n})\n\ndescribe('class normalization function', () => {\n  it('should trim white space', () => {\n    const classList = QuillEditorComponent.normalizeClassNames('test-class  ')\n\n    expect(classList).toEqual(['test-class'])\n  })\n\n  it('should not return empty strings as class names', () => {\n    const classList = QuillEditorComponent.normalizeClassNames('test-class   test-class2')\n\n    expect(classList).toEqual(['test-class', 'test-class2'])\n  })\n})\n\ndescribe('Reactive forms integration', () => {\n  let fixture: ComponentFixture<ReactiveFormTestComponent>\n\n  beforeEach(async () => {\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [FormsModule, ReactiveFormsModule, QuillModule],\n      providers: QuillModule.forRoot().providers\n    })\n\n    fixture = TestBed.createComponent(ReactiveFormTestComponent) as ComponentFixture<ReactiveFormTestComponent>\n    fixture.detectChanges()\n    await fixture.whenStable()\n  })\n\n  it('should be disabled', () => {\n    const component = fixture.componentInstance\n    component.formControl.disable()\n    expect((component.editor.quillEditor as any).container.classList.contains('ql-disabled')).toBeTruthy()\n  })\n\n  it('has \"disabled\" attribute', () => {\n    const component = fixture.componentInstance\n    component.formControl.disable()\n    expect(fixture.nativeElement.children[0].attributes.disabled).toBeDefined()\n  })\n\n  it('should re-enable', () => {\n    const component = fixture.componentInstance\n    component.formControl.disable()\n\n    component.formControl.enable()\n\n    expect((component.editor.quillEditor as any).container.classList.contains('ql-disabled')).toBeFalsy()\n    expect(fixture.nativeElement.children[0].attributes.disabled).not.toBeDefined()\n  })\n\n  it('should leave form pristine when content of editor changed programmatically', async () => {\n    const values: (string | null)[] = []\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.componentInstance.formControl.valueChanges.subscribe((value: string) => values.push(value))\n    fixture.componentInstance.formControl.patchValue('1234')\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(fixture.nativeElement.querySelector('div.ql-editor').textContent).toEqual('1234')\n    expect(fixture.componentInstance.formControl.value).toEqual('1234')\n    expect(fixture.componentInstance.formControl.pristine).toBeTruthy()\n    expect(values).toEqual(['1234'])\n  })\n\n  it('should mark form dirty when content of editor changed by user', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    fixture.componentInstance.editor.quillEditor.setText('1234', 'user')\n    fixture.detectChanges()\n    await fixture.whenStable()\n    expect(fixture.nativeElement.querySelector('div.ql-editor').textContent).toEqual('1234')\n    expect(fixture.componentInstance.formControl.dirty).toBeTruthy()\n    expect(fixture.componentInstance.formControl.value).toEqual('<p>1234</p>')\n  })\n\n  it('should validate initial content and do not mark it as invalid', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(fixture.nativeElement.querySelector('div.ql-editor').textContent).toEqual('a')\n    expect(fixture.componentInstance.formControl.pristine).toBeTruthy()\n    expect(fixture.componentInstance.formControl.value).toEqual('a')\n    expect(fixture.componentInstance.formControl.invalid).toBeTruthy()\n  })\n\n  it('should write the defaultEmptyValue when editor is emptied', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.componentInstance.editor.quillEditor.setText('', 'user')\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    // default empty value is null\n    expect(fixture.componentInstance.formControl.value).toEqual(null)\n  })\n})\n\ndescribe('Advanced QuillEditorComponent', () => {\n  let fixture: ComponentFixture<TestComponent>\n\n  beforeEach(async () => {\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [FormsModule, QuillModule],\n      providers: QuillModule.forRoot().providers\n    }).compileComponents()\n\n    fixture = TestBed.createComponent(TestComponent) as ComponentFixture<TestComponent>\n\n    spyOn(Quill, 'import').and.callThrough()\n    spyOn(Quill, 'register').and.callThrough()\n  })\n\n  it('should set editor settings', async () => {\n    const editorElem = fixture.debugElement.children[0]\n    const editorCmp = fixture.debugElement.children[0].componentInstance\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(editorCmp.readOnly()).toBe(false)\n\n    fixture.componentInstance.isReadOnly = true\n\n    expect(Quill.import).toHaveBeenCalledWith('attributors/style/size')\n    expect(Quill.register).toHaveBeenCalled()\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(editorCmp.readOnly()).toBe(true)\n    expect(editorElem.nativeElement.querySelectorAll('div.ql-container.ql-disabled').length).toBe(1)\n    expect(editorElem.nativeElement.querySelector('div[quill-editor-element]').style.height).toBe('30px')\n  })\n\n  it('should update editor style', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const editorElem = fixture.debugElement.children[0]\n\n    fixture.componentInstance.style = { backgroundColor: 'red' }\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(editorElem.nativeElement.querySelector('div[quill-editor-element]').style.backgroundColor).toBe('red')\n    expect(editorElem.nativeElement.querySelector('div[quill-editor-element]').style.height).toEqual('')\n  })\n\n  it('should update editor style to null and readd styling', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const editorElem = fixture.debugElement.children[0]\n\n    fixture.componentInstance.style = null\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.componentInstance.style = { color: 'red' }\n    expect(editorElem.nativeElement.querySelector('div[quill-editor-element]').style.height).toEqual('')\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(editorElem.nativeElement.querySelector('div[quill-editor-element]').style.color).toBe('red')\n  })\n\n  it('should not update editor style if nothing changed', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const editorElem = fixture.debugElement.children[0]\n\n    fixture.componentInstance.isReadOnly = true\n    fixture.detectChanges()\n\n    await fixture.whenStable\n    expect(editorElem.nativeElement.querySelector('div[quill-editor-element]').style.height).toEqual('30px')\n  })\n\n  it('should set touched state correctly', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const editorFixture = fixture.debugElement.children[0]\n\n    editorFixture.componentInstance.quillEditor.setSelection(0, 5)\n    fixture.detectChanges()\n    await fixture.whenStable()\n    editorFixture.componentInstance.quillEditor.setSelection(null)\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(editorFixture.nativeElement.className).toMatch('ng-untouched')\n\n    editorFixture.componentInstance.quillEditor.setSelection(0, 5, 'user')\n    fixture.detectChanges()\n    await fixture.whenStable()\n    editorFixture.componentInstance.quillEditor.setSelection(null, 'user')\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(editorFixture.nativeElement.className).toMatch('ng-touched')\n  })\n\n  it('should set required state correctly', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    // get editor component\n    const editorElement = fixture.debugElement.children[0].nativeElement\n\n    fixture.componentInstance.title = ''\n    fixture.detectChanges()\n    await fixture.whenStable()\n    expect(editorElement.className).toMatch('ng-valid')\n  })\n\n  it('should emit onEditorCreated with editor instance',  async () => {\n    fixture.componentInstance.editorComponent.onValidatorChanged = () => { return }\n\n    spyOn(fixture.componentInstance, 'handleEditorCreated')\n\n    fixture.detectChanges()\n    spyOn(fixture.componentInstance.editorComponent, 'onValidatorChanged')\n\n    await fixture.whenStable()\n\n    const editorComponent = fixture.debugElement.children[0].componentInstance\n    expect(fixture.componentInstance.handleEditorCreated).toHaveBeenCalledWith(editorComponent.quillEditor)\n    expect(fixture.componentInstance.editorComponent.onValidatorChanged).toHaveBeenCalled()\n  })\n\n  it('should emit onContentChanged when content of editor changed + editor changed', async () => {\n    spyOn(fixture.componentInstance, 'handleChange').and.callThrough()\n    spyOn(fixture.componentInstance, 'handleEditorChange').and.callThrough()\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const editorFixture = fixture.debugElement.children[0]\n    editorFixture.componentInstance.quillEditor.setText('1234', 'user')\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(fixture.componentInstance.handleChange).toHaveBeenCalledWith(fixture.componentInstance.changed)\n    expect(fixture.componentInstance.handleEditorChange).toHaveBeenCalledWith(fixture.componentInstance.changedEditor)\n  })\n\n  it('should emit onContentChanged with a delay after content of editor changed + editor changed', fakeAsync(() => {\n    fixture.componentInstance.debounceTime = 400\n    spyOn(fixture.componentInstance, 'handleChange').and.callThrough()\n    spyOn(fixture.componentInstance, 'handleEditorChange').and.callThrough()\n\n    fixture.detectChanges()\n    tick()\n\n    const editorFixture = fixture.debugElement.children[0]\n    editorFixture.componentInstance.quillEditor.setText('foo', 'bar')\n    fixture.detectChanges()\n    tick()\n\n    expect(fixture.componentInstance.handleChange).not.toHaveBeenCalled()\n    expect(fixture.componentInstance.handleEditorChange).not.toHaveBeenCalled()\n\n    tick(400)\n\n    expect(fixture.componentInstance.handleChange).toHaveBeenCalledWith(fixture.componentInstance.changed)\n    expect(fixture.componentInstance.handleEditorChange).toHaveBeenCalledWith(fixture.componentInstance.changedEditor)\n  }))\n\n  it('should emit onContentChanged once after editor content changed twice within debounce interval + editor changed',\n    fakeAsync(() => {\n      fixture.componentInstance.debounceTime = 400\n      spyOn(fixture.componentInstance, 'handleChange').and.callThrough()\n      spyOn(fixture.componentInstance, 'handleEditorChange').and.callThrough()\n\n      fixture.detectChanges()\n      tick()\n\n      const editorFixture = fixture.debugElement.children[0]\n      editorFixture.componentInstance.quillEditor.setText('foo', 'bar')\n      fixture.detectChanges()\n      tick(200)\n\n      editorFixture.componentInstance.quillEditor.setText('baz', 'bar')\n      fixture.detectChanges()\n      tick(400)\n\n      expect(fixture.componentInstance.handleChange).toHaveBeenCalledTimes(1)\n      expect(fixture.componentInstance.handleChange).toHaveBeenCalledWith(fixture.componentInstance.changed)\n      expect(fixture.componentInstance.handleEditorChange).toHaveBeenCalledTimes(1)\n      expect(fixture.componentInstance.handleEditorChange).toHaveBeenCalledWith(fixture.componentInstance.changedEditor)\n    })\n  )\n\n  it(`should adjust the debounce time if the value of 'debounceTime' changes`, fakeAsync(() => {\n    fixture.componentInstance.debounceTime = 400\n    const handleChangeSpy = spyOn(fixture.componentInstance, 'handleChange').and.callThrough()\n    const handleEditorChangeSpy = spyOn(fixture.componentInstance, 'handleEditorChange').and.callThrough()\n\n    fixture.detectChanges()\n    tick()\n\n    const editorFixture = fixture.debugElement.children[0]\n    editorFixture.componentInstance.quillEditor.setText('foo', 'bar')\n    fixture.detectChanges()\n    tick()\n\n    expect(fixture.componentInstance.handleChange).not.toHaveBeenCalled()\n    expect(fixture.componentInstance.handleEditorChange).not.toHaveBeenCalled()\n\n    tick(400)\n\n    expect(fixture.componentInstance.handleChange).toHaveBeenCalledWith(fixture.componentInstance.changed)\n    expect(fixture.componentInstance.handleEditorChange).toHaveBeenCalledWith(fixture.componentInstance.changedEditor)\n    handleChangeSpy.calls.reset()\n    handleEditorChangeSpy.calls.reset()\n\n    fixture.componentInstance.debounceTime = 200\n    fixture.detectChanges()\n    tick()\n\n    editorFixture.componentInstance.quillEditor.setText('baz', 'foo')\n    fixture.detectChanges()\n    tick()\n\n    expect(fixture.componentInstance.handleChange).not.toHaveBeenCalled()\n    expect(fixture.componentInstance.handleEditorChange).not.toHaveBeenCalled()\n\n    tick(200)\n\n    expect(fixture.componentInstance.handleChange).toHaveBeenCalledWith(fixture.componentInstance.changed)\n    expect(fixture.componentInstance.handleEditorChange).toHaveBeenCalledWith(fixture.componentInstance.changedEditor)\n  }))\n\n  it('should unsubscribe from Quill events on destroy', async () => {\n    fixture.componentInstance.debounceTime = 400\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const editorFixture = fixture.debugElement.children[0]\n    const quillOffSpy = spyOn(editorFixture.componentInstance.quillEditor, 'off').and.callThrough()\n    editorFixture.componentInstance.quillEditor.setText('baz', 'bar')\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.destroy()\n\n    expect(quillOffSpy).toHaveBeenCalledTimes(3)\n    expect(editorFixture.componentInstance.subscription).toEqual(null)\n    expect(quillOffSpy).toHaveBeenCalledWith('text-change', jasmine.any(Function))\n    expect(quillOffSpy).toHaveBeenCalledWith('editor-change', jasmine.any(Function))\n    expect(quillOffSpy).toHaveBeenCalledWith('selection-change', jasmine.any(Function))\n  })\n\n  it('should emit onSelectionChanged when selection changed + editor changed', async () => {\n    spyOn(fixture.componentInstance, 'handleSelection').and.callThrough()\n    spyOn(fixture.componentInstance, 'handleEditorChange').and.callThrough()\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const editorFixture = fixture.debugElement.children[0]\n\n    editorFixture.componentInstance.quillEditor.focus()\n    editorFixture.componentInstance.quillEditor.blur()\n    fixture.detectChanges()\n\n    expect(fixture.componentInstance.handleSelection).toHaveBeenCalledWith(fixture.componentInstance.selected)\n    expect(fixture.componentInstance.handleEditorChange).toHaveBeenCalledWith(fixture.componentInstance.changedEditor)\n  })\n\n  it('should emit onFocus when focused', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const editorFixture = fixture.debugElement.children[0]\n\n    editorFixture.componentInstance.quillEditor.focus()\n    fixture.detectChanges()\n\n    expect(fixture.componentInstance.focused).toBe(true)\n  })\n\n  it('should emit onNativeFocus when scroll container receives focus', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const editorFixture = fixture.debugElement.children[0]\n\n    editorFixture.componentInstance.quillEditor.scroll.domNode.focus()\n    fixture.detectChanges()\n\n    expect(fixture.componentInstance.focusedNative).toBe(true)\n  })\n\n  it('should emit onBlur when blured', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const editorFixture = fixture.debugElement.children[0]\n\n    editorFixture.componentInstance.quillEditor.focus()\n    editorFixture.componentInstance.quillEditor.blur()\n    fixture.detectChanges()\n\n    expect(fixture.componentInstance.blured).toBe(true)\n  })\n\n  it('should emit onNativeBlur when scroll container receives blur', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const editorFixture = fixture.debugElement.children[0]\n\n    editorFixture.componentInstance.quillEditor.scroll.domNode.focus()\n    editorFixture.componentInstance.quillEditor.scroll.domNode.blur()\n    fixture.detectChanges()\n\n    expect(fixture.componentInstance.bluredNative).toBe(true)\n  })\n\n  it('should validate minlength', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    // get editor component\n    const editorComponent = fixture.debugElement.children[0].componentInstance\n    const editorElement = fixture.debugElement.children[0].nativeElement\n\n    expect(editorElement.className).toMatch('ng-valid')\n\n    // set minlength\n    fixture.componentInstance.minLength = 8\n    fixture.detectChanges()\n    await fixture.whenStable()\n    expect(editorComponent.minLength()).toBe(8)\n\n    fixture.componentInstance.title = 'Hallo1'\n    fixture.detectChanges()\n    await fixture.whenStable()\n    fixture.detectChanges()\n    await fixture.whenStable()\n    expect(editorElement.className).toMatch('ng-invalid')\n  })\n\n  it('should set valid minlength if model is empty', async () => {\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    // get editor component\n    const editorComponent = fixture.debugElement.children[0].componentInstance\n    const editorElement = fixture.debugElement.children[0].nativeElement\n\n    // set min length\n    fixture.componentInstance.minLength = 2\n    // change text\n    editorComponent.quillEditor.setText('', 'user')\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.detectChanges()\n    expect(editorElement.className).toMatch('ng-valid')\n  })\n\n  it('should validate maxlength', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    // get editor component\n    const editorComponent = fixture.debugElement.children[0].componentInstance\n    const editorElement = fixture.debugElement.children[0].nativeElement\n\n    expect(fixture.debugElement.children[0].nativeElement.className).toMatch('ng-valid')\n\n    fixture.componentInstance.maxLength = 3\n    fixture.componentInstance.title = '1234'\n    fixture.detectChanges()\n\n    await fixture.whenStable()\n    fixture.detectChanges()\n\n    expect(editorComponent.maxLength()).toBe(3)\n    expect(editorElement.className).toMatch('ng-invalid')\n  })\n\n  it('should validate maxlength and minlength', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    // get editor component\n    const editorElement = fixture.debugElement.children[0].nativeElement\n\n    expect(fixture.debugElement.children[0].nativeElement.className).toMatch('ng-valid')\n\n    fixture.componentInstance.minLength = 3\n    fixture.componentInstance.maxLength = 5\n    fixture.componentInstance.title = '123456'\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.detectChanges()\n    expect(editorElement.className).toMatch('ng-invalid')\n\n    fixture.componentInstance.title = '1234'\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n    fixture.detectChanges()\n    expect(editorElement.className).toMatch('ng-valid')\n  })\n\n  it('should validate maxlength and minlength with trimming white spaces', async () => {\n    // get editor component\n    const editorElement = fixture.debugElement.children[0].nativeElement\n    fixture.componentInstance.trimOnValidation = true\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(fixture.debugElement.children[0].nativeElement.className).toMatch('ng-valid')\n\n    fixture.componentInstance.minLength = 3\n    fixture.componentInstance.maxLength = 5\n    fixture.componentInstance.title = '  1234567  '\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.detectChanges()\n    expect(editorElement.className).toMatch('ng-invalid')\n\n    fixture.componentInstance.title = '  1234  '\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n    fixture.detectChanges()\n\n    expect(editorElement.className).toMatch('ng-valid')\n  })\n\n  it('should validate required', async () => {\n    // get editor component\n    const editorElement = fixture.debugElement.children[0].nativeElement\n    const editorComponent = fixture.debugElement.children[0].componentInstance\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(fixture.debugElement.children[0].nativeElement.className).toMatch('ng-valid')\n    expect(editorComponent.required()).toBeFalsy()\n\n    fixture.componentInstance.required = true\n    fixture.componentInstance.title = ''\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n    fixture.detectChanges()\n\n    expect(editorComponent.required()).toBeTruthy()\n    expect(editorElement.className).toMatch('ng-invalid')\n\n    fixture.componentInstance.title = '1'\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.detectChanges()\n    expect(editorElement.className).toMatch('ng-valid')\n\n    fixture.componentInstance.title = '<img src=\"test.jpg\">'\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.detectChanges()\n    expect(editorElement.className).toMatch('ng-valid')\n  })\n\n  it('should add custom toolbar', async () => {\n    // get editor component\n    const toolbarFixture = TestBed.createComponent(TestToolbarComponent) as ComponentFixture<TestToolbarComponent>\n\n    toolbarFixture.detectChanges()\n    await toolbarFixture.whenStable()\n\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[0].attributes['above-quill-editor-toolbar']).toBeDefined()\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[1].attributes['quill-editor-toolbar']).toBeDefined()\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[2].attributes['below-quill-editor-toolbar']).toBeDefined()\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[3].attributes['quill-editor-element']).toBeDefined()\n\n    const editorComponent = toolbarFixture.debugElement.children[0].componentInstance\n    expect(editorComponent.required()).toBe(true)\n    expect(editorComponent.customToolbarPosition()).toEqual('top')\n  })\n\n  it('should add custom toolbar at the end', async () => {\n    // get editor component\n    const toolbarFixture = TestBed.createComponent(TestToolbarComponent) as ComponentFixture<TestToolbarComponent>\n    toolbarFixture.componentInstance.toolbarPosition = 'bottom'\n\n    toolbarFixture.detectChanges()\n    await toolbarFixture.whenStable()\n\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[0].attributes['quill-editor-element']).toBeDefined()\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[1].attributes['above-quill-editor-toolbar']).toBeDefined()\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[2].attributes['quill-editor-toolbar']).toBeDefined()\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[3].attributes['below-quill-editor-toolbar']).toBeDefined()\n\n    const editorComponent = toolbarFixture.debugElement.children[0].componentInstance\n    expect(editorComponent.customToolbarPosition()).toEqual('bottom')\n  })\n\n  it('should render custom link placeholder', async () => {\n    const linkFixture = TestBed.createComponent(CustomLinkPlaceholderTestComponent) as ComponentFixture<CustomLinkPlaceholderTestComponent>\n\n    linkFixture.detectChanges()\n    await linkFixture.whenStable()\n\n    const el = linkFixture.nativeElement.querySelector('input[data-link]')\n\n    expect(el.dataset.link).toBe('https://test.de')\n  })\n})\n\ndescribe('QuillEditor - base config', () => {\n  let fixture: ComponentFixture<TestComponent>\n  let registerSpy: jasmine.Spy\n  let importSpy: jasmine.Spy\n\n  beforeAll(() => {\n    importSpy = spyOn(Quill, 'import').and.callThrough()\n    registerSpy = spyOn(Quill, 'register').and.callThrough()\n  })\n\n  beforeEach(async () => {\n\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [FormsModule, QuillModule],\n      providers: QuillModule.forRoot({\n        customModules: [{\n          path: 'modules/custom',\n          implementation: CustomModule\n        }],\n        customOptions: [{\n          import: 'attributors/style/size',\n          whitelist: ['14']\n        }],\n        suppressGlobalRegisterWarning: true,\n        bounds: 'body',\n        debug: false,\n        format: 'object',\n        formats: ['bold'],\n        modules: {\n          toolbar: [\n            ['bold']\n          ]\n        },\n        placeholder: 'placeholder',\n        readOnly: true,\n        theme: 'snow',\n        trackChanges: 'all'\n      }).providers\n    }).compileComponents()\n\n    fixture = TestBed.createComponent(TestComponent)\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(registerSpy).toHaveBeenCalledWith('modules/custom', CustomModule, true)\n    expect(importSpy).toHaveBeenCalledWith('attributors/style/size')\n  })\n\n  it('renders editor with config',  async () => {\n\n    const editor = fixture.componentInstance.editor as Quill\n\n    expect(fixture.nativeElement.querySelector('.ql-toolbar').querySelectorAll('button').length).toBe(1)\n    expect(fixture.nativeElement.querySelector('.ql-toolbar').querySelector('button.ql-bold')).toBeDefined()\n\n    editor.updateContents([{\n      insert: 'content',\n      attributes: {\n        bold: true,\n        italic: true\n      }\n    }] as any, 'api')\n    fixture.detectChanges()\n\n    expect(JSON.stringify(fixture.componentInstance.title))\n      .toEqual(JSON.stringify({ ops: [{ attributes: { bold: true },\ninsert: 'content' }, { insert: '\\n' }] }))\n    expect(editor.root.dataset.placeholder).toEqual('placeholder')\n    expect(registerSpy).toHaveBeenCalledWith(\n      jasmine.objectContaining({ attrName: 'size',\nkeyName: 'font-size',\nscope: 5,\nwhitelist: ['14'] }), true, true\n    )\n\n    expect(fixture.componentInstance.editorComponent.quillEditor['options'].modules.toolbar)\n      .toEqual(jasmine.objectContaining({\n        container: [\n          ['bold']\n        ]\n      }))\n  })\n})\n\ndescribe('QuillEditor - customModules', () => {\n  let fixture: ComponentFixture<CustomModuleTestComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [FormsModule, QuillModule],\n      providers: QuillModule.forRoot().providers\n    }).compileComponents()\n  })\n\n  it('renders editor with config', async () => {\n    const spy = spyOn(Quill, 'register').and.callThrough()\n    fixture = TestBed.createComponent(CustomModuleTestComponent)\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(spy).toHaveBeenCalled()\n    expect(fixture.componentInstance.editor.quillEditor['options'].modules.custom).toBeDefined()\n  })\n})\n\ndescribe('QuillEditor - customModules (asynchronous)', () => {\n  let fixture: ComponentFixture<CustomAsynchronousModuleTestComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [FormsModule, QuillModule],\n      providers: QuillModule.forRoot().providers\n    }).compileComponents()\n  })\n\n  it('renders editor with config', async () => {\n    const spy = spyOn(Quill, 'register').and.callThrough()\n    fixture = TestBed.createComponent(CustomAsynchronousModuleTestComponent)\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(spy).toHaveBeenCalled()\n    expect(fixture.componentInstance.editor.quillEditor['options'].modules.custom).toBeDefined()\n  })\n})\n\ndescribe('QuillEditor - defaultEmptyValue', () => {\n  @Component({\n    imports: [QuillModule],\n    template: `\n      <quill-editor defaultEmptyValue=\"\"></quill-editor>\n  `\n  })\n  class DefaultEmptyValueTestComponent {\n    @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  }\n\n  let fixture: ComponentFixture<DefaultEmptyValueTestComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [QuillModule],\n      providers: QuillModule.forRoot().providers\n    }).compileComponents()\n  })\n\n  it('should change default empty value', async () => {\n    fixture = TestBed.createComponent(DefaultEmptyValueTestComponent)\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(fixture.componentInstance.editor.defaultEmptyValue).toBeDefined()\n  })\n})\n\ndescribe('QuillEditor - beforeRender', () => {\n  @Component({\n    changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/prefer-signals","severity":2,"message":"Use the `viewChild` function instead of the `ViewChild` decorator","line":1460,"column":5,"nodeType":"Decorator","messageId":"preferQuerySignals","endLine":1460,"endColumn":55}],"suppressedMessages":[],"errorCount":43,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Component, Renderer2, ViewChild } from '@angular/core'\nimport { ComponentFixture, fakeAsync, TestBed, tick } from '@angular/core/testing'\nimport { defer } from 'rxjs'\n\nimport { FormControl, FormsModule, ReactiveFormsModule } from '@angular/forms'\n\nimport { QuillEditorComponent } from './quill-editor.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nwindow.setTimeout = ((cb) => {\n  cb()\n  return 0\n}) as any\n\n// const Quill = require('quill')\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-test',\n  template: `\n<quill-editor\n  (onBlur)=\"blured = true\"\n  (onFocus)=\"focused = true\"\n  (onNativeBlur)=\"bluredNative = true\"\n  (onNativeFocus)=\"focusedNative = true\"\n  [(ngModel)]=\"title\"\n  [customOptions]=\"[{import: 'attributors/style/size', whitelist: ['14']}]\"\n  [styles]=\"style\"\n  [required]=\"required\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  [debounceTime]=\"debounceTime\"\n  [trimOnValidation]=\"trimOnValidation\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onEditorChanged)=\"handleEditorChange($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n  (onSelectionChanged)=\"handleSelection($event)\"\n></quill-editor>\n`\n})\nclass TestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editorComponent!: QuillEditorComponent\n  title: any = 'Hallo'\n  isReadOnly = false\n  required = false\n  minLength = 0\n  focused = false\n  blured = false\n  focusedNative = false\n  bluredNative = false\n  trimOnValidation = false\n  maxLength = 0\n  style: {\n    backgroundColor?: string\n    color?: string\n    height?: string\n  } | null = { height: '30px' }\n  editor: any\n  debounceTime: number\n\n  changed: any\n  changedEditor: any\n  selected: any\n\n  handleEditorCreated(event: any) {\n    this.editor = event\n  }\n\n  handleChange(event: any) {\n    this.changed = event\n  }\n\n  handleEditorChange(event: any) {\n    this.changedEditor = event\n  }\n\n  handleSelection(event: any) {\n    this.selected = event\n  }\n}\n\n@Component({\n  imports: [FormsModule, QuillModule],\n  selector: 'quill-toolbar-test',\n  template: `\n<quill-editor\n  [customToolbarPosition]=\"toolbarPosition\"\n  [(ngModel)]=\"title\" [required]=\"true\"\n  [minLength]=\"minLength\"\n  [maxLength]=\"maxLength\"\n  [readOnly]=\"isReadOnly\"\n  (onEditorCreated)=\"handleEditorCreated($event)\"\n  (onContentChanged)=\"handleChange($event)\"\n>\n  <div quill-editor-toolbar=\"true\">\n    <span class=\"ql-formats\">\n      <button class=\"ql-bold\" [title]=\"'Bold'\"></button>\n    </span>\n    <span class=\"ql-formats\">\n      <select class=\"ql-align\" [title]=\"'Aligment'\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n      <select class=\"ql-align\">\n        <option selected></option>\n        <option value=\"center\"></option>\n        <option value=\"right\"></option>\n        <option value=\"justify\"></option>\n      </select>\n    </span>\n  </div>\n  <div above-quill-editor-toolbar=\"true\">\n    <span>above</span>\n  </div>\n  <div below-quill-editor-toolbar=\"true\">\n    <span>below</span>\n  </div>\n</quill-editor>\n`\n})\nclass TestToolbarComponent {\n  title = 'Hallo'\n  isReadOnly = false\n  minLength = 0\n  maxLength = 0\n  toolbarPosition = 'top'\n\n  handleEditorCreated() {return}\n  handleChange() {return}\n}\n\n@Component({\n  imports: [QuillModule, ReactiveFormsModule],\n  selector: 'quill-reactive-test',\n  template: `\n    <quill-editor [formControl]='formControl' [minLength]='minLength'></quill-editor>\n`\n})\nclass ReactiveFormTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  formControl: FormControl = new FormControl('a')\n  minLength = 3\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"[{path: 'modules/custom', implementation: impl}]\"></quill-editor>\n`\n})\nclass CustomModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  impl = CustomModule\n}\n\n@Component({\n  imports: [QuillModule],\n  selector: 'quill-async-module-test',\n  template: `\n    <quill-editor [modules]=\"{custom: true}\" [customModules]=\"customModules\"></quill-editor>\n`\n})\nclass CustomAsynchronousModuleTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  customModules = [\n    {\n      path: 'modules/custom',\n      implementation: defer(() => Promise.resolve(CustomModule))\n    }\n  ]\n}\n\n@Component({\n  imports: [QuillModule, FormsModule],\n  selector: 'quill-link-placeholder-test',\n  template: `\n    <quill-editor [ngModel]=\"content\" [linkPlaceholder]=\"'https://test.de'\"></quill-editor>\n`\n})\nclass CustomLinkPlaceholderTestComponent {\n  @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  content = ''\n}\n\ndescribe('Basic QuillEditorComponent', () => {\n  let fixture: ComponentFixture<QuillEditorComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n\n      ],\n      providers: QuillModule.forRoot().providers\n    })\n    fixture = TestBed.createComponent(QuillEditorComponent)\n  })\n\n  it('ngOnDestroy - removes listeners', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const spy = spyOn(fixture.componentInstance.quillEditor, 'off').and.callThrough()\n\n    fixture.componentInstance.ngOnDestroy()\n\n    expect(spy).toHaveBeenCalledTimes(3)\n    const quillEditor: any = fixture.componentInstance.quillEditor\n    expect(quillEditor.emitter._events['editor-change'].length).toBe(4)\n    expect(quillEditor.emitter._events['selection-change']).toBeInstanceOf(Object)\n    expect(quillEditor.emitter._events['text-change']).toBeFalsy()\n  })\n\n  it('should render toolbar', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('div.ql-toolbar.ql-snow').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n  })\n\n  it('should render text div', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('div.ql-container.ql-snow').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n  })\n})\n\ndescribe('Formats', () => {\n  describe('object', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"object\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class ObjectComponent {\n      title = [{\n        insert: 'Hello'\n      }]\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<ObjectComponent>\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(ObjectComponent) as ComponentFixture<ObjectComponent>\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n    it('should be set object', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hello\\n' }] }))\n    })\n\n    it('should update text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.title = [{ insert: '1234' }]\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: '1234\\n' }] }))\n    })\n\n    it('should update model if editor text changes', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      component.editor.setContents([{ insert: '123' }], 'user')\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.title)).toEqual(JSON.stringify({ ops: [{ insert: '123\\n' }] }))\n    })\n  })\n\n  describe('html', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"html\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class HTMLComponent {\n      title = '<p>Hallo<ol><li>ordered</li></ol><ul><li>unordered</li></ul></p>'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" [sanitize]=\"true\" format=\"html\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class HTMLSanitizeComponent {\n      title = '<p>Hallo <img src=\"wroooong.jpg\" onerror=\"window.alert(\\'sanitize me\\')\"></p>'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<HTMLComponent>\n    let component: HTMLComponent\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule.forRoot()]\n      })\n\n      fixture = TestBed.createComponent(HTMLComponent) as ComponentFixture<HTMLComponent>\n      component = fixture.componentInstance\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n    it('should be set html', async () => {\n      expect(component.editor.getText().trim()).toEqual(`Hallo\nordered\nunordered`)\n    })\n\n    it('should update html', async () => {\n      component.title = '<p>test</p>'\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.editor.getText().trim()).toEqual('test')\n    })\n\n    it('should update model if editor html changes', async () => {\n      expect(component.title.trim()).toEqual('<p>Hallo<ol><li>ordered</li></ol><ul><li>unordered</li></ul></p>')\n      component.editor.setText('1234', 'user')\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.title.trim()).toEqual('<p>1234</p>')\n    })\n\n    it('should sanitize html', async () => {\n      const sanfixture = TestBed.createComponent(HTMLSanitizeComponent) as ComponentFixture<HTMLSanitizeComponent>\n      sanfixture.detectChanges()\n\n      await sanfixture.whenStable()\n      const incomponent = sanfixture.componentInstance\n\n      expect(JSON.stringify(incomponent.editor.getContents()))\n      .toEqual(JSON.stringify({ ops: [{ insert: 'Hallo ' }, { insert: { image: 'wroooong.jpg' } }, { insert: '\\n' }] }))\n\n      incomponent.title = '<p><img src=\"xxxx\" onerror=\"window.alert()\"></p>'\n      sanfixture.detectChanges()\n\n      await sanfixture.whenStable()\n      expect(JSON.stringify(incomponent.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: { image: 'xxxx' } }, { insert: '\\n' }] }))\n    })\n  })\n\n  describe('text', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"text\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class TextComponent {\n      title = 'Hallo'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<TextComponent>\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(TextComponent) as ComponentFixture<TextComponent>\n      fixture.detectChanges()\n    })\n    it('should be set text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      expect(component.editor.getText().trim()).toEqual('Hallo')\n    })\n\n    it('should update text', async () => {\n      const component = fixture.componentInstance\n      component.title = 'test'\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(component.editor.getText().trim()).toEqual('test')\n    })\n\n    it('should update model if editor text changes', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.editor.setText('123', 'user')\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.title.trim()).toEqual('123')\n    })\n\n    it('should not update model if editor content changed by api', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.editor.setText('123')\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(component.title.trim()).toEqual('Hallo')\n    })\n  })\n\n  describe('json', () => {\n    @Component({\n      imports: [QuillModule, FormsModule],\n      selector: 'json-valid',\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"json\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class JSONComponent {\n      title = JSON.stringify([{\n        insert: 'Hallo'\n      }])\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    @Component({\n      imports: [QuillModule, FormsModule],\n      selector: 'quill-json-invalid',\n      template: `\n    <quill-editor [(ngModel)]=\"title\" format=\"json\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n    `\n    })\n    class JSONInvalidComponent {\n      title = JSON.stringify([{\n        insert: 'Hallo'\n      }]) + '{'\n      editor: any\n\n      handleEditorCreated(event: any) {\n        this.editor = event\n      }\n    }\n\n    let fixture: ComponentFixture<JSONComponent>\n    let component: JSONComponent\n\n    beforeEach(async () => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule.forRoot()]\n      })\n\n      fixture = TestBed.createComponent(JSONComponent) as ComponentFixture<JSONComponent>\n      component = fixture.componentInstance\n      fixture.detectChanges()\n      await fixture.whenStable()\n    })\n\n    it('should set json string', async () => {\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hallo\\n' }] }))\n    })\n\n    it('should update json string', async () => {\n      component.title = JSON.stringify([{\n        insert: 'Hallo 123'\n      }])\n      fixture.detectChanges()\n      await fixture.whenStable()\n      expect(JSON.stringify(component.editor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hallo 123\\n' }] }))\n    })\n\n    it('should update model if editor changes', async () => {\n      component.editor.setContents([{\n        insert: 'Hallo 123'\n      }], 'user')\n      fixture.detectChanges()\n      await fixture.whenStable()\n\n      expect(component.title).toEqual(JSON.stringify({ ops: [{ insert: 'Hallo 123\\n' }] }))\n    })\n\n    it('should set as text if invalid JSON', async () => {\n      const infixture = TestBed.createComponent(JSONInvalidComponent) as ComponentFixture<JSONInvalidComponent>\n      infixture.detectChanges()\n      await infixture.whenStable()\n      const incomponent = infixture.componentInstance\n      expect(incomponent.editor.getText().trim()).toEqual(JSON.stringify([{\n        insert: 'Hallo'\n      }]) + '{')\n\n      incomponent.title = JSON.stringify([{\n        insert: 'Hallo 1234'\n      }]) + '{'\n      infixture.detectChanges()\n      await infixture.whenStable()\n      expect(incomponent.editor.getText().trim()).toEqual(JSON.stringify([{\n        insert: 'Hallo 1234'\n      }]) + '{')\n    })\n  })\n})\n\ndescribe('Dynamic styles', () => {\n  @Component({\n    imports: [QuillModule, FormsModule],\n    template: `\n  <quill-editor\n    [bounds]=\"'self'\"\n    [(ngModel)]=\"title\"\n    format=\"text\"\n    [styles]=\"style\"\n    (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n  `\n  })\n  class StylingComponent {\n    title = 'Hallo'\n    style = {\n      backgroundColor: 'red'\n    }\n    editor: any\n\n    handleEditorCreated(event: any) {\n      this.editor = event\n    }\n  }\n\n  let fixture: ComponentFixture<StylingComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [FormsModule, QuillModule],\n      providers: QuillModule.forRoot().providers\n    })\n\n    fixture = TestBed.createComponent(StylingComponent) as ComponentFixture<StylingComponent>\n    fixture.detectChanges()\n  })\n\n  it('set inital styles', async () => {\n    const component = fixture.componentInstance\n    await fixture.whenStable()\n    expect(component.editor.container.style.backgroundColor).toEqual('red')\n  })\n\n  it('set style', async () => {\n    const component = fixture.componentInstance\n    await fixture.whenStable()\n    component.style = {\n      backgroundColor: 'gray'\n    }\n    fixture.detectChanges()\n    await fixture.whenStable()\n    expect(component.editor.container.style.backgroundColor).toEqual('gray')\n  })\n})\n\ndescribe('Dynamic classes', () => {\n  @Component({\n    imports: [QuillModule, FormsModule],\n    template: `\n  <quill-editor\n    [bounds]=\"'self'\"\n    [(ngModel)]=\"title\"\n    format=\"text\"\n    [classes]=\"classes\"\n    (onEditorCreated)=\"handleEditorCreated($event)\"></quill-editor>\n  `\n  })\n  class ClassesComponent {\n    title = 'Hallo'\n    classes = 'test-class1 test-class2'\n    editor: any\n    constructor(public renderer2: Renderer2) {\n    }\n    handleEditorCreated(event: any) {\n      this.editor = event\n    }\n  }\n\n  let fixture: ComponentFixture<ClassesComponent>\n\n  beforeEach(async () => {\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [FormsModule, QuillModule.forRoot()]\n    })\n\n    fixture = TestBed.createComponent(ClassesComponent) as ComponentFixture<ClassesComponent>\n    fixture.detectChanges()\n    await fixture.whenStable()\n  })\n\n  it('should set initial classes', async () => {\n    const component = fixture.componentInstance\n    expect(component.editor.container.classList.contains('test-class1')).toBe(true)\n    expect(component.editor.container.classList.contains('test-class2')).toBe(true)\n  })\n\n  it('should set class', async () => {\n    const component = fixture.componentInstance\n\n    component.classes = 'test-class2 test-class3'\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(component.editor.container.classList.contains('test-class1')).toBe(false)\n    expect(component.editor.container.classList.contains('test-class2')).toBe(true)\n    expect(component.editor.container.classList.contains('test-class3')).toBe(true)\n  })\n})\n\ndescribe('class normalization function', () => {\n  it('should trim white space', () => {\n    const classList = QuillEditorComponent.normalizeClassNames('test-class  ')\n\n    expect(classList).toEqual(['test-class'])\n  })\n\n  it('should not return empty strings as class names', () => {\n    const classList = QuillEditorComponent.normalizeClassNames('test-class   test-class2')\n\n    expect(classList).toEqual(['test-class', 'test-class2'])\n  })\n})\n\ndescribe('Reactive forms integration', () => {\n  let fixture: ComponentFixture<ReactiveFormTestComponent>\n\n  beforeEach(async () => {\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [FormsModule, ReactiveFormsModule, QuillModule],\n      providers: QuillModule.forRoot().providers\n    })\n\n    fixture = TestBed.createComponent(ReactiveFormTestComponent) as ComponentFixture<ReactiveFormTestComponent>\n    fixture.detectChanges()\n    await fixture.whenStable()\n  })\n\n  it('should be disabled', () => {\n    const component = fixture.componentInstance\n    component.formControl.disable()\n    expect((component.editor.quillEditor as any).container.classList.contains('ql-disabled')).toBeTruthy()\n  })\n\n  it('has \"disabled\" attribute', () => {\n    const component = fixture.componentInstance\n    component.formControl.disable()\n    expect(fixture.nativeElement.children[0].attributes.disabled).toBeDefined()\n  })\n\n  it('should re-enable', () => {\n    const component = fixture.componentInstance\n    component.formControl.disable()\n\n    component.formControl.enable()\n\n    expect((component.editor.quillEditor as any).container.classList.contains('ql-disabled')).toBeFalsy()\n    expect(fixture.nativeElement.children[0].attributes.disabled).not.toBeDefined()\n  })\n\n  it('should leave form pristine when content of editor changed programmatically', async () => {\n    const values: (string | null)[] = []\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.componentInstance.formControl.valueChanges.subscribe((value: string) => values.push(value))\n    fixture.componentInstance.formControl.patchValue('1234')\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(fixture.nativeElement.querySelector('div.ql-editor').textContent).toEqual('1234')\n    expect(fixture.componentInstance.formControl.value).toEqual('1234')\n    expect(fixture.componentInstance.formControl.pristine).toBeTruthy()\n    expect(values).toEqual(['1234'])\n  })\n\n  it('should mark form dirty when content of editor changed by user', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    fixture.componentInstance.editor.quillEditor.setText('1234', 'user')\n    fixture.detectChanges()\n    await fixture.whenStable()\n    expect(fixture.nativeElement.querySelector('div.ql-editor').textContent).toEqual('1234')\n    expect(fixture.componentInstance.formControl.dirty).toBeTruthy()\n    expect(fixture.componentInstance.formControl.value).toEqual('<p>1234</p>')\n  })\n\n  it('should validate initial content and do not mark it as invalid', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(fixture.nativeElement.querySelector('div.ql-editor').textContent).toEqual('a')\n    expect(fixture.componentInstance.formControl.pristine).toBeTruthy()\n    expect(fixture.componentInstance.formControl.value).toEqual('a')\n    expect(fixture.componentInstance.formControl.invalid).toBeTruthy()\n  })\n\n  it('should write the defaultEmptyValue when editor is emptied', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.componentInstance.editor.quillEditor.setText('', 'user')\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    // default empty value is null\n    expect(fixture.componentInstance.formControl.value).toEqual(null)\n  })\n})\n\ndescribe('Advanced QuillEditorComponent', () => {\n  let fixture: ComponentFixture<TestComponent>\n\n  beforeEach(async () => {\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [FormsModule, QuillModule],\n      providers: QuillModule.forRoot().providers\n    }).compileComponents()\n\n    fixture = TestBed.createComponent(TestComponent) as ComponentFixture<TestComponent>\n\n    spyOn(Quill, 'import').and.callThrough()\n    spyOn(Quill, 'register').and.callThrough()\n  })\n\n  it('should set editor settings', async () => {\n    const editorElem = fixture.debugElement.children[0]\n    const editorCmp = fixture.debugElement.children[0].componentInstance\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(editorCmp.readOnly()).toBe(false)\n\n    fixture.componentInstance.isReadOnly = true\n\n    expect(Quill.import).toHaveBeenCalledWith('attributors/style/size')\n    expect(Quill.register).toHaveBeenCalled()\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(editorCmp.readOnly()).toBe(true)\n    expect(editorElem.nativeElement.querySelectorAll('div.ql-container.ql-disabled').length).toBe(1)\n    expect(editorElem.nativeElement.querySelector('div[quill-editor-element]').style.height).toBe('30px')\n  })\n\n  it('should update editor style', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const editorElem = fixture.debugElement.children[0]\n\n    fixture.componentInstance.style = { backgroundColor: 'red' }\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(editorElem.nativeElement.querySelector('div[quill-editor-element]').style.backgroundColor).toBe('red')\n    expect(editorElem.nativeElement.querySelector('div[quill-editor-element]').style.height).toEqual('')\n  })\n\n  it('should update editor style to null and readd styling', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const editorElem = fixture.debugElement.children[0]\n\n    fixture.componentInstance.style = null\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.componentInstance.style = { color: 'red' }\n    expect(editorElem.nativeElement.querySelector('div[quill-editor-element]').style.height).toEqual('')\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(editorElem.nativeElement.querySelector('div[quill-editor-element]').style.color).toBe('red')\n  })\n\n  it('should not update editor style if nothing changed', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const editorElem = fixture.debugElement.children[0]\n\n    fixture.componentInstance.isReadOnly = true\n    fixture.detectChanges()\n\n    await fixture.whenStable\n    expect(editorElem.nativeElement.querySelector('div[quill-editor-element]').style.height).toEqual('30px')\n  })\n\n  it('should set touched state correctly', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n    const editorFixture = fixture.debugElement.children[0]\n\n    editorFixture.componentInstance.quillEditor.setSelection(0, 5)\n    fixture.detectChanges()\n    await fixture.whenStable()\n    editorFixture.componentInstance.quillEditor.setSelection(null)\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(editorFixture.nativeElement.className).toMatch('ng-untouched')\n\n    editorFixture.componentInstance.quillEditor.setSelection(0, 5, 'user')\n    fixture.detectChanges()\n    await fixture.whenStable()\n    editorFixture.componentInstance.quillEditor.setSelection(null, 'user')\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(editorFixture.nativeElement.className).toMatch('ng-touched')\n  })\n\n  it('should set required state correctly', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    // get editor component\n    const editorElement = fixture.debugElement.children[0].nativeElement\n\n    fixture.componentInstance.title = ''\n    fixture.detectChanges()\n    await fixture.whenStable()\n    expect(editorElement.className).toMatch('ng-valid')\n  })\n\n  it('should emit onEditorCreated with editor instance',  async () => {\n    fixture.componentInstance.editorComponent.onValidatorChanged = () => { return }\n\n    spyOn(fixture.componentInstance, 'handleEditorCreated')\n\n    fixture.detectChanges()\n    spyOn(fixture.componentInstance.editorComponent, 'onValidatorChanged')\n\n    await fixture.whenStable()\n\n    const editorComponent = fixture.debugElement.children[0].componentInstance\n    expect(fixture.componentInstance.handleEditorCreated).toHaveBeenCalledWith(editorComponent.quillEditor)\n    expect(fixture.componentInstance.editorComponent.onValidatorChanged).toHaveBeenCalled()\n  })\n\n  it('should emit onContentChanged when content of editor changed + editor changed', async () => {\n    spyOn(fixture.componentInstance, 'handleChange').and.callThrough()\n    spyOn(fixture.componentInstance, 'handleEditorChange').and.callThrough()\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const editorFixture = fixture.debugElement.children[0]\n    editorFixture.componentInstance.quillEditor.setText('1234', 'user')\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(fixture.componentInstance.handleChange).toHaveBeenCalledWith(fixture.componentInstance.changed)\n    expect(fixture.componentInstance.handleEditorChange).toHaveBeenCalledWith(fixture.componentInstance.changedEditor)\n  })\n\n  it('should emit onContentChanged with a delay after content of editor changed + editor changed', fakeAsync(() => {\n    fixture.componentInstance.debounceTime = 400\n    spyOn(fixture.componentInstance, 'handleChange').and.callThrough()\n    spyOn(fixture.componentInstance, 'handleEditorChange').and.callThrough()\n\n    fixture.detectChanges()\n    tick()\n\n    const editorFixture = fixture.debugElement.children[0]\n    editorFixture.componentInstance.quillEditor.setText('foo', 'bar')\n    fixture.detectChanges()\n    tick()\n\n    expect(fixture.componentInstance.handleChange).not.toHaveBeenCalled()\n    expect(fixture.componentInstance.handleEditorChange).not.toHaveBeenCalled()\n\n    tick(400)\n\n    expect(fixture.componentInstance.handleChange).toHaveBeenCalledWith(fixture.componentInstance.changed)\n    expect(fixture.componentInstance.handleEditorChange).toHaveBeenCalledWith(fixture.componentInstance.changedEditor)\n  }))\n\n  it('should emit onContentChanged once after editor content changed twice within debounce interval + editor changed',\n    fakeAsync(() => {\n      fixture.componentInstance.debounceTime = 400\n      spyOn(fixture.componentInstance, 'handleChange').and.callThrough()\n      spyOn(fixture.componentInstance, 'handleEditorChange').and.callThrough()\n\n      fixture.detectChanges()\n      tick()\n\n      const editorFixture = fixture.debugElement.children[0]\n      editorFixture.componentInstance.quillEditor.setText('foo', 'bar')\n      fixture.detectChanges()\n      tick(200)\n\n      editorFixture.componentInstance.quillEditor.setText('baz', 'bar')\n      fixture.detectChanges()\n      tick(400)\n\n      expect(fixture.componentInstance.handleChange).toHaveBeenCalledTimes(1)\n      expect(fixture.componentInstance.handleChange).toHaveBeenCalledWith(fixture.componentInstance.changed)\n      expect(fixture.componentInstance.handleEditorChange).toHaveBeenCalledTimes(1)\n      expect(fixture.componentInstance.handleEditorChange).toHaveBeenCalledWith(fixture.componentInstance.changedEditor)\n    })\n  )\n\n  it(`should adjust the debounce time if the value of 'debounceTime' changes`, fakeAsync(() => {\n    fixture.componentInstance.debounceTime = 400\n    const handleChangeSpy = spyOn(fixture.componentInstance, 'handleChange').and.callThrough()\n    const handleEditorChangeSpy = spyOn(fixture.componentInstance, 'handleEditorChange').and.callThrough()\n\n    fixture.detectChanges()\n    tick()\n\n    const editorFixture = fixture.debugElement.children[0]\n    editorFixture.componentInstance.quillEditor.setText('foo', 'bar')\n    fixture.detectChanges()\n    tick()\n\n    expect(fixture.componentInstance.handleChange).not.toHaveBeenCalled()\n    expect(fixture.componentInstance.handleEditorChange).not.toHaveBeenCalled()\n\n    tick(400)\n\n    expect(fixture.componentInstance.handleChange).toHaveBeenCalledWith(fixture.componentInstance.changed)\n    expect(fixture.componentInstance.handleEditorChange).toHaveBeenCalledWith(fixture.componentInstance.changedEditor)\n    handleChangeSpy.calls.reset()\n    handleEditorChangeSpy.calls.reset()\n\n    fixture.componentInstance.debounceTime = 200\n    fixture.detectChanges()\n    tick()\n\n    editorFixture.componentInstance.quillEditor.setText('baz', 'foo')\n    fixture.detectChanges()\n    tick()\n\n    expect(fixture.componentInstance.handleChange).not.toHaveBeenCalled()\n    expect(fixture.componentInstance.handleEditorChange).not.toHaveBeenCalled()\n\n    tick(200)\n\n    expect(fixture.componentInstance.handleChange).toHaveBeenCalledWith(fixture.componentInstance.changed)\n    expect(fixture.componentInstance.handleEditorChange).toHaveBeenCalledWith(fixture.componentInstance.changedEditor)\n  }))\n\n  it('should unsubscribe from Quill events on destroy', async () => {\n    fixture.componentInstance.debounceTime = 400\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const editorFixture = fixture.debugElement.children[0]\n    const quillOffSpy = spyOn(editorFixture.componentInstance.quillEditor, 'off').and.callThrough()\n    editorFixture.componentInstance.quillEditor.setText('baz', 'bar')\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.destroy()\n\n    expect(quillOffSpy).toHaveBeenCalledTimes(3)\n    expect(editorFixture.componentInstance.subscription).toEqual(null)\n    expect(quillOffSpy).toHaveBeenCalledWith('text-change', jasmine.any(Function))\n    expect(quillOffSpy).toHaveBeenCalledWith('editor-change', jasmine.any(Function))\n    expect(quillOffSpy).toHaveBeenCalledWith('selection-change', jasmine.any(Function))\n  })\n\n  it('should emit onSelectionChanged when selection changed + editor changed', async () => {\n    spyOn(fixture.componentInstance, 'handleSelection').and.callThrough()\n    spyOn(fixture.componentInstance, 'handleEditorChange').and.callThrough()\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const editorFixture = fixture.debugElement.children[0]\n\n    editorFixture.componentInstance.quillEditor.focus()\n    editorFixture.componentInstance.quillEditor.blur()\n    fixture.detectChanges()\n\n    expect(fixture.componentInstance.handleSelection).toHaveBeenCalledWith(fixture.componentInstance.selected)\n    expect(fixture.componentInstance.handleEditorChange).toHaveBeenCalledWith(fixture.componentInstance.changedEditor)\n  })\n\n  it('should emit onFocus when focused', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const editorFixture = fixture.debugElement.children[0]\n\n    editorFixture.componentInstance.quillEditor.focus()\n    fixture.detectChanges()\n\n    expect(fixture.componentInstance.focused).toBe(true)\n  })\n\n  it('should emit onNativeFocus when scroll container receives focus', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const editorFixture = fixture.debugElement.children[0]\n\n    editorFixture.componentInstance.quillEditor.scroll.domNode.focus()\n    fixture.detectChanges()\n\n    expect(fixture.componentInstance.focusedNative).toBe(true)\n  })\n\n  it('should emit onBlur when blured', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const editorFixture = fixture.debugElement.children[0]\n\n    editorFixture.componentInstance.quillEditor.focus()\n    editorFixture.componentInstance.quillEditor.blur()\n    fixture.detectChanges()\n\n    expect(fixture.componentInstance.blured).toBe(true)\n  })\n\n  it('should emit onNativeBlur when scroll container receives blur', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const editorFixture = fixture.debugElement.children[0]\n\n    editorFixture.componentInstance.quillEditor.scroll.domNode.focus()\n    editorFixture.componentInstance.quillEditor.scroll.domNode.blur()\n    fixture.detectChanges()\n\n    expect(fixture.componentInstance.bluredNative).toBe(true)\n  })\n\n  it('should validate minlength', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    // get editor component\n    const editorComponent = fixture.debugElement.children[0].componentInstance\n    const editorElement = fixture.debugElement.children[0].nativeElement\n\n    expect(editorElement.className).toMatch('ng-valid')\n\n    // set minlength\n    fixture.componentInstance.minLength = 8\n    fixture.detectChanges()\n    await fixture.whenStable()\n    expect(editorComponent.minLength()).toBe(8)\n\n    fixture.componentInstance.title = 'Hallo1'\n    fixture.detectChanges()\n    await fixture.whenStable()\n    fixture.detectChanges()\n    await fixture.whenStable()\n    expect(editorElement.className).toMatch('ng-invalid')\n  })\n\n  it('should set valid minlength if model is empty', async () => {\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    // get editor component\n    const editorComponent = fixture.debugElement.children[0].componentInstance\n    const editorElement = fixture.debugElement.children[0].nativeElement\n\n    // set min length\n    fixture.componentInstance.minLength = 2\n    // change text\n    editorComponent.quillEditor.setText('', 'user')\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.detectChanges()\n    expect(editorElement.className).toMatch('ng-valid')\n  })\n\n  it('should validate maxlength', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    // get editor component\n    const editorComponent = fixture.debugElement.children[0].componentInstance\n    const editorElement = fixture.debugElement.children[0].nativeElement\n\n    expect(fixture.debugElement.children[0].nativeElement.className).toMatch('ng-valid')\n\n    fixture.componentInstance.maxLength = 3\n    fixture.componentInstance.title = '1234'\n    fixture.detectChanges()\n\n    await fixture.whenStable()\n    fixture.detectChanges()\n\n    expect(editorComponent.maxLength()).toBe(3)\n    expect(editorElement.className).toMatch('ng-invalid')\n  })\n\n  it('should validate maxlength and minlength', async () => {\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    // get editor component\n    const editorElement = fixture.debugElement.children[0].nativeElement\n\n    expect(fixture.debugElement.children[0].nativeElement.className).toMatch('ng-valid')\n\n    fixture.componentInstance.minLength = 3\n    fixture.componentInstance.maxLength = 5\n    fixture.componentInstance.title = '123456'\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.detectChanges()\n    expect(editorElement.className).toMatch('ng-invalid')\n\n    fixture.componentInstance.title = '1234'\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n    fixture.detectChanges()\n    expect(editorElement.className).toMatch('ng-valid')\n  })\n\n  it('should validate maxlength and minlength with trimming white spaces', async () => {\n    // get editor component\n    const editorElement = fixture.debugElement.children[0].nativeElement\n    fixture.componentInstance.trimOnValidation = true\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(fixture.debugElement.children[0].nativeElement.className).toMatch('ng-valid')\n\n    fixture.componentInstance.minLength = 3\n    fixture.componentInstance.maxLength = 5\n    fixture.componentInstance.title = '  1234567  '\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.detectChanges()\n    expect(editorElement.className).toMatch('ng-invalid')\n\n    fixture.componentInstance.title = '  1234  '\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n    fixture.detectChanges()\n\n    expect(editorElement.className).toMatch('ng-valid')\n  })\n\n  it('should validate required', async () => {\n    // get editor component\n    const editorElement = fixture.debugElement.children[0].nativeElement\n    const editorComponent = fixture.debugElement.children[0].componentInstance\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(fixture.debugElement.children[0].nativeElement.className).toMatch('ng-valid')\n    expect(editorComponent.required()).toBeFalsy()\n\n    fixture.componentInstance.required = true\n    fixture.componentInstance.title = ''\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n    fixture.detectChanges()\n\n    expect(editorComponent.required()).toBeTruthy()\n    expect(editorElement.className).toMatch('ng-invalid')\n\n    fixture.componentInstance.title = '1'\n\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.detectChanges()\n    expect(editorElement.className).toMatch('ng-valid')\n\n    fixture.componentInstance.title = '<img src=\"test.jpg\">'\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    fixture.detectChanges()\n    expect(editorElement.className).toMatch('ng-valid')\n  })\n\n  it('should add custom toolbar', async () => {\n    // get editor component\n    const toolbarFixture = TestBed.createComponent(TestToolbarComponent) as ComponentFixture<TestToolbarComponent>\n\n    toolbarFixture.detectChanges()\n    await toolbarFixture.whenStable()\n\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[0].attributes['above-quill-editor-toolbar']).toBeDefined()\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[1].attributes['quill-editor-toolbar']).toBeDefined()\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[2].attributes['below-quill-editor-toolbar']).toBeDefined()\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[3].attributes['quill-editor-element']).toBeDefined()\n\n    const editorComponent = toolbarFixture.debugElement.children[0].componentInstance\n    expect(editorComponent.required()).toBe(true)\n    expect(editorComponent.customToolbarPosition()).toEqual('top')\n  })\n\n  it('should add custom toolbar at the end', async () => {\n    // get editor component\n    const toolbarFixture = TestBed.createComponent(TestToolbarComponent) as ComponentFixture<TestToolbarComponent>\n    toolbarFixture.componentInstance.toolbarPosition = 'bottom'\n\n    toolbarFixture.detectChanges()\n    await toolbarFixture.whenStable()\n\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[0].attributes['quill-editor-element']).toBeDefined()\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[1].attributes['above-quill-editor-toolbar']).toBeDefined()\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[2].attributes['quill-editor-toolbar']).toBeDefined()\n    expect(toolbarFixture.debugElement.children[0].nativeElement.children[3].attributes['below-quill-editor-toolbar']).toBeDefined()\n\n    const editorComponent = toolbarFixture.debugElement.children[0].componentInstance\n    expect(editorComponent.customToolbarPosition()).toEqual('bottom')\n  })\n\n  it('should render custom link placeholder', async () => {\n    const linkFixture = TestBed.createComponent(CustomLinkPlaceholderTestComponent) as ComponentFixture<CustomLinkPlaceholderTestComponent>\n\n    linkFixture.detectChanges()\n    await linkFixture.whenStable()\n\n    const el = linkFixture.nativeElement.querySelector('input[data-link]')\n\n    expect(el.dataset.link).toBe('https://test.de')\n  })\n})\n\ndescribe('QuillEditor - base config', () => {\n  let fixture: ComponentFixture<TestComponent>\n  let registerSpy: jasmine.Spy\n  let importSpy: jasmine.Spy\n\n  beforeAll(() => {\n    importSpy = spyOn(Quill, 'import').and.callThrough()\n    registerSpy = spyOn(Quill, 'register').and.callThrough()\n  })\n\n  beforeEach(async () => {\n\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [FormsModule, QuillModule],\n      providers: QuillModule.forRoot({\n        customModules: [{\n          path: 'modules/custom',\n          implementation: CustomModule\n        }],\n        customOptions: [{\n          import: 'attributors/style/size',\n          whitelist: ['14']\n        }],\n        suppressGlobalRegisterWarning: true,\n        bounds: 'body',\n        debug: false,\n        format: 'object',\n        formats: ['bold'],\n        modules: {\n          toolbar: [\n            ['bold']\n          ]\n        },\n        placeholder: 'placeholder',\n        readOnly: true,\n        theme: 'snow',\n        trackChanges: 'all'\n      }).providers\n    }).compileComponents()\n\n    fixture = TestBed.createComponent(TestComponent)\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(registerSpy).toHaveBeenCalledWith('modules/custom', CustomModule, true)\n    expect(importSpy).toHaveBeenCalledWith('attributors/style/size')\n  })\n\n  it('renders editor with config',  async () => {\n\n    const editor = fixture.componentInstance.editor as Quill\n\n    expect(fixture.nativeElement.querySelector('.ql-toolbar').querySelectorAll('button').length).toBe(1)\n    expect(fixture.nativeElement.querySelector('.ql-toolbar').querySelector('button.ql-bold')).toBeDefined()\n\n    editor.updateContents([{\n      insert: 'content',\n      attributes: {\n        bold: true,\n        italic: true\n      }\n    }] as any, 'api')\n    fixture.detectChanges()\n\n    expect(JSON.stringify(fixture.componentInstance.title))\n      .toEqual(JSON.stringify({ ops: [{ attributes: { bold: true },\ninsert: 'content' }, { insert: '\\n' }] }))\n    expect(editor.root.dataset.placeholder).toEqual('placeholder')\n    expect(registerSpy).toHaveBeenCalledWith(\n      jasmine.objectContaining({ attrName: 'size',\nkeyName: 'font-size',\nscope: 5,\nwhitelist: ['14'] }), true, true\n    )\n\n    expect(fixture.componentInstance.editorComponent.quillEditor['options'].modules.toolbar)\n      .toEqual(jasmine.objectContaining({\n        container: [\n          ['bold']\n        ]\n      }))\n  })\n})\n\ndescribe('QuillEditor - customModules', () => {\n  let fixture: ComponentFixture<CustomModuleTestComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [FormsModule, QuillModule],\n      providers: QuillModule.forRoot().providers\n    }).compileComponents()\n  })\n\n  it('renders editor with config', async () => {\n    const spy = spyOn(Quill, 'register').and.callThrough()\n    fixture = TestBed.createComponent(CustomModuleTestComponent)\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(spy).toHaveBeenCalled()\n    expect(fixture.componentInstance.editor.quillEditor['options'].modules.custom).toBeDefined()\n  })\n})\n\ndescribe('QuillEditor - customModules (asynchronous)', () => {\n  let fixture: ComponentFixture<CustomAsynchronousModuleTestComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [FormsModule, QuillModule],\n      providers: QuillModule.forRoot().providers\n    }).compileComponents()\n  })\n\n  it('renders editor with config', async () => {\n    const spy = spyOn(Quill, 'register').and.callThrough()\n    fixture = TestBed.createComponent(CustomAsynchronousModuleTestComponent)\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(spy).toHaveBeenCalled()\n    expect(fixture.componentInstance.editor.quillEditor['options'].modules.custom).toBeDefined()\n  })\n})\n\ndescribe('QuillEditor - defaultEmptyValue', () => {\n  @Component({\n    imports: [QuillModule],\n    template: `\n      <quill-editor defaultEmptyValue=\"\"></quill-editor>\n  `\n  })\n  class DefaultEmptyValueTestComponent {\n    @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n  }\n\n  let fixture: ComponentFixture<DefaultEmptyValueTestComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [QuillModule],\n      providers: QuillModule.forRoot().providers\n    }).compileComponents()\n  })\n\n  it('should change default empty value', async () => {\n    fixture = TestBed.createComponent(DefaultEmptyValueTestComponent)\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(fixture.componentInstance.editor.defaultEmptyValue).toBeDefined()\n  })\n})\n\ndescribe('QuillEditor - beforeRender', () => {\n  @Component({\n    imports: [QuillModule],\n    template: `\n      <quill-editor [beforeRender]=\"beforeRender\"></quill-editor>\n  `\n  })\n  class BeforeRenderTestComponent {\n    @ViewChild(QuillEditorComponent, { static: true }) editor!: QuillEditorComponent\n\n    beforeRender?: () => Promise<any>\n  }\n\n  let fixture: ComponentFixture<BeforeRenderTestComponent>\n\n  it('should call beforeRender provided on the config level', async () => {\n    const config = { beforeRender: () => Promise.resolve() }\n\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [QuillModule.forRoot(config)],\n    })\n\n    spyOn(config, 'beforeRender').and.callThrough()\n\n    fixture = TestBed.createComponent(BeforeRenderTestComponent)\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(config.beforeRender).toHaveBeenCalled()\n  })\n\n  it('should call beforeRender provided on the component level and should not call beforeRender on the config level', async () => {\n    const config = { beforeRender: () => Promise.resolve() }\n\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [QuillModule.forRoot(config)],\n    })\n\n    spyOn(config, 'beforeRender').and.callThrough()\n\n    fixture = TestBed.createComponent(BeforeRenderTestComponent)\n    fixture.componentInstance.beforeRender = () => Promise.resolve()\n    spyOn(fixture.componentInstance, 'beforeRender').and.callThrough()\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(config.beforeRender).not.toHaveBeenCalled()\n    expect(fixture.componentInstance.beforeRender).toHaveBeenCalled()\n  })\n})\n","usedDeprecatedRules":[]},{"filePath":"/home/migudel/Documents/GII/42C/TFG/develop/repos/ngx-quill/projects/ngx-quill/src/lib/quill-editor.component.ts","messages":[{"ruleId":"@angular-eslint/prefer-output-readonly","severity":2,"message":"Prefer to declare `@Output` as `readonly` since they are not supposed to be reassigned","line":125,"column":13,"nodeType":"Identifier","messageId":"preferOutputReadonly","endLine":125,"endColumn":28,"suggestions":[{"messageId":"suggestAddReadonlyModifier","fix":{"range":[3725,3725],"text":"readonly "},"desc":"Add `readonly` modifier"}]},{"ruleId":"@angular-eslint/prefer-output-readonly","severity":2,"message":"Prefer to declare `@Output` as `readonly` since they are not supposed to be reassigned","line":126,"column":13,"nodeType":"Identifier","messageId":"preferOutputReadonly","endLine":126,"endColumn":28,"suggestions":[{"messageId":"suggestAddReadonlyModifier","fix":{"range":[3785,3785],"text":"readonly "},"desc":"Add `readonly` modifier"}]},{"ruleId":"@angular-eslint/prefer-output-readonly","severity":2,"message":"Prefer to declare `@Output` as `readonly` since they are not supposed to be reassigned","line":127,"column":13,"nodeType":"Identifier","messageId":"preferOutputReadonly","endLine":127,"endColumn":29,"suggestions":[{"messageId":"suggestAddReadonlyModifier","fix":{"range":[3879,3879],"text":"readonly "},"desc":"Add `readonly` modifier"}]},{"ruleId":"@angular-eslint/prefer-output-readonly","severity":2,"message":"Prefer to declare `@Output` as `readonly` since they are not supposed to be reassigned","line":128,"column":13,"nodeType":"Identifier","messageId":"preferOutputReadonly","endLine":128,"endColumn":31,"suggestions":[{"messageId":"suggestAddReadonlyModifier","fix":{"range":[3944,3944],"text":"readonly "},"desc":"Add `readonly` modifier"}]},{"ruleId":"@angular-eslint/prefer-output-readonly","severity":2,"message":"Prefer to declare `@Output` as `readonly` since they are not supposed to be reassigned","line":129,"column":13,"nodeType":"Identifier","messageId":"preferOutputReadonly","endLine":129,"endColumn":20,"suggestions":[{"messageId":"suggestAddReadonlyModifier","fix":{"range":[4013,4013],"text":"readonly "},"desc":"Add `readonly` modifier"}]},{"ruleId":"@angular-eslint/prefer-output-readonly","severity":2,"message":"Prefer to declare `@Output` as `readonly` since they are not supposed to be reassigned","line":130,"column":13,"nodeType":"Identifier","messageId":"preferOutputReadonly","endLine":130,"endColumn":19,"suggestions":[{"messageId":"suggestAddReadonlyModifier","fix":{"range":[4061,4061],"text":"readonly "},"desc":"Add `readonly` modifier"}]},{"ruleId":"@angular-eslint/prefer-output-readonly","severity":2,"message":"Prefer to declare `@Output` as `readonly` since they are not supposed to be reassigned","line":131,"column":13,"nodeType":"Identifier","messageId":"preferOutputReadonly","endLine":131,"endColumn":26,"suggestions":[{"messageId":"suggestAddReadonlyModifier","fix":{"range":[4107,4107],"text":"readonly "},"desc":"Add `readonly` modifier"}]},{"ruleId":"@angular-eslint/prefer-output-readonly","severity":2,"message":"Prefer to declare `@Output` as `readonly` since they are not supposed to be reassigned","line":132,"column":13,"nodeType":"Identifier","messageId":"preferOutputReadonly","endLine":132,"endColumn":25,"suggestions":[{"messageId":"suggestAddReadonlyModifier","fix":{"range":[4161,4161],"text":"readonly "},"desc":"Add `readonly` modifier"}]},{"ruleId":"@angular-eslint/prefer-signals","severity":2,"message":"Properties declared using signals should be marked as `readonly` since they should not be reassigned","line":171,"column":3,"nodeType":"Identifier","messageId":"preferReadonlySignalProperties","endLine":171,"endColumn":14,"fix":{"range":[5265,5265],"text":"readonly "}},{"ruleId":"@angular-eslint/prefer-signals","severity":2,"message":"Properties declared using signals should be marked as `readonly` since they should not be reassigned","line":194,"column":3,"nodeType":"Identifier","messageId":"preferReadonlySignalProperties","endLine":194,"endColumn":14,"fix":{"range":[5962,5962],"text":"readonly "}},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":730,"column":1,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":765,"endColumn":3,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[537,22837],"text":", ChangeDetectionStrategy\n} from '@angular/core'\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop'\nimport { fromEvent, Subscription } from 'rxjs'\nimport { debounceTime, mergeMap } from 'rxjs/operators'\n\nimport { ControlValueAccessor, NG_VALIDATORS, NG_VALUE_ACCESSOR, Validator } from '@angular/forms'\n\nimport { CustomModule, CustomOption, defaultModules, QuillBeforeRender, QuillModules } from 'ngx-quill/config'\n\nimport type History from 'quill/modules/history'\nimport type Toolbar from 'quill/modules/toolbar'\nimport { getFormat, raf$ } from './helpers'\nimport { QuillService } from './quill.service'\n\nexport interface Range {\n  index: number\n  length: number\n}\n\nexport interface ContentChange {\n  content: DeltaType\n  delta: DeltaType\n  editor: QuillType\n  html: string | null\n  oldDelta: DeltaType\n  source: string\n  text: string\n}\n\nexport interface SelectionChange {\n  editor: QuillType\n  oldRange: Range | null\n  range: Range | null\n  source: string\n}\n\nexport interface Blur {\n  editor: QuillType\n  source: string\n}\n\nexport interface Focus {\n  editor: QuillType\n  source: string\n}\n\nexport type EditorChangeContent = ContentChange & { event: 'text-change' }\nexport type EditorChangeSelection = SelectionChange & { event: 'selection-change' }\n\n@Directive()\nexport abstract class QuillEditorBase implements AfterViewInit, ControlValueAccessor, OnChanges, OnInit, OnDestroy, Validator {\n  readonly format = input<'object' | 'html' | 'text' | 'json' | undefined>(\n    undefined\n  )\n  readonly theme = input<string | undefined>(undefined)\n  readonly modules = input<QuillModules | undefined>(undefined)\n  readonly debug = input<'warn' | 'log' | 'error' | false>(false)\n  readonly readOnly = input<boolean | undefined>(false)\n  readonly placeholder = input<string | undefined>(undefined)\n  readonly maxLength = input<number | undefined>(undefined)\n  readonly minLength = input<number | undefined>(undefined)\n  readonly required = input(false)\n  readonly formats = input<string[] | null | undefined>(undefined)\n  readonly customToolbarPosition = input<'top' | 'bottom'>('top')\n  readonly sanitize = input<boolean | undefined>(undefined)\n  readonly beforeRender = input<QuillBeforeRender>(undefined)\n  readonly styles = input<any>(null)\n  readonly registry = input<QuillOptions['registry']>(\n    undefined\n  )\n  readonly bounds = input<HTMLElement | string | undefined>(undefined)\n  readonly customOptions = input<CustomOption[]>([])\n  readonly customModules = input<CustomModule[]>([])\n  readonly trackChanges = input<'user' | 'all' | undefined>(undefined)\n  readonly classes = input<string | undefined>(undefined)\n  readonly trimOnValidation = input(false)\n  readonly linkPlaceholder = input<string | undefined>(undefined)\n  readonly compareValues = input(false)\n  readonly filterNull = input(false)\n  readonly debounceTime = input<number | undefined>(undefined)\n  /*\n  https://github.com/KillerCodeMonkey/ngx-quill/issues/1257 - fix null value set\n\n  provide default empty value\n  by default null\n\n  e.g. defaultEmptyValue=\"\" - empty string\n\n  <quill-editor\n    defaultEmptyValue=\"\"\n    formControlName=\"message\"\n  ></quill-editor>\n  */\n  readonly defaultEmptyValue = input<any>(null)\n\n  @Output() onEditorCreated = new EventEmitter<QuillType>()\n  @Output() onEditorChanged = new EventEmitter<EditorChangeContent | EditorChangeSelection>()\n  @Output() onContentChanged = new EventEmitter<ContentChange>()\n  @Output() onSelectionChanged = new EventEmitter<SelectionChange>()\n  @Output() onFocus = new EventEmitter<Focus>()\n  @Output() onBlur = new EventEmitter<Blur>()\n  @Output() onNativeFocus = new EventEmitter<Focus>()\n  @Output() onNativeBlur = new EventEmitter<Blur>()\n\n  quillEditor!: QuillType\n  editorElem!: HTMLElement\n  content: any\n  disabled = false // used to store initial value before ViewInit\n\n  readonly toolbarPosition = signal('top')\n\n  onModelChange: (modelValue?: any) => void\n  onModelTouched: () => void\n  onValidatorChanged: () => void\n\n  private subscription: Subscription | null = null\n  private quillSubscription: Subscription | null = null\n\n  private elementRef = inject(ElementRef)\n  private document = inject(DOCUMENT)\n\n  private cd = inject(ChangeDetectorRef)\n  private domSanitizer = inject(DomSanitizer)\n  private platformId = inject<string>(PLATFORM_ID)\n  private renderer = inject(Renderer2)\n  private zone = inject(NgZone)\n  private service = inject(QuillService)\n  private destroyRef = inject(DestroyRef)\n\n  static normalizeClassNames(classes: string): string[] {\n    const classList = classes.trim().split(' ')\n    return classList.reduce((prev: string[], cur: string) => {\n      const trimmed = cur.trim()\n      if (trimmed) {\n        prev.push(trimmed)\n      }\n\n      return prev\n    }, [])\n  }\n\n  valueGetter = input((quillEditor: QuillType): string | any => {\n    let html: string | null = quillEditor.getSemanticHTML()\n    if (this.isEmptyValue(html)) {\n      html = this.defaultEmptyValue()\n    }\n    let modelValue: string | DeltaType | null = html\n    const format = getFormat(this.format(), this.service.config.format)\n\n    if (format === 'text') {\n      modelValue = quillEditor.getText()\n    } else if (format === 'object') {\n      modelValue = quillEditor.getContents()\n    } else if (format === 'json') {\n      try {\n        modelValue = JSON.stringify(quillEditor.getContents())\n      } catch {\n        modelValue = quillEditor.getText()\n      }\n    }\n\n    return modelValue\n  })\n\n  valueSetter = input((quillEditor: QuillType, value: any): any => {\n    const format = getFormat(this.format(), this.service.config.format)\n    if (format === 'html') {\n      const sanitize = [true, false].includes(this.sanitize()) ? this.sanitize() : (this.service.config.sanitize || false)\n      if (sanitize) {\n        value = this.domSanitizer.sanitize(SecurityContext.HTML, value)\n      }\n      return quillEditor.clipboard.convert({ html: value })\n    } else if (format === 'json') {\n      try {\n        return JSON.parse(value)\n      } catch {\n        return [{ insert: value }]\n      }\n    }\n\n    return value\n  })\n\n  ngOnInit() {\n    this.toolbarPosition.set(this.customToolbarPosition())\n  }\n\n  ngAfterViewInit() {\n    if (isPlatformServer(this.platformId)) {\n      return\n    }\n\n    // The `quill-editor` component might be destroyed before the `quill` chunk is loaded and its code is executed\n    // this will lead to runtime exceptions, since the code will be executed on DOM nodes that don't exist within the tree.\n\n    this.quillSubscription = this.service.getQuill().pipe(\n      mergeMap((Quill) => this.service.beforeRender(Quill, this.customModules(), this.beforeRender()))\n    ).subscribe(Quill => {\n      this.editorElem = this.elementRef.nativeElement.querySelector(\n        '[quill-editor-element]'\n      )\n\n      const toolbarElem = this.elementRef.nativeElement.querySelector(\n        '[quill-editor-toolbar]'\n      )\n      const modules = Object.assign({}, this.modules() || this.service.config.modules)\n\n      if (toolbarElem) {\n        modules.toolbar = toolbarElem\n      } else if (modules.toolbar === undefined) {\n        modules.toolbar = defaultModules.toolbar\n      }\n\n      let placeholder = this.placeholder() !== undefined ? this.placeholder() : this.service.config.placeholder\n      if (placeholder === undefined) {\n        placeholder = 'Insert text here ...'\n      }\n\n      const styles = this.styles()\n      if (styles) {\n        Object.keys(styles).forEach((key: string) => {\n          this.renderer.setStyle(this.editorElem, key, styles[key])\n        })\n      }\n\n      if (this.classes()) {\n        this.addClasses(this.classes())\n      }\n\n      this.customOptions().forEach((customOption) => {\n        const newCustomOption = Quill.import(customOption.import)\n        newCustomOption.whitelist = customOption.whitelist\n        Quill.register(newCustomOption, true)\n      })\n\n      let bounds = this.bounds() && this.bounds() === 'self' ? this.editorElem : this.bounds()\n      if (!bounds) {\n        bounds = this.service.config.bounds ? this.service.config.bounds : this.document.body\n      }\n\n      let debug = this.debug()\n      if (!debug && debug !== false && this.service.config.debug) {\n        debug = this.service.config.debug\n      }\n\n      let readOnly = this.readOnly()\n      if (!readOnly && this.readOnly() !== false) {\n        readOnly = this.service.config.readOnly !== undefined ? this.service.config.readOnly : false\n      }\n\n      let formats = this.formats()\n      if (!formats && formats === undefined) {\n        formats = this.service.config.formats ? [...this.service.config.formats] : (this.service.config.formats === null ? null : undefined)\n      }\n\n      this.zone.runOutsideAngular(() => {\n        this.quillEditor = new Quill(this.editorElem, {\n          bounds,\n          debug,\n          formats,\n          modules,\n          placeholder,\n          readOnly,\n          registry: this.registry(),\n          theme: this.theme() || (this.service.config.theme ? this.service.config.theme : 'snow')\n        })\n\n        if (this.onNativeBlur.observed) {\n          // https://github.com/quilljs/quill/issues/2186#issuecomment-533401328\n          fromEvent(this.quillEditor.scroll.domNode, 'blur').pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => this.onNativeBlur.next({\n            editor: this.quillEditor,\n            source: 'dom'\n          }))\n          // https://github.com/quilljs/quill/issues/2186#issuecomment-803257538\n          const toolbar = this.quillEditor.getModule('toolbar') as Toolbar\n          if (toolbar.container) {\n            fromEvent(toolbar.container, 'mousedown').pipe(takeUntilDestroyed(this.destroyRef)).subscribe(e => e.preventDefault())\n          }\n        }\n\n        if (this.onNativeFocus.observed) {\n          fromEvent(this.quillEditor.scroll.domNode, 'focus').pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => this.onNativeFocus.next({\n            editor: this.quillEditor,\n            source: 'dom'\n          }))\n        }\n\n        // Set optional link placeholder, Quill has no native API for it so using workaround\n        if (this.linkPlaceholder()) {\n          const tooltip = (this.quillEditor as any)?.theme?.tooltip\n          const input = tooltip?.root?.querySelector('input[data-link]')\n          if (input?.dataset) {\n            input.dataset.link = this.linkPlaceholder()\n          }\n        }\n      })\n\n      if (this.content) {\n        const format = getFormat(this.format(), this.service.config.format)\n\n        if (format === 'text') {\n          this.quillEditor.setText(this.content, 'silent')\n        } else {\n          const valueSetter = this.valueSetter()\n          const newValue = valueSetter(this.quillEditor, this.content)\n          this.quillEditor.setContents(newValue, 'silent')\n        }\n\n        const history = this.quillEditor.getModule('history') as History\n        history.clear()\n      }\n\n      // initialize disabled status based on this.disabled as default value\n      this.setDisabledState()\n\n      this.addQuillEventListeners()\n\n      // The `requestAnimationFrame` triggers change detection. There's no sense to invoke the `requestAnimationFrame` if anyone is\n      // listening to the `onEditorCreated` event inside the template, for instance `<quill-view (onEditorCreated)=\"...\">`.\n      if (!this.onEditorCreated.observed && !this.onValidatorChanged) {\n        return\n      }\n\n      // The `requestAnimationFrame` will trigger change detection and `onEditorCreated` will also call `markDirty()`\n      // internally, since Angular wraps template event listeners into `listener` instruction. We're using the `requestAnimationFrame`\n      // to prevent the frame drop and avoid `ExpressionChangedAfterItHasBeenCheckedError` error.\n      raf$().pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => {\n        if (this.onValidatorChanged) {\n          this.onValidatorChanged()\n        }\n        this.onEditorCreated.emit(this.quillEditor)\n      })\n    })\n  }\n\n  selectionChangeHandler = (range: Range | null, oldRange: Range | null, source: string) => {\n    const trackChanges = this.trackChanges() || this.service.config.trackChanges\n    const shouldTriggerOnModelTouched = !range && !!this.onModelTouched && (source === 'user' || trackChanges && trackChanges === 'all')\n\n    // only emit changes when there's any listener\n    if (!this.onBlur.observed &&\n      !this.onFocus.observed &&\n      !this.onSelectionChanged.observed &&\n      !shouldTriggerOnModelTouched) {\n      return\n    }\n\n    this.zone.run(() => {\n      if (range === null) {\n        this.onBlur.emit({\n          editor: this.quillEditor,\n          source\n        })\n      } else if (oldRange === null) {\n        this.onFocus.emit({\n          editor: this.quillEditor,\n          source\n        })\n      }\n\n      this.onSelectionChanged.emit({\n        editor: this.quillEditor,\n        oldRange,\n        range,\n        source\n      })\n\n      if (shouldTriggerOnModelTouched) {\n        this.onModelTouched()\n      }\n\n      this.cd.markForCheck()\n    })\n  }\n\n  textChangeHandler = (delta: DeltaType, oldDelta: DeltaType, source: string): void => {\n    // only emit changes emitted by user interactions\n    const text = this.quillEditor.getText()\n    const content = this.quillEditor.getContents()\n\n    let html: string | null = this.quillEditor.getSemanticHTML()\n    if (this.isEmptyValue(html)) {\n      html = this.defaultEmptyValue()\n    }\n\n    const trackChanges = this.trackChanges() || this.service.config.trackChanges\n    const shouldTriggerOnModelChange = (source === 'user' || trackChanges && trackChanges === 'all') && !!this.onModelChange\n\n    // only emit changes when there's any listener\n    if (!this.onContentChanged.observed && !shouldTriggerOnModelChange) {\n      return\n    }\n\n    this.zone.run(() => {\n      if (shouldTriggerOnModelChange) {\n        const valueGetter = this.valueGetter()\n        this.onModelChange(\n          valueGetter(this.quillEditor)\n        )\n      }\n\n      this.onContentChanged.emit({\n        content,\n        delta,\n        editor: this.quillEditor,\n        html,\n        oldDelta,\n        source,\n        text\n      })\n\n      this.cd.markForCheck()\n    })\n  }\n\n  editorChangeHandler = (\n    event: 'text-change' | 'selection-change',\n    current: any | Range | null, old: any | Range | null, source: string\n  ): void => {\n    // only emit changes when there's any listener\n    if (!this.onEditorChanged.observed) {\n      return\n    }\n\n    // only emit changes emitted by user interactions\n    if (event === 'text-change') {\n      const text = this.quillEditor.getText()\n      const content = this.quillEditor.getContents()\n\n      let html: string | null = this.quillEditor.getSemanticHTML()\n      if (this.isEmptyValue(html)) {\n        html = this.defaultEmptyValue()\n      }\n\n      this.zone.run(() => {\n        this.onEditorChanged.emit({\n          content,\n          delta: current,\n          editor: this.quillEditor,\n          event,\n          html,\n          oldDelta: old,\n          source,\n          text\n        })\n\n        this.cd.markForCheck()\n      })\n    } else {\n      this.zone.run(() => {\n        this.onEditorChanged.emit({\n          editor: this.quillEditor,\n          event,\n          oldRange: old,\n          range: current,\n          source\n        })\n\n        this.cd.markForCheck()\n      })\n    }\n  }\n\n  ngOnDestroy() {\n    this.dispose()\n\n    this.quillSubscription?.unsubscribe()\n    this.quillSubscription = null\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (!this.quillEditor) {\n      return\n    }\n    if (changes.readOnly) {\n      this.quillEditor.enable(!changes.readOnly.currentValue)\n    }\n    if (changes.placeholder) {\n      this.quillEditor.root.dataset.placeholder =\n        changes.placeholder.currentValue\n    }\n    if (changes.styles) {\n      const currentStyling = changes.styles.currentValue\n      const previousStyling = changes.styles.previousValue\n\n      if (previousStyling) {\n        Object.keys(previousStyling).forEach((key: string) => {\n          this.renderer.removeStyle(this.editorElem, key)\n        })\n      }\n      if (currentStyling) {\n        Object.keys(currentStyling).forEach((key: string) => {\n          this.renderer.setStyle(this.editorElem, key, this.styles()[key])\n        })\n      }\n    }\n    if (changes.classes) {\n      const currentClasses = changes.classes.currentValue\n      const previousClasses = changes.classes.previousValue\n\n      if (previousClasses) {\n        this.removeClasses(previousClasses)\n      }\n\n      if (currentClasses) {\n        this.addClasses(currentClasses)\n      }\n    }\n    // We'd want to re-apply event listeners if the `debounceTime` binding changes to apply the\n    // `debounceTime` operator or vice-versa remove it.\n    if (changes.debounceTime) {\n      this.addQuillEventListeners()\n    }\n  }\n\n  addClasses(classList: string): void {\n    QuillEditorBase.normalizeClassNames(classList).forEach((c: string) => {\n      this.renderer.addClass(this.editorElem, c)\n    })\n  }\n\n  removeClasses(classList: string): void {\n    QuillEditorBase.normalizeClassNames(classList).forEach((c: string) => {\n      this.renderer.removeClass(this.editorElem, c)\n    })\n  }\n\n  writeValue(currentValue: any) {\n\n    // optional fix for https://github.com/angular/angular/issues/14988\n    if (this.filterNull() && currentValue === null) {\n      return\n    }\n\n    this.content = currentValue\n\n    if (!this.quillEditor) {\n      return\n    }\n\n    const format = getFormat(this.format(), this.service.config.format)\n    const valueSetter = this.valueSetter()\n    const newValue = valueSetter(this.quillEditor, currentValue)\n\n    if (this.compareValues()) {\n      const currentEditorValue = this.quillEditor.getContents()\n      if (JSON.stringify(currentEditorValue) === JSON.stringify(newValue)) {\n        return\n      }\n    }\n\n    if (currentValue) {\n      if (format === 'text') {\n        this.quillEditor.setText(currentValue)\n      } else {\n        this.quillEditor.setContents(newValue)\n      }\n      return\n    }\n    this.quillEditor.setText('')\n\n  }\n\n  setDisabledState(isDisabled: boolean = this.disabled): void {\n    // store initial value to set appropriate disabled status after ViewInit\n    this.disabled = isDisabled\n    if (this.quillEditor) {\n      if (isDisabled) {\n        this.quillEditor.disable()\n        this.renderer.setAttribute(this.elementRef.nativeElement, 'disabled', 'disabled')\n      } else {\n        if (!this.readOnly()) {\n          this.quillEditor.enable()\n        }\n        this.renderer.removeAttribute(this.elementRef.nativeElement, 'disabled')\n      }\n    }\n  }\n\n  registerOnChange(fn: (modelValue: any) => void): void {\n    this.onModelChange = fn\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onModelTouched = fn\n  }\n\n  registerOnValidatorChange(fn: () => void) {\n    this.onValidatorChanged = fn\n  }\n\n  validate() {\n    if (!this.quillEditor) {\n      return null\n    }\n\n    const err: {\n      minLengthError?: {\n        given: number\n        minLength: number\n      }\n      maxLengthError?: {\n        given: number\n        maxLength: number\n      }\n      requiredError?: { empty: boolean }\n    } = {}\n    let valid = true\n\n    const text = this.quillEditor.getText()\n    // trim text if wanted + handle special case that an empty editor contains a new line\n    const textLength = this.trimOnValidation() ? text.trim().length : (text.length === 1 && text.trim().length === 0 ? 0 : text.length - 1)\n    const deltaOperations = this.quillEditor.getContents().ops\n    const onlyEmptyOperation = !!deltaOperations && deltaOperations.length === 1 && ['\\n', ''].includes(deltaOperations[0].insert?.toString())\n\n    if (this.minLength() && textLength && textLength < this.minLength()) {\n      err.minLengthError = {\n        given: textLength,\n        minLength: this.minLength()\n      }\n\n      valid = false\n    }\n\n    if (this.maxLength() && textLength > this.maxLength()) {\n      err.maxLengthError = {\n        given: textLength,\n        maxLength: this.maxLength()\n      }\n\n      valid = false\n    }\n\n    if (this.required() && !textLength && onlyEmptyOperation) {\n      err.requiredError = {\n        empty: true\n      }\n\n      valid = false\n    }\n\n    return valid ? null : err\n  }\n\n  private addQuillEventListeners(): void {\n    this.dispose()\n\n    // We have to enter the `<root>` zone when adding event listeners, so `debounceTime` will spawn the\n    // `AsyncAction` there w/o triggering change detections. We still re-enter the Angular's zone through\n    // `zone.run` when we emit an event to the parent component.\n    this.zone.runOutsideAngular(() => {\n      this.subscription = new Subscription()\n\n      this.subscription.add(\n        // mark model as touched if editor lost focus\n        fromEvent(this.quillEditor, 'selection-change').subscribe(\n          ([range, oldRange, source]) => {\n            this.selectionChangeHandler(range as any, oldRange as any, source)\n          }\n        )\n      )\n\n      // The `fromEvent` supports passing JQuery-style event targets, the editor has `on` and `off` methods which\n      // will be invoked upon subscription and teardown.\n      let textChange$ = fromEvent(this.quillEditor, 'text-change')\n      let editorChange$ = fromEvent(this.quillEditor, 'editor-change')\n\n      if (typeof this.debounceTime() === 'number') {\n        textChange$ = textChange$.pipe(debounceTime(this.debounceTime()))\n        editorChange$ = editorChange$.pipe(debounceTime(this.debounceTime()))\n      }\n\n      this.subscription.add(\n        // update model if text changes\n        textChange$.subscribe(([delta, oldDelta, source]) => {\n          this.textChangeHandler(delta as any, oldDelta as any, source)\n        })\n      )\n\n      this.subscription.add(\n        // triggered if selection or text changed\n        editorChange$.subscribe(([event, current, old, source]) => {\n          this.editorChangeHandler(event as 'text-change' | 'selection-change', current, old, source)\n        })\n      )\n    })\n  }\n\n  private dispose(): void {\n    if (this.subscription !== null) {\n      this.subscription.unsubscribe()\n      this.subscription = null\n    }\n  }\n\n  private isEmptyValue(html: string | null) {\n    return html === '<p></p>' || html === '<div></div>' || html === '<p><br></p>' || html === '<div><br></div>'\n  }\n}\n\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/no-forward-ref","severity":2,"message":"Avoid using `forwardRef`","line":736,"column":20,"nodeType":"CallExpression","messageId":"noForwardRef","endLine":736,"endColumn":58},{"ruleId":"@angular-eslint/no-forward-ref","severity":2,"message":"Avoid using `forwardRef`","line":741,"column":20,"nodeType":"CallExpression","messageId":"noForwardRef","endLine":741,"endColumn":58},{"ruleId":"@angular-eslint/component-selector","severity":2,"message":"The selector should start with one of these prefixes: \"lib\" (https://angular.dev/style-guide#style-02-07)","line":744,"column":13,"nodeType":"Literal","messageId":"prefixFailure","endLine":744,"endColumn":27},{"ruleId":"@angular-eslint/component-max-inline-declarations","severity":2,"message":"`template` has too many lines (11). Maximum allowed is 3 (https://angular.dev/style-guide#style-05-04)","line":745,"column":13,"nodeType":"TemplateLiteral","messageId":"componentMaxInlineDeclarations","endLine":757,"endColumn":4},{"ruleId":"@angular-eslint/consistent-component-styles","severity":2,"message":"Use a `string` instead of a `string[]` for the `styles` property","line":758,"column":11,"nodeType":"ArrayExpression","messageId":"useStylesString","endLine":764,"endColumn":4,"fix":{"range":[23574,23638],"text":"`\n    :host {\n      display: inline-block;\n    }\n    `"}}],"suppressedMessages":[],"errorCount":16,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":3,"fixableWarningCount":0,"source":"import { DOCUMENT, isPlatformServer } from '@angular/common'\nimport { DomSanitizer } from '@angular/platform-browser'\n\nimport type QuillType from 'quill'\nimport type { QuillOptions } from 'quill'\nimport type DeltaType from 'quill-delta'\n\nimport {\n  AfterViewInit,\n  ChangeDetectorRef,\n  Component,\n  DestroyRef,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  forwardRef,\n  inject,\n  input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Output,\n  PLATFORM_ID,\n  Renderer2,\n  SecurityContext,\n  signal,\n  SimpleChanges,\n  ViewEncapsulation\n} from '@angular/core'\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop'\nimport { fromEvent, Subscription } from 'rxjs'\nimport { debounceTime, mergeMap } from 'rxjs/operators'\n\nimport { ControlValueAccessor, NG_VALIDATORS, NG_VALUE_ACCESSOR, Validator } from '@angular/forms'\n\nimport { CustomModule, CustomOption, defaultModules, QuillBeforeRender, QuillModules } from 'ngx-quill/config'\n\nimport type History from 'quill/modules/history'\nimport type Toolbar from 'quill/modules/toolbar'\nimport { getFormat, raf$ } from './helpers'\nimport { QuillService } from './quill.service'\n\nexport interface Range {\n  index: number\n  length: number\n}\n\nexport interface ContentChange {\n  content: DeltaType\n  delta: DeltaType\n  editor: QuillType\n  html: string | null\n  oldDelta: DeltaType\n  source: string\n  text: string\n}\n\nexport interface SelectionChange {\n  editor: QuillType\n  oldRange: Range | null\n  range: Range | null\n  source: string\n}\n\nexport interface Blur {\n  editor: QuillType\n  source: string\n}\n\nexport interface Focus {\n  editor: QuillType\n  source: string\n}\n\nexport type EditorChangeContent = ContentChange & { event: 'text-change' }\nexport type EditorChangeSelection = SelectionChange & { event: 'selection-change' }\n\n@Directive()\nexport abstract class QuillEditorBase implements AfterViewInit, ControlValueAccessor, OnChanges, OnInit, OnDestroy, Validator {\n  readonly format = input<'object' | 'html' | 'text' | 'json' | undefined>(\n    undefined\n  )\n  readonly theme = input<string | undefined>(undefined)\n  readonly modules = input<QuillModules | undefined>(undefined)\n  readonly debug = input<'warn' | 'log' | 'error' | false>(false)\n  readonly readOnly = input<boolean | undefined>(false)\n  readonly placeholder = input<string | undefined>(undefined)\n  readonly maxLength = input<number | undefined>(undefined)\n  readonly minLength = input<number | undefined>(undefined)\n  readonly required = input(false)\n  readonly formats = input<string[] | null | undefined>(undefined)\n  readonly customToolbarPosition = input<'top' | 'bottom'>('top')\n  readonly sanitize = input<boolean | undefined>(undefined)\n  readonly beforeRender = input<QuillBeforeRender>(undefined)\n  readonly styles = input<any>(null)\n  readonly registry = input<QuillOptions['registry']>(\n    undefined\n  )\n  readonly bounds = input<HTMLElement | string | undefined>(undefined)\n  readonly customOptions = input<CustomOption[]>([])\n  readonly customModules = input<CustomModule[]>([])\n  readonly trackChanges = input<'user' | 'all' | undefined>(undefined)\n  readonly classes = input<string | undefined>(undefined)\n  readonly trimOnValidation = input(false)\n  readonly linkPlaceholder = input<string | undefined>(undefined)\n  readonly compareValues = input(false)\n  readonly filterNull = input(false)\n  readonly debounceTime = input<number | undefined>(undefined)\n  /*\n  https://github.com/KillerCodeMonkey/ngx-quill/issues/1257 - fix null value set\n\n  provide default empty value\n  by default null\n\n  e.g. defaultEmptyValue=\"\" - empty string\n\n  <quill-editor\n    defaultEmptyValue=\"\"\n    formControlName=\"message\"\n  ></quill-editor>\n  */\n  readonly defaultEmptyValue = input<any>(null)\n\n  @Output() onEditorCreated = new EventEmitter<QuillType>()\n  @Output() onEditorChanged = new EventEmitter<EditorChangeContent | EditorChangeSelection>()\n  @Output() onContentChanged = new EventEmitter<ContentChange>()\n  @Output() onSelectionChanged = new EventEmitter<SelectionChange>()\n  @Output() onFocus = new EventEmitter<Focus>()\n  @Output() onBlur = new EventEmitter<Blur>()\n  @Output() onNativeFocus = new EventEmitter<Focus>()\n  @Output() onNativeBlur = new EventEmitter<Blur>()\n\n  quillEditor!: QuillType\n  editorElem!: HTMLElement\n  content: any\n  disabled = false // used to store initial value before ViewInit\n\n  readonly toolbarPosition = signal('top')\n\n  onModelChange: (modelValue?: any) => void\n  onModelTouched: () => void\n  onValidatorChanged: () => void\n\n  private subscription: Subscription | null = null\n  private quillSubscription: Subscription | null = null\n\n  private elementRef = inject(ElementRef)\n  private document = inject(DOCUMENT)\n\n  private cd = inject(ChangeDetectorRef)\n  private domSanitizer = inject(DomSanitizer)\n  private platformId = inject<string>(PLATFORM_ID)\n  private renderer = inject(Renderer2)\n  private zone = inject(NgZone)\n  private service = inject(QuillService)\n  private destroyRef = inject(DestroyRef)\n\n  static normalizeClassNames(classes: string): string[] {\n    const classList = classes.trim().split(' ')\n    return classList.reduce((prev: string[], cur: string) => {\n      const trimmed = cur.trim()\n      if (trimmed) {\n        prev.push(trimmed)\n      }\n\n      return prev\n    }, [])\n  }\n\n  valueGetter = input((quillEditor: QuillType): string | any => {\n    let html: string | null = quillEditor.getSemanticHTML()\n    if (this.isEmptyValue(html)) {\n      html = this.defaultEmptyValue()\n    }\n    let modelValue: string | DeltaType | null = html\n    const format = getFormat(this.format(), this.service.config.format)\n\n    if (format === 'text') {\n      modelValue = quillEditor.getText()\n    } else if (format === 'object') {\n      modelValue = quillEditor.getContents()\n    } else if (format === 'json') {\n      try {\n        modelValue = JSON.stringify(quillEditor.getContents())\n      } catch {\n        modelValue = quillEditor.getText()\n      }\n    }\n\n    return modelValue\n  })\n\n  valueSetter = input((quillEditor: QuillType, value: any): any => {\n    const format = getFormat(this.format(), this.service.config.format)\n    if (format === 'html') {\n      const sanitize = [true, false].includes(this.sanitize()) ? this.sanitize() : (this.service.config.sanitize || false)\n      if (sanitize) {\n        value = this.domSanitizer.sanitize(SecurityContext.HTML, value)\n      }\n      return quillEditor.clipboard.convert({ html: value })\n    } else if (format === 'json') {\n      try {\n        return JSON.parse(value)\n      } catch {\n        return [{ insert: value }]\n      }\n    }\n\n    return value\n  })\n\n  ngOnInit() {\n    this.toolbarPosition.set(this.customToolbarPosition())\n  }\n\n  ngAfterViewInit() {\n    if (isPlatformServer(this.platformId)) {\n      return\n    }\n\n    // The `quill-editor` component might be destroyed before the `quill` chunk is loaded and its code is executed\n    // this will lead to runtime exceptions, since the code will be executed on DOM nodes that don't exist within the tree.\n\n    this.quillSubscription = this.service.getQuill().pipe(\n      mergeMap((Quill) => this.service.beforeRender(Quill, this.customModules(), this.beforeRender()))\n    ).subscribe(Quill => {\n      this.editorElem = this.elementRef.nativeElement.querySelector(\n        '[quill-editor-element]'\n      )\n\n      const toolbarElem = this.elementRef.nativeElement.querySelector(\n        '[quill-editor-toolbar]'\n      )\n      const modules = Object.assign({}, this.modules() || this.service.config.modules)\n\n      if (toolbarElem) {\n        modules.toolbar = toolbarElem\n      } else if (modules.toolbar === undefined) {\n        modules.toolbar = defaultModules.toolbar\n      }\n\n      let placeholder = this.placeholder() !== undefined ? this.placeholder() : this.service.config.placeholder\n      if (placeholder === undefined) {\n        placeholder = 'Insert text here ...'\n      }\n\n      const styles = this.styles()\n      if (styles) {\n        Object.keys(styles).forEach((key: string) => {\n          this.renderer.setStyle(this.editorElem, key, styles[key])\n        })\n      }\n\n      if (this.classes()) {\n        this.addClasses(this.classes())\n      }\n\n      this.customOptions().forEach((customOption) => {\n        const newCustomOption = Quill.import(customOption.import)\n        newCustomOption.whitelist = customOption.whitelist\n        Quill.register(newCustomOption, true)\n      })\n\n      let bounds = this.bounds() && this.bounds() === 'self' ? this.editorElem : this.bounds()\n      if (!bounds) {\n        bounds = this.service.config.bounds ? this.service.config.bounds : this.document.body\n      }\n\n      let debug = this.debug()\n      if (!debug && debug !== false && this.service.config.debug) {\n        debug = this.service.config.debug\n      }\n\n      let readOnly = this.readOnly()\n      if (!readOnly && this.readOnly() !== false) {\n        readOnly = this.service.config.readOnly !== undefined ? this.service.config.readOnly : false\n      }\n\n      let formats = this.formats()\n      if (!formats && formats === undefined) {\n        formats = this.service.config.formats ? [...this.service.config.formats] : (this.service.config.formats === null ? null : undefined)\n      }\n\n      this.zone.runOutsideAngular(() => {\n        this.quillEditor = new Quill(this.editorElem, {\n          bounds,\n          debug,\n          formats,\n          modules,\n          placeholder,\n          readOnly,\n          registry: this.registry(),\n          theme: this.theme() || (this.service.config.theme ? this.service.config.theme : 'snow')\n        })\n\n        if (this.onNativeBlur.observed) {\n          // https://github.com/quilljs/quill/issues/2186#issuecomment-533401328\n          fromEvent(this.quillEditor.scroll.domNode, 'blur').pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => this.onNativeBlur.next({\n            editor: this.quillEditor,\n            source: 'dom'\n          }))\n          // https://github.com/quilljs/quill/issues/2186#issuecomment-803257538\n          const toolbar = this.quillEditor.getModule('toolbar') as Toolbar\n          if (toolbar.container) {\n            fromEvent(toolbar.container, 'mousedown').pipe(takeUntilDestroyed(this.destroyRef)).subscribe(e => e.preventDefault())\n          }\n        }\n\n        if (this.onNativeFocus.observed) {\n          fromEvent(this.quillEditor.scroll.domNode, 'focus').pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => this.onNativeFocus.next({\n            editor: this.quillEditor,\n            source: 'dom'\n          }))\n        }\n\n        // Set optional link placeholder, Quill has no native API for it so using workaround\n        if (this.linkPlaceholder()) {\n          const tooltip = (this.quillEditor as any)?.theme?.tooltip\n          const input = tooltip?.root?.querySelector('input[data-link]')\n          if (input?.dataset) {\n            input.dataset.link = this.linkPlaceholder()\n          }\n        }\n      })\n\n      if (this.content) {\n        const format = getFormat(this.format(), this.service.config.format)\n\n        if (format === 'text') {\n          this.quillEditor.setText(this.content, 'silent')\n        } else {\n          const valueSetter = this.valueSetter()\n          const newValue = valueSetter(this.quillEditor, this.content)\n          this.quillEditor.setContents(newValue, 'silent')\n        }\n\n        const history = this.quillEditor.getModule('history') as History\n        history.clear()\n      }\n\n      // initialize disabled status based on this.disabled as default value\n      this.setDisabledState()\n\n      this.addQuillEventListeners()\n\n      // The `requestAnimationFrame` triggers change detection. There's no sense to invoke the `requestAnimationFrame` if anyone is\n      // listening to the `onEditorCreated` event inside the template, for instance `<quill-view (onEditorCreated)=\"...\">`.\n      if (!this.onEditorCreated.observed && !this.onValidatorChanged) {\n        return\n      }\n\n      // The `requestAnimationFrame` will trigger change detection and `onEditorCreated` will also call `markDirty()`\n      // internally, since Angular wraps template event listeners into `listener` instruction. We're using the `requestAnimationFrame`\n      // to prevent the frame drop and avoid `ExpressionChangedAfterItHasBeenCheckedError` error.\n      raf$().pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => {\n        if (this.onValidatorChanged) {\n          this.onValidatorChanged()\n        }\n        this.onEditorCreated.emit(this.quillEditor)\n      })\n    })\n  }\n\n  selectionChangeHandler = (range: Range | null, oldRange: Range | null, source: string) => {\n    const trackChanges = this.trackChanges() || this.service.config.trackChanges\n    const shouldTriggerOnModelTouched = !range && !!this.onModelTouched && (source === 'user' || trackChanges && trackChanges === 'all')\n\n    // only emit changes when there's any listener\n    if (!this.onBlur.observed &&\n      !this.onFocus.observed &&\n      !this.onSelectionChanged.observed &&\n      !shouldTriggerOnModelTouched) {\n      return\n    }\n\n    this.zone.run(() => {\n      if (range === null) {\n        this.onBlur.emit({\n          editor: this.quillEditor,\n          source\n        })\n      } else if (oldRange === null) {\n        this.onFocus.emit({\n          editor: this.quillEditor,\n          source\n        })\n      }\n\n      this.onSelectionChanged.emit({\n        editor: this.quillEditor,\n        oldRange,\n        range,\n        source\n      })\n\n      if (shouldTriggerOnModelTouched) {\n        this.onModelTouched()\n      }\n\n      this.cd.markForCheck()\n    })\n  }\n\n  textChangeHandler = (delta: DeltaType, oldDelta: DeltaType, source: string): void => {\n    // only emit changes emitted by user interactions\n    const text = this.quillEditor.getText()\n    const content = this.quillEditor.getContents()\n\n    let html: string | null = this.quillEditor.getSemanticHTML()\n    if (this.isEmptyValue(html)) {\n      html = this.defaultEmptyValue()\n    }\n\n    const trackChanges = this.trackChanges() || this.service.config.trackChanges\n    const shouldTriggerOnModelChange = (source === 'user' || trackChanges && trackChanges === 'all') && !!this.onModelChange\n\n    // only emit changes when there's any listener\n    if (!this.onContentChanged.observed && !shouldTriggerOnModelChange) {\n      return\n    }\n\n    this.zone.run(() => {\n      if (shouldTriggerOnModelChange) {\n        const valueGetter = this.valueGetter()\n        this.onModelChange(\n          valueGetter(this.quillEditor)\n        )\n      }\n\n      this.onContentChanged.emit({\n        content,\n        delta,\n        editor: this.quillEditor,\n        html,\n        oldDelta,\n        source,\n        text\n      })\n\n      this.cd.markForCheck()\n    })\n  }\n\n  editorChangeHandler = (\n    event: 'text-change' | 'selection-change',\n    current: any | Range | null, old: any | Range | null, source: string\n  ): void => {\n    // only emit changes when there's any listener\n    if (!this.onEditorChanged.observed) {\n      return\n    }\n\n    // only emit changes emitted by user interactions\n    if (event === 'text-change') {\n      const text = this.quillEditor.getText()\n      const content = this.quillEditor.getContents()\n\n      let html: string | null = this.quillEditor.getSemanticHTML()\n      if (this.isEmptyValue(html)) {\n        html = this.defaultEmptyValue()\n      }\n\n      this.zone.run(() => {\n        this.onEditorChanged.emit({\n          content,\n          delta: current,\n          editor: this.quillEditor,\n          event,\n          html,\n          oldDelta: old,\n          source,\n          text\n        })\n\n        this.cd.markForCheck()\n      })\n    } else {\n      this.zone.run(() => {\n        this.onEditorChanged.emit({\n          editor: this.quillEditor,\n          event,\n          oldRange: old,\n          range: current,\n          source\n        })\n\n        this.cd.markForCheck()\n      })\n    }\n  }\n\n  ngOnDestroy() {\n    this.dispose()\n\n    this.quillSubscription?.unsubscribe()\n    this.quillSubscription = null\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (!this.quillEditor) {\n      return\n    }\n    if (changes.readOnly) {\n      this.quillEditor.enable(!changes.readOnly.currentValue)\n    }\n    if (changes.placeholder) {\n      this.quillEditor.root.dataset.placeholder =\n        changes.placeholder.currentValue\n    }\n    if (changes.styles) {\n      const currentStyling = changes.styles.currentValue\n      const previousStyling = changes.styles.previousValue\n\n      if (previousStyling) {\n        Object.keys(previousStyling).forEach((key: string) => {\n          this.renderer.removeStyle(this.editorElem, key)\n        })\n      }\n      if (currentStyling) {\n        Object.keys(currentStyling).forEach((key: string) => {\n          this.renderer.setStyle(this.editorElem, key, this.styles()[key])\n        })\n      }\n    }\n    if (changes.classes) {\n      const currentClasses = changes.classes.currentValue\n      const previousClasses = changes.classes.previousValue\n\n      if (previousClasses) {\n        this.removeClasses(previousClasses)\n      }\n\n      if (currentClasses) {\n        this.addClasses(currentClasses)\n      }\n    }\n    // We'd want to re-apply event listeners if the `debounceTime` binding changes to apply the\n    // `debounceTime` operator or vice-versa remove it.\n    if (changes.debounceTime) {\n      this.addQuillEventListeners()\n    }\n  }\n\n  addClasses(classList: string): void {\n    QuillEditorBase.normalizeClassNames(classList).forEach((c: string) => {\n      this.renderer.addClass(this.editorElem, c)\n    })\n  }\n\n  removeClasses(classList: string): void {\n    QuillEditorBase.normalizeClassNames(classList).forEach((c: string) => {\n      this.renderer.removeClass(this.editorElem, c)\n    })\n  }\n\n  writeValue(currentValue: any) {\n\n    // optional fix for https://github.com/angular/angular/issues/14988\n    if (this.filterNull() && currentValue === null) {\n      return\n    }\n\n    this.content = currentValue\n\n    if (!this.quillEditor) {\n      return\n    }\n\n    const format = getFormat(this.format(), this.service.config.format)\n    const valueSetter = this.valueSetter()\n    const newValue = valueSetter(this.quillEditor, currentValue)\n\n    if (this.compareValues()) {\n      const currentEditorValue = this.quillEditor.getContents()\n      if (JSON.stringify(currentEditorValue) === JSON.stringify(newValue)) {\n        return\n      }\n    }\n\n    if (currentValue) {\n      if (format === 'text') {\n        this.quillEditor.setText(currentValue)\n      } else {\n        this.quillEditor.setContents(newValue)\n      }\n      return\n    }\n    this.quillEditor.setText('')\n\n  }\n\n  setDisabledState(isDisabled: boolean = this.disabled): void {\n    // store initial value to set appropriate disabled status after ViewInit\n    this.disabled = isDisabled\n    if (this.quillEditor) {\n      if (isDisabled) {\n        this.quillEditor.disable()\n        this.renderer.setAttribute(this.elementRef.nativeElement, 'disabled', 'disabled')\n      } else {\n        if (!this.readOnly()) {\n          this.quillEditor.enable()\n        }\n        this.renderer.removeAttribute(this.elementRef.nativeElement, 'disabled')\n      }\n    }\n  }\n\n  registerOnChange(fn: (modelValue: any) => void): void {\n    this.onModelChange = fn\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onModelTouched = fn\n  }\n\n  registerOnValidatorChange(fn: () => void) {\n    this.onValidatorChanged = fn\n  }\n\n  validate() {\n    if (!this.quillEditor) {\n      return null\n    }\n\n    const err: {\n      minLengthError?: {\n        given: number\n        minLength: number\n      }\n      maxLengthError?: {\n        given: number\n        maxLength: number\n      }\n      requiredError?: { empty: boolean }\n    } = {}\n    let valid = true\n\n    const text = this.quillEditor.getText()\n    // trim text if wanted + handle special case that an empty editor contains a new line\n    const textLength = this.trimOnValidation() ? text.trim().length : (text.length === 1 && text.trim().length === 0 ? 0 : text.length - 1)\n    const deltaOperations = this.quillEditor.getContents().ops\n    const onlyEmptyOperation = !!deltaOperations && deltaOperations.length === 1 && ['\\n', ''].includes(deltaOperations[0].insert?.toString())\n\n    if (this.minLength() && textLength && textLength < this.minLength()) {\n      err.minLengthError = {\n        given: textLength,\n        minLength: this.minLength()\n      }\n\n      valid = false\n    }\n\n    if (this.maxLength() && textLength > this.maxLength()) {\n      err.maxLengthError = {\n        given: textLength,\n        maxLength: this.maxLength()\n      }\n\n      valid = false\n    }\n\n    if (this.required() && !textLength && onlyEmptyOperation) {\n      err.requiredError = {\n        empty: true\n      }\n\n      valid = false\n    }\n\n    return valid ? null : err\n  }\n\n  private addQuillEventListeners(): void {\n    this.dispose()\n\n    // We have to enter the `<root>` zone when adding event listeners, so `debounceTime` will spawn the\n    // `AsyncAction` there w/o triggering change detections. We still re-enter the Angular's zone through\n    // `zone.run` when we emit an event to the parent component.\n    this.zone.runOutsideAngular(() => {\n      this.subscription = new Subscription()\n\n      this.subscription.add(\n        // mark model as touched if editor lost focus\n        fromEvent(this.quillEditor, 'selection-change').subscribe(\n          ([range, oldRange, source]) => {\n            this.selectionChangeHandler(range as any, oldRange as any, source)\n          }\n        )\n      )\n\n      // The `fromEvent` supports passing JQuery-style event targets, the editor has `on` and `off` methods which\n      // will be invoked upon subscription and teardown.\n      let textChange$ = fromEvent(this.quillEditor, 'text-change')\n      let editorChange$ = fromEvent(this.quillEditor, 'editor-change')\n\n      if (typeof this.debounceTime() === 'number') {\n        textChange$ = textChange$.pipe(debounceTime(this.debounceTime()))\n        editorChange$ = editorChange$.pipe(debounceTime(this.debounceTime()))\n      }\n\n      this.subscription.add(\n        // update model if text changes\n        textChange$.subscribe(([delta, oldDelta, source]) => {\n          this.textChangeHandler(delta as any, oldDelta as any, source)\n        })\n      )\n\n      this.subscription.add(\n        // triggered if selection or text changed\n        editorChange$.subscribe(([event, current, old, source]) => {\n          this.editorChangeHandler(event as 'text-change' | 'selection-change', current, old, source)\n        })\n      )\n    })\n  }\n\n  private dispose(): void {\n    if (this.subscription !== null) {\n      this.subscription.unsubscribe()\n      this.subscription = null\n    }\n  }\n\n  private isEmptyValue(html: string | null) {\n    return html === '<p></p>' || html === '<div></div>' || html === '<p><br></p>' || html === '<div><br></div>'\n  }\n}\n\n@Component({\n  encapsulation: ViewEncapsulation.Emulated,\n  providers: [\n    {\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => QuillEditorComponent)\n    },\n    {\n      multi: true,\n      provide: NG_VALIDATORS,\n      useExisting: forwardRef(() => QuillEditorComponent)\n    }\n  ],\n  selector: 'quill-editor',\n  template: `\n    @if (toolbarPosition() !== 'top') {\n        <div quill-editor-element></div>\n    }\n\n    <ng-content select=\"[above-quill-editor-toolbar]\"></ng-content>\n    <ng-content select=\"[quill-editor-toolbar]\"></ng-content>\n    <ng-content select=\"[below-quill-editor-toolbar]\"></ng-content>\n\n    @if (toolbarPosition() === 'top') {\n        <div quill-editor-element></div>\n    }\n  `,\n  styles: [\n    `\n    :host {\n      display: inline-block;\n    }\n    `\n  ]\n})\nexport class QuillEditorComponent extends QuillEditorBase { }\n","usedDeprecatedRules":[]},{"filePath":"/home/migudel/Documents/GII/42C/TFG/develop/repos/ngx-quill/projects/ngx-quill/src/lib/quill-view-html.component.spec.ts","messages":[{"ruleId":"@angular-eslint/use-component-selector","severity":2,"message":"The selector of the component is mandatory","line":33,"column":3,"nodeType":"Decorator","messageId":"useComponentSelector","endLine":38,"endColumn":5},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":33,"column":3,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":38,"endColumn":5,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[29,1134],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing'\nimport { QuillViewHTMLComponent } from './quill-view-html.component'\nimport { QuillModule } from './quill.module'\n\ndescribe('Basic QuillViewHTMLComponent', () => {\n  let fixture: ComponentFixture<QuillViewHTMLComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n        QuillModule.forRoot()\n      ],\n      providers: QuillModule.forRoot().providers\n    })\n\n    fixture = TestBed.createComponent(QuillViewHTMLComponent)\n  })\n\n  it('should render and set default snow theme class', waitForAsync(async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('.ql-editor').length).toBe(1)\n    expect(fixture.componentInstance.themeClass()).toBe('ql-snow')\n    const viewElement = element.querySelector('.ql-container.ql-snow.ngx-quill-view-html > .ql-editor')\n    expect(viewElement).toBeDefined()\n  }))\n})\n\ndescribe('QuillViewHTMLComponent - content', () => {\n  @Component({\n    changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/prefer-signals","severity":2,"message":"Use the `viewChild` function instead of the `ViewChild` decorator","line":40,"column":5,"nodeType":"Decorator","messageId":"preferQuerySignals","endLine":42,"endColumn":7},{"ruleId":"@angular-eslint/use-component-selector","severity":2,"message":"The selector of the component is mandatory","line":106,"column":3,"nodeType":"Decorator","messageId":"useComponentSelector","endLine":111,"endColumn":5},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":106,"column":3,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":111,"endColumn":5,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[29,3488],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing'\nimport { QuillViewHTMLComponent } from './quill-view-html.component'\nimport { QuillModule } from './quill.module'\n\ndescribe('Basic QuillViewHTMLComponent', () => {\n  let fixture: ComponentFixture<QuillViewHTMLComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n        QuillModule.forRoot()\n      ],\n      providers: QuillModule.forRoot().providers\n    })\n\n    fixture = TestBed.createComponent(QuillViewHTMLComponent)\n  })\n\n  it('should render and set default snow theme class', waitForAsync(async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('.ql-editor').length).toBe(1)\n    expect(fixture.componentInstance.themeClass()).toBe('ql-snow')\n    const viewElement = element.querySelector('.ql-container.ql-snow.ngx-quill-view-html > .ql-editor')\n    expect(viewElement).toBeDefined()\n  }))\n})\n\ndescribe('QuillViewHTMLComponent - content', () => {\n  @Component({\n    imports: [QuillModule],\n    template: `\n  <quill-view-html [content]=\"content\" [theme]=\"theme\"></quill-view-html>\n  `\n  })\n  class HTMLComponent {\n    @ViewChild(QuillViewHTMLComponent, {\n      static: true\n    }) view: QuillViewHTMLComponent | undefined\n    content = '<p>Hallo</p>'\n    theme = 'snow'\n\n  }\n\n  let fixture: ComponentFixture<HTMLComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [QuillModule],\n      providers: QuillModule.forRoot().providers\n    })\n\n    fixture = TestBed.createComponent(HTMLComponent) as ComponentFixture<HTMLComponent>\n    fixture.detectChanges()\n  })\n  it('should be set html', waitForAsync(async () => {\n    const element = fixture.nativeElement\n\n    await fixture.whenStable()\n    const viewElement = element.querySelector('.ql-container.ql-snow.ngx-quill-view-html > .ql-editor')\n    expect(viewElement.innerHTML).toEqual('<p>Hallo</p>')\n  }))\n\n  it('should update html', waitForAsync(async () => {\n    const component = fixture.componentInstance\n    await fixture.whenStable()\n    component.content = '<p>test</p>'\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const element = fixture.nativeElement\n    const viewElement = element.querySelector('.ql-container.ql-snow.ngx-quill-view-html > .ql-editor')\n    expect(viewElement.innerHTML).toEqual('<p>test</p>')\n  }))\n\n  it('should set default theme when not set', waitForAsync(async () => {\n    const component = fixture.componentInstance\n    await fixture.whenStable()\n    component.theme = undefined\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const element = fixture.nativeElement\n    const viewElement = element.querySelector('.ql-container.ql-snow.ngx-quill-view-html > .ql-editor')\n    expect(viewElement.innerHTML).toEqual('<p>Hallo</p>')\n  }))\n\n  it('should update theme', waitForAsync(async () => {\n    const component = fixture.componentInstance\n    await fixture.whenStable()\n    component.theme = 'bubble'\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const element = fixture.nativeElement\n    const viewElement = element.querySelector('.ql-container.ql-bubble.ngx-quill-view-html > .ql-editor')\n    expect(viewElement.innerHTML).toEqual('<p>Hallo</p>')\n  }))\n})\n\ndescribe('QuillViewHTMLComponent - sanitize', () => {\n  @Component({\n    changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Component, ViewChild } from '@angular/core'\nimport { ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing'\nimport { QuillViewHTMLComponent } from './quill-view-html.component'\nimport { QuillModule } from './quill.module'\n\ndescribe('Basic QuillViewHTMLComponent', () => {\n  let fixture: ComponentFixture<QuillViewHTMLComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n        QuillModule.forRoot()\n      ],\n      providers: QuillModule.forRoot().providers\n    })\n\n    fixture = TestBed.createComponent(QuillViewHTMLComponent)\n  })\n\n  it('should render and set default snow theme class', waitForAsync(async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('.ql-editor').length).toBe(1)\n    expect(fixture.componentInstance.themeClass()).toBe('ql-snow')\n    const viewElement = element.querySelector('.ql-container.ql-snow.ngx-quill-view-html > .ql-editor')\n    expect(viewElement).toBeDefined()\n  }))\n})\n\ndescribe('QuillViewHTMLComponent - content', () => {\n  @Component({\n    imports: [QuillModule],\n    template: `\n  <quill-view-html [content]=\"content\" [theme]=\"theme\"></quill-view-html>\n  `\n  })\n  class HTMLComponent {\n    @ViewChild(QuillViewHTMLComponent, {\n      static: true\n    }) view: QuillViewHTMLComponent | undefined\n    content = '<p>Hallo</p>'\n    theme = 'snow'\n\n  }\n\n  let fixture: ComponentFixture<HTMLComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [QuillModule],\n      providers: QuillModule.forRoot().providers\n    })\n\n    fixture = TestBed.createComponent(HTMLComponent) as ComponentFixture<HTMLComponent>\n    fixture.detectChanges()\n  })\n  it('should be set html', waitForAsync(async () => {\n    const element = fixture.nativeElement\n\n    await fixture.whenStable()\n    const viewElement = element.querySelector('.ql-container.ql-snow.ngx-quill-view-html > .ql-editor')\n    expect(viewElement.innerHTML).toEqual('<p>Hallo</p>')\n  }))\n\n  it('should update html', waitForAsync(async () => {\n    const component = fixture.componentInstance\n    await fixture.whenStable()\n    component.content = '<p>test</p>'\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const element = fixture.nativeElement\n    const viewElement = element.querySelector('.ql-container.ql-snow.ngx-quill-view-html > .ql-editor')\n    expect(viewElement.innerHTML).toEqual('<p>test</p>')\n  }))\n\n  it('should set default theme when not set', waitForAsync(async () => {\n    const component = fixture.componentInstance\n    await fixture.whenStable()\n    component.theme = undefined\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const element = fixture.nativeElement\n    const viewElement = element.querySelector('.ql-container.ql-snow.ngx-quill-view-html > .ql-editor')\n    expect(viewElement.innerHTML).toEqual('<p>Hallo</p>')\n  }))\n\n  it('should update theme', waitForAsync(async () => {\n    const component = fixture.componentInstance\n    await fixture.whenStable()\n    component.theme = 'bubble'\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    const element = fixture.nativeElement\n    const viewElement = element.querySelector('.ql-container.ql-bubble.ngx-quill-view-html > .ql-editor')\n    expect(viewElement.innerHTML).toEqual('<p>Hallo</p>')\n  }))\n})\n\ndescribe('QuillViewHTMLComponent - sanitize', () => {\n  @Component({\n    imports: [QuillModule],\n    template: `\n  <quill-view-html [content]=\"content\" [sanitize]=\"sanitize\"></quill-view-html>\n  `\n  })\n  class HTMLComponent {\n    content = '<p>Hallo <img src=\"wroooong.jpg\" onerror=\"window.alert(\\'sanitize me\\')\"></p>'\n    sanitize = false\n  }\n\n  let fixture: ComponentFixture<HTMLComponent>\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [QuillModule],\n      providers: QuillModule.forRoot().providers\n    })\n\n    fixture = TestBed.createComponent(HTMLComponent)\n  })\n\n  it('should NOT sanitize content when sanitize parameter is false', () => {\n    fixture.detectChanges()\n\n    const element = fixture.nativeElement\n    const viewElement = element.querySelector('.ql-container.ql-snow.ngx-quill-view-html > .ql-editor')\n    expect(viewElement.innerHTML).toEqual('<p>Hallo <img src=\"wroooong.jpg\" onerror=\"window.alert(\\'sanitize me\\')\"></p>')\n  })\n\n  it('should sanitize content when sanitize parameter is true', () => {\n    const component = fixture.componentInstance\n    component.sanitize = true\n    fixture.detectChanges()\n\n    const element = fixture.nativeElement\n    const viewElement = element.querySelector('.ql-container.ql-snow.ngx-quill-view-html > .ql-editor')\n    expect(viewElement.innerHTML).toEqual('<p>Hallo <img src=\"wroooong.jpg\"></p>')\n  })\n\n  it('should use default sanatize when not set', () => {\n    const component = fixture.componentInstance\n    component.sanitize = undefined\n    fixture.detectChanges()\n\n    const element = fixture.nativeElement\n    const viewElement = element.querySelector('.ql-container.ql-snow.ngx-quill-view-html > .ql-editor')\n    expect(viewElement.innerHTML).toEqual('<p>Hallo <img src=\"wroooong.jpg\" onerror=\"window.alert(\\'sanitize me\\')\"></p>')\n  })\n})\n","usedDeprecatedRules":[]},{"filePath":"/home/migudel/Documents/GII/42C/TFG/develop/repos/ngx-quill/projects/ngx-quill/src/lib/quill-view-html.component.ts","messages":[{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":14,"column":1,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":29,"endColumn":3,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[247,287],"text":", ChangeDetectionStrategy\n} from '@angular/core'\n\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/use-component-view-encapsulation","severity":2,"message":"Using `ViewEncapsulation.None` makes your styles global, which may have an unintended effect","line":16,"column":36,"nodeType":"Identifier","messageId":"useComponentViewEncapsulation","endLine":16,"endColumn":40,"suggestions":[{"messageId":"suggestRemoveViewEncapsulationNone","fix":{"range":[207,347],"text":",\n  input,\n  signal\n} from '@angular/core'\n\n@Component({\n  imports: [NgClass],\n  "},"desc":"Remove `ViewEncapsulation.None`"}]},{"ruleId":"@angular-eslint/component-selector","severity":2,"message":"The selector should start with one of these prefixes: \"lib\" (https://angular.dev/style-guide#style-02-07)","line":17,"column":13,"nodeType":"Literal","messageId":"prefixFailure","endLine":17,"endColumn":30},{"ruleId":"@angular-eslint/consistent-component-styles","severity":2,"message":"Use a `string` instead of a `string[]` for the `styles` property","line":18,"column":11,"nodeType":"ArrayExpression","messageId":"useStylesString","endLine":22,"endColumn":3,"fix":{"range":[389,445],"text":"`\n.ql-container.ngx-quill-view-html {\n  border: 0;\n}\n`"}},{"ruleId":"@angular-eslint/component-max-inline-declarations","severity":2,"message":"`template` has too many lines (4). Maximum allowed is 3 (https://angular.dev/style-guide#style-05-04)","line":23,"column":13,"nodeType":"TemplateLiteral","messageId":"componentMaxInlineDeclarations","endLine":28,"endColumn":2}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { DomSanitizer, SafeHtml } from '@angular/platform-browser'\nimport { QuillService } from './quill.service'\n\nimport { NgClass } from '@angular/common'\nimport {\n  Component,\n  OnChanges,\n  SimpleChanges,\n  ViewEncapsulation,\n  input,\n  signal\n} from '@angular/core'\n\n@Component({\n  imports: [NgClass],\n  encapsulation: ViewEncapsulation.None,\n  selector: 'quill-view-html',\n  styles: [`\n.ql-container.ngx-quill-view-html {\n  border: 0;\n}\n`],\n  template: `\n  <div class=\"ql-container\" [ngClass]=\"themeClass()\">\n    <div class=\"ql-editor\" [innerHTML]=\"innerHTML()\">\n    </div>\n  </div>\n`\n})\nexport class QuillViewHTMLComponent implements OnChanges {\n  readonly content = input('')\n  readonly theme = input<string | undefined>(undefined)\n  readonly sanitize = input<boolean | undefined>(undefined)\n\n  readonly innerHTML = signal<SafeHtml>('')\n  readonly themeClass = signal('ql-snow')\n\n  constructor(\n    private sanitizer: DomSanitizer,\n    protected service: QuillService\n  ) {}\n\n  ngOnChanges(changes: SimpleChanges) {\n    if (changes.theme) {\n      const theme = changes.theme.currentValue || (this.service.config.theme ? this.service.config.theme : 'snow')\n      this.themeClass.set(`ql-${theme} ngx-quill-view-html`)\n    } else if (!this.theme()) {\n      const theme = this.service.config.theme ? this.service.config.theme : 'snow'\n      this.themeClass.set(`ql-${theme} ngx-quill-view-html`)\n    }\n    if (changes.content) {\n      const content = changes.content.currentValue\n      const sanitize = [true, false].includes(this.sanitize()) ? this.sanitize() : (this.service.config.sanitize || false)\n      const innerHTML = sanitize ? content : this.sanitizer.bypassSecurityTrustHtml(content)\n      this.innerHTML.set(innerHTML)\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/migudel/Documents/GII/42C/TFG/develop/repos/ngx-quill/projects/ngx-quill/src/lib/quill-view.component.spec.ts","messages":[{"ruleId":"@angular-eslint/use-component-selector","severity":2,"message":"The selector of the component is mandatory","line":58,"column":5,"nodeType":"Decorator","messageId":"useComponentSelector","endLine":63,"endColumn":7},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":58,"column":5,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":63,"endColumn":7,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[29,1579],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, TestBed } from '@angular/core/testing'\n\nimport { QuillViewComponent } from './quill-view.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\ndescribe('Basic QuillViewComponent', () => {\n  let fixture: ComponentFixture<QuillViewComponent>\n\n  beforeEach(async () => {\n    TestBed.configureTestingModule({\n      imports: [\n        QuillModule.forRoot({\n          customModules: [{\n            path: 'modules/custom',\n            implementation: CustomModule\n          }],\n          customOptions: [{\n            import: 'attributors/style/size',\n            whitelist: ['14']\n          }],\n        })\n      ],\n      providers: QuillModule.forRoot().providers\n    })\n\n    fixture = TestBed.createComponent(QuillViewComponent)\n    fixture.detectChanges()\n    await fixture.whenStable()\n  })\n\n  it('should render and set default snow theme class', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('.ql-editor').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n    const viewElement = element.querySelector('.ql-container.ql-snow.ngx-quill-view > .ql-editor')\n    expect(viewElement).toBeDefined()\n  })\n})\n\ndescribe('Formats', () => {\n  describe('object', () => {\n    @Component({\n      changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/prefer-signals","severity":2,"message":"Use the `viewChild` function instead of the `ViewChild` decorator","line":65,"column":7,"nodeType":"Decorator","messageId":"preferQuerySignals","endLine":67,"endColumn":9},{"ruleId":"@angular-eslint/use-component-selector","severity":2,"message":"The selector of the component is mandatory","line":107,"column":5,"nodeType":"Decorator","messageId":"useComponentSelector","endLine":112,"endColumn":7},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":107,"column":5,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":112,"endColumn":7,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[29,3056],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, TestBed } from '@angular/core/testing'\n\nimport { QuillViewComponent } from './quill-view.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\ndescribe('Basic QuillViewComponent', () => {\n  let fixture: ComponentFixture<QuillViewComponent>\n\n  beforeEach(async () => {\n    TestBed.configureTestingModule({\n      imports: [\n        QuillModule.forRoot({\n          customModules: [{\n            path: 'modules/custom',\n            implementation: CustomModule\n          }],\n          customOptions: [{\n            import: 'attributors/style/size',\n            whitelist: ['14']\n          }],\n        })\n      ],\n      providers: QuillModule.forRoot().providers\n    })\n\n    fixture = TestBed.createComponent(QuillViewComponent)\n    fixture.detectChanges()\n    await fixture.whenStable()\n  })\n\n  it('should render and set default snow theme class', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('.ql-editor').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n    const viewElement = element.querySelector('.ql-container.ql-snow.ngx-quill-view > .ql-editor')\n    expect(viewElement).toBeDefined()\n  })\n})\n\ndescribe('Formats', () => {\n  describe('object', () => {\n    @Component({\n      imports: [QuillModule],\n      template: `\n    <quill-view [content]=\"content\" [customModules]=\"[{path: 'modules/test', implementation: impl}]\" format=\"object\"></quill-view>\n    `\n    })\n    class ObjectComponent {\n      @ViewChild(QuillViewComponent, {\n        static: true\n      }) view: QuillViewComponent | undefined\n      content = [{\n        insert: 'Hello'\n      }]\n\n      impl = CustomModule\n    }\n\n    let fixture: ComponentFixture<ObjectComponent>\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(ObjectComponent) as ComponentFixture<ObjectComponent>\n      fixture.detectChanges()\n    })\n\n    it('should be set object', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.view!.quillEditor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hello\\n' }] }))\n    })\n\n    it('should update object content', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.content = [{ insert: '1234' }]\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.view!.quillEditor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: '1234\\n' }] }))\n    })\n  })\n\n  describe('html', () => {\n    @Component({\n      changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/prefer-signals","severity":2,"message":"Use the `viewChild` function instead of the `ViewChild` decorator","line":114,"column":7,"nodeType":"Decorator","messageId":"preferQuerySignals","endLine":116,"endColumn":9},{"ruleId":"@angular-eslint/use-component-selector","severity":2,"message":"The selector of the component is mandatory","line":151,"column":5,"nodeType":"Decorator","messageId":"useComponentSelector","endLine":156,"endColumn":7},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":151,"column":5,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":156,"endColumn":7,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[29,4282],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, TestBed } from '@angular/core/testing'\n\nimport { QuillViewComponent } from './quill-view.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\ndescribe('Basic QuillViewComponent', () => {\n  let fixture: ComponentFixture<QuillViewComponent>\n\n  beforeEach(async () => {\n    TestBed.configureTestingModule({\n      imports: [\n        QuillModule.forRoot({\n          customModules: [{\n            path: 'modules/custom',\n            implementation: CustomModule\n          }],\n          customOptions: [{\n            import: 'attributors/style/size',\n            whitelist: ['14']\n          }],\n        })\n      ],\n      providers: QuillModule.forRoot().providers\n    })\n\n    fixture = TestBed.createComponent(QuillViewComponent)\n    fixture.detectChanges()\n    await fixture.whenStable()\n  })\n\n  it('should render and set default snow theme class', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('.ql-editor').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n    const viewElement = element.querySelector('.ql-container.ql-snow.ngx-quill-view > .ql-editor')\n    expect(viewElement).toBeDefined()\n  })\n})\n\ndescribe('Formats', () => {\n  describe('object', () => {\n    @Component({\n      imports: [QuillModule],\n      template: `\n    <quill-view [content]=\"content\" [customModules]=\"[{path: 'modules/test', implementation: impl}]\" format=\"object\"></quill-view>\n    `\n    })\n    class ObjectComponent {\n      @ViewChild(QuillViewComponent, {\n        static: true\n      }) view: QuillViewComponent | undefined\n      content = [{\n        insert: 'Hello'\n      }]\n\n      impl = CustomModule\n    }\n\n    let fixture: ComponentFixture<ObjectComponent>\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(ObjectComponent) as ComponentFixture<ObjectComponent>\n      fixture.detectChanges()\n    })\n\n    it('should be set object', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.view!.quillEditor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hello\\n' }] }))\n    })\n\n    it('should update object content', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.content = [{ insert: '1234' }]\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.view!.quillEditor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: '1234\\n' }] }))\n    })\n  })\n\n  describe('html', () => {\n    @Component({\n      imports: [QuillModule],\n      template: `\n    <quill-view [content]=\"content\" format=\"html\"></quill-view>\n    `\n    })\n    class HTMLComponent {\n      @ViewChild(QuillViewComponent, {\n        static: true\n      }) view: QuillViewComponent | undefined\n      content = '<p>Hallo</p>'\n    }\n\n    let fixture: ComponentFixture<HTMLComponent>\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(HTMLComponent) as ComponentFixture<HTMLComponent>\n      fixture.detectChanges()\n    })\n    it('should be set html', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      expect(component.view!.quillEditor.getText().trim()).toEqual('Hallo')\n    })\n\n    it('should update html', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.content = '<p>test</p>'\n      fixture.detectChanges()\n      await fixture.whenStable()\n\n      expect(component.view!.quillEditor.getText().trim()).toEqual('test')\n    })\n  })\n\n  describe('text', () => {\n    @Component({\n      changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/prefer-signals","severity":2,"message":"Use the `viewChild` function instead of the `ViewChild` decorator","line":158,"column":7,"nodeType":"Decorator","messageId":"preferQuerySignals","endLine":160,"endColumn":9},{"ruleId":"@angular-eslint/use-component-selector","severity":2,"message":"The selector of the component is mandatory","line":194,"column":5,"nodeType":"Decorator","messageId":"useComponentSelector","endLine":199,"endColumn":7},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":194,"column":5,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":199,"endColumn":7,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[29,5493],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, TestBed } from '@angular/core/testing'\n\nimport { QuillViewComponent } from './quill-view.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\ndescribe('Basic QuillViewComponent', () => {\n  let fixture: ComponentFixture<QuillViewComponent>\n\n  beforeEach(async () => {\n    TestBed.configureTestingModule({\n      imports: [\n        QuillModule.forRoot({\n          customModules: [{\n            path: 'modules/custom',\n            implementation: CustomModule\n          }],\n          customOptions: [{\n            import: 'attributors/style/size',\n            whitelist: ['14']\n          }],\n        })\n      ],\n      providers: QuillModule.forRoot().providers\n    })\n\n    fixture = TestBed.createComponent(QuillViewComponent)\n    fixture.detectChanges()\n    await fixture.whenStable()\n  })\n\n  it('should render and set default snow theme class', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('.ql-editor').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n    const viewElement = element.querySelector('.ql-container.ql-snow.ngx-quill-view > .ql-editor')\n    expect(viewElement).toBeDefined()\n  })\n})\n\ndescribe('Formats', () => {\n  describe('object', () => {\n    @Component({\n      imports: [QuillModule],\n      template: `\n    <quill-view [content]=\"content\" [customModules]=\"[{path: 'modules/test', implementation: impl}]\" format=\"object\"></quill-view>\n    `\n    })\n    class ObjectComponent {\n      @ViewChild(QuillViewComponent, {\n        static: true\n      }) view: QuillViewComponent | undefined\n      content = [{\n        insert: 'Hello'\n      }]\n\n      impl = CustomModule\n    }\n\n    let fixture: ComponentFixture<ObjectComponent>\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(ObjectComponent) as ComponentFixture<ObjectComponent>\n      fixture.detectChanges()\n    })\n\n    it('should be set object', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.view!.quillEditor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hello\\n' }] }))\n    })\n\n    it('should update object content', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.content = [{ insert: '1234' }]\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.view!.quillEditor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: '1234\\n' }] }))\n    })\n  })\n\n  describe('html', () => {\n    @Component({\n      imports: [QuillModule],\n      template: `\n    <quill-view [content]=\"content\" format=\"html\"></quill-view>\n    `\n    })\n    class HTMLComponent {\n      @ViewChild(QuillViewComponent, {\n        static: true\n      }) view: QuillViewComponent | undefined\n      content = '<p>Hallo</p>'\n    }\n\n    let fixture: ComponentFixture<HTMLComponent>\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(HTMLComponent) as ComponentFixture<HTMLComponent>\n      fixture.detectChanges()\n    })\n    it('should be set html', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      expect(component.view!.quillEditor.getText().trim()).toEqual('Hallo')\n    })\n\n    it('should update html', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.content = '<p>test</p>'\n      fixture.detectChanges()\n      await fixture.whenStable()\n\n      expect(component.view!.quillEditor.getText().trim()).toEqual('test')\n    })\n  })\n\n  describe('text', () => {\n    @Component({\n      imports: [QuillModule],\n      template: `\n    <quill-view [content]=\"content\" format=\"text\"></quill-view>\n    `\n    })\n    class TextComponent {\n      @ViewChild(QuillViewComponent, {\n        static: true\n      }) view: QuillViewComponent | undefined\n      content = 'Hallo'\n    }\n\n    let fixture: ComponentFixture<TextComponent>\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(TextComponent) as ComponentFixture<TextComponent>\n      fixture.detectChanges()\n    })\n    it('should be set text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      expect(component.view!.quillEditor.getText().trim()).toEqual('Hallo')\n    })\n\n    it('should update text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.content = 'test'\n      fixture.detectChanges()\n      await fixture.whenStable()\n\n      expect(component.view!.quillEditor.getText().trim()).toEqual('test')\n    })\n  })\n\n  describe('json', () => {\n    @Component({\n      changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/prefer-signals","severity":2,"message":"Use the `viewChild` function instead of the `ViewChild` decorator","line":201,"column":7,"nodeType":"Decorator","messageId":"preferQuerySignals","endLine":203,"endColumn":9},{"ruleId":"@angular-eslint/use-component-selector","severity":2,"message":"The selector of the component is mandatory","line":247,"column":3,"nodeType":"Decorator","messageId":"useComponentSelector","endLine":252,"endColumn":5},{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":247,"column":3,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":252,"endColumn":5,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[29,6978],"text":", ChangeDetectionStrategy } from '@angular/core'\nimport { ComponentFixture, TestBed } from '@angular/core/testing'\n\nimport { QuillViewComponent } from './quill-view.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\ndescribe('Basic QuillViewComponent', () => {\n  let fixture: ComponentFixture<QuillViewComponent>\n\n  beforeEach(async () => {\n    TestBed.configureTestingModule({\n      imports: [\n        QuillModule.forRoot({\n          customModules: [{\n            path: 'modules/custom',\n            implementation: CustomModule\n          }],\n          customOptions: [{\n            import: 'attributors/style/size',\n            whitelist: ['14']\n          }],\n        })\n      ],\n      providers: QuillModule.forRoot().providers\n    })\n\n    fixture = TestBed.createComponent(QuillViewComponent)\n    fixture.detectChanges()\n    await fixture.whenStable()\n  })\n\n  it('should render and set default snow theme class', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('.ql-editor').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n    const viewElement = element.querySelector('.ql-container.ql-snow.ngx-quill-view > .ql-editor')\n    expect(viewElement).toBeDefined()\n  })\n})\n\ndescribe('Formats', () => {\n  describe('object', () => {\n    @Component({\n      imports: [QuillModule],\n      template: `\n    <quill-view [content]=\"content\" [customModules]=\"[{path: 'modules/test', implementation: impl}]\" format=\"object\"></quill-view>\n    `\n    })\n    class ObjectComponent {\n      @ViewChild(QuillViewComponent, {\n        static: true\n      }) view: QuillViewComponent | undefined\n      content = [{\n        insert: 'Hello'\n      }]\n\n      impl = CustomModule\n    }\n\n    let fixture: ComponentFixture<ObjectComponent>\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(ObjectComponent) as ComponentFixture<ObjectComponent>\n      fixture.detectChanges()\n    })\n\n    it('should be set object', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.view!.quillEditor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hello\\n' }] }))\n    })\n\n    it('should update object content', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.content = [{ insert: '1234' }]\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.view!.quillEditor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: '1234\\n' }] }))\n    })\n  })\n\n  describe('html', () => {\n    @Component({\n      imports: [QuillModule],\n      template: `\n    <quill-view [content]=\"content\" format=\"html\"></quill-view>\n    `\n    })\n    class HTMLComponent {\n      @ViewChild(QuillViewComponent, {\n        static: true\n      }) view: QuillViewComponent | undefined\n      content = '<p>Hallo</p>'\n    }\n\n    let fixture: ComponentFixture<HTMLComponent>\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(HTMLComponent) as ComponentFixture<HTMLComponent>\n      fixture.detectChanges()\n    })\n    it('should be set html', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      expect(component.view!.quillEditor.getText().trim()).toEqual('Hallo')\n    })\n\n    it('should update html', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.content = '<p>test</p>'\n      fixture.detectChanges()\n      await fixture.whenStable()\n\n      expect(component.view!.quillEditor.getText().trim()).toEqual('test')\n    })\n  })\n\n  describe('text', () => {\n    @Component({\n      imports: [QuillModule],\n      template: `\n    <quill-view [content]=\"content\" format=\"text\"></quill-view>\n    `\n    })\n    class TextComponent {\n      @ViewChild(QuillViewComponent, {\n        static: true\n      }) view: QuillViewComponent | undefined\n      content = 'Hallo'\n    }\n\n    let fixture: ComponentFixture<TextComponent>\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(TextComponent) as ComponentFixture<TextComponent>\n      fixture.detectChanges()\n    })\n    it('should be set text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      expect(component.view!.quillEditor.getText().trim()).toEqual('Hallo')\n    })\n\n    it('should update text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.content = 'test'\n      fixture.detectChanges()\n      await fixture.whenStable()\n\n      expect(component.view!.quillEditor.getText().trim()).toEqual('test')\n    })\n  })\n\n  describe('json', () => {\n    @Component({\n      imports: [QuillModule],\n      template: `\n    <quill-view [content]=\"content\" format=\"json\"></quill-view>\n    `\n    })\n    class JSONComponent {\n      @ViewChild(QuillViewComponent, {\n        static: true\n      }) view: QuillViewComponent | undefined\n      content = JSON.stringify([{\n        insert: 'Hallo'\n      }])\n    }\n\n    let fixture: ComponentFixture<JSONComponent>\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(JSONComponent) as ComponentFixture<JSONComponent>\n      fixture.detectChanges()\n    })\n\n    it('should set json string', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      await fixture.whenStable()\n\n      expect(JSON.stringify(component.view!.quillEditor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hallo\\n' }] }))\n    })\n\n    it('should update json string', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n\n      component.content = JSON.stringify([{\n        insert: 'Hallo 123'\n      }])\n      fixture.detectChanges()\n      await fixture.whenStable()\n\n      expect(JSON.stringify(component.view!.quillEditor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hallo 123\\n' }] }))\n    })\n  })\n})\n\ndescribe('Advanced QuillViewComponent', () => {\n\n  @Component({\n    changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/prefer-signals","severity":2,"message":"Use the `viewChild` function instead of the `ViewChild` decorator","line":254,"column":5,"nodeType":"Decorator","messageId":"preferQuerySignals","endLine":254,"endColumn":53}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Component, ViewChild } from '@angular/core'\nimport { ComponentFixture, TestBed } from '@angular/core/testing'\n\nimport { QuillViewComponent } from './quill-view.component'\n\nimport Quill from 'quill'\nimport { QuillModule } from './quill.module'\n\nclass CustomModule {\n  quill: Quill\n  options: any\n\n  constructor(quill: Quill, options: any) {\n    this.quill = quill\n    this.options = options\n  }\n}\n\ndescribe('Basic QuillViewComponent', () => {\n  let fixture: ComponentFixture<QuillViewComponent>\n\n  beforeEach(async () => {\n    TestBed.configureTestingModule({\n      imports: [\n        QuillModule.forRoot({\n          customModules: [{\n            path: 'modules/custom',\n            implementation: CustomModule\n          }],\n          customOptions: [{\n            import: 'attributors/style/size',\n            whitelist: ['14']\n          }],\n        })\n      ],\n      providers: QuillModule.forRoot().providers\n    })\n\n    fixture = TestBed.createComponent(QuillViewComponent)\n    fixture.detectChanges()\n    await fixture.whenStable()\n  })\n\n  it('should render and set default snow theme class', async () => {\n    const element = fixture.nativeElement\n    fixture.detectChanges()\n    await fixture.whenStable()\n\n    expect(element.querySelectorAll('.ql-editor').length).toBe(1)\n    expect(fixture.componentInstance.quillEditor).toBeDefined()\n    const viewElement = element.querySelector('.ql-container.ql-snow.ngx-quill-view > .ql-editor')\n    expect(viewElement).toBeDefined()\n  })\n})\n\ndescribe('Formats', () => {\n  describe('object', () => {\n    @Component({\n      imports: [QuillModule],\n      template: `\n    <quill-view [content]=\"content\" [customModules]=\"[{path: 'modules/test', implementation: impl}]\" format=\"object\"></quill-view>\n    `\n    })\n    class ObjectComponent {\n      @ViewChild(QuillViewComponent, {\n        static: true\n      }) view: QuillViewComponent | undefined\n      content = [{\n        insert: 'Hello'\n      }]\n\n      impl = CustomModule\n    }\n\n    let fixture: ComponentFixture<ObjectComponent>\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(ObjectComponent) as ComponentFixture<ObjectComponent>\n      fixture.detectChanges()\n    })\n\n    it('should be set object', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.view!.quillEditor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hello\\n' }] }))\n    })\n\n    it('should update object content', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.content = [{ insert: '1234' }]\n      fixture.detectChanges()\n\n      await fixture.whenStable()\n      expect(JSON.stringify(component.view!.quillEditor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: '1234\\n' }] }))\n    })\n  })\n\n  describe('html', () => {\n    @Component({\n      imports: [QuillModule],\n      template: `\n    <quill-view [content]=\"content\" format=\"html\"></quill-view>\n    `\n    })\n    class HTMLComponent {\n      @ViewChild(QuillViewComponent, {\n        static: true\n      }) view: QuillViewComponent | undefined\n      content = '<p>Hallo</p>'\n    }\n\n    let fixture: ComponentFixture<HTMLComponent>\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(HTMLComponent) as ComponentFixture<HTMLComponent>\n      fixture.detectChanges()\n    })\n    it('should be set html', async () => {\n      const component = fixture.componentInstance\n\n      await fixture.whenStable()\n      expect(component.view!.quillEditor.getText().trim()).toEqual('Hallo')\n    })\n\n    it('should update html', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.content = '<p>test</p>'\n      fixture.detectChanges()\n      await fixture.whenStable()\n\n      expect(component.view!.quillEditor.getText().trim()).toEqual('test')\n    })\n  })\n\n  describe('text', () => {\n    @Component({\n      imports: [QuillModule],\n      template: `\n    <quill-view [content]=\"content\" format=\"text\"></quill-view>\n    `\n    })\n    class TextComponent {\n      @ViewChild(QuillViewComponent, {\n        static: true\n      }) view: QuillViewComponent | undefined\n      content = 'Hallo'\n    }\n\n    let fixture: ComponentFixture<TextComponent>\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(TextComponent) as ComponentFixture<TextComponent>\n      fixture.detectChanges()\n    })\n    it('should be set text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      expect(component.view!.quillEditor.getText().trim()).toEqual('Hallo')\n    })\n\n    it('should update text', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      component.content = 'test'\n      fixture.detectChanges()\n      await fixture.whenStable()\n\n      expect(component.view!.quillEditor.getText().trim()).toEqual('test')\n    })\n  })\n\n  describe('json', () => {\n    @Component({\n      imports: [QuillModule],\n      template: `\n    <quill-view [content]=\"content\" format=\"json\"></quill-view>\n    `\n    })\n    class JSONComponent {\n      @ViewChild(QuillViewComponent, {\n        static: true\n      }) view: QuillViewComponent | undefined\n      content = JSON.stringify([{\n        insert: 'Hallo'\n      }])\n    }\n\n    let fixture: ComponentFixture<JSONComponent>\n\n    beforeEach(() => {\n      TestBed.configureTestingModule({\n        declarations: [],\n        imports: [QuillModule],\n        providers: QuillModule.forRoot().providers\n      })\n\n      fixture = TestBed.createComponent(JSONComponent) as ComponentFixture<JSONComponent>\n      fixture.detectChanges()\n    })\n\n    it('should set json string', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n      await fixture.whenStable()\n\n      expect(JSON.stringify(component.view!.quillEditor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hallo\\n' }] }))\n    })\n\n    it('should update json string', async () => {\n      const component = fixture.componentInstance\n      await fixture.whenStable()\n\n      component.content = JSON.stringify([{\n        insert: 'Hallo 123'\n      }])\n      fixture.detectChanges()\n      await fixture.whenStable()\n\n      expect(JSON.stringify(component.view!.quillEditor.getContents())).toEqual(JSON.stringify({ ops: [{ insert: 'Hallo 123\\n' }] }))\n    })\n  })\n})\n\ndescribe('Advanced QuillViewComponent', () => {\n\n  @Component({\n    imports: [QuillModule],\n    template: `\n  <quill-view [content]=\"content\" format=\"html\" (onEditorCreated)=\"handleEditorCreated($event)\"></quill-view>\n  `\n  })\n  class AdvancedComponent {\n    @ViewChild(QuillViewComponent, { static: true }) view: QuillViewComponent | undefined\n    content = '<p>Hallo</p>'\n    quillEditor: any\n\n    handleEditorCreated(event: any) {\n      this.quillEditor = event\n    }\n  }\n\n  let fixture: ComponentFixture<AdvancedComponent>\n\n  beforeEach(async () => {\n\n    TestBed.configureTestingModule({\n      declarations: [],\n      imports: [QuillModule],\n      providers: QuillModule.forRoot().providers\n    }).compileComponents()\n\n    fixture = TestBed.createComponent(AdvancedComponent) as ComponentFixture<AdvancedComponent>\n  })\n\n  it('should emit onEditorCreated with editor instance',  async () => {\n\n    spyOn(fixture.componentInstance, 'handleEditorCreated')\n    fixture.detectChanges()\n\n    await fixture.whenStable()\n\n    const viewComponent = fixture.debugElement.children[0].componentInstance\n    expect(fixture.componentInstance.handleEditorCreated).toHaveBeenCalledWith(viewComponent.quillEditor)\n  })\n})\n","usedDeprecatedRules":[]},{"filePath":"/home/migudel/Documents/GII/42C/TFG/develop/repos/ngx-quill/projects/ngx-quill/src/lib/quill-view.component.ts","messages":[{"ruleId":"@angular-eslint/prefer-on-push-component-change-detection","severity":2,"message":"The component's `changeDetection` value should be set to `ChangeDetectionStrategy.OnPush`","line":33,"column":1,"nodeType":"Decorator","messageId":"preferOnPushComponentChangeDetection","endLine":44,"endColumn":3,"suggestions":[{"messageId":"suggestAddChangeDetectionOnPush","fix":{"range":[328,760],"text":", ChangeDetectionStrategy\n} from '@angular/core'\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop'\nimport { DomSanitizer } from '@angular/platform-browser'\nimport type { Subscription } from 'rxjs'\nimport { mergeMap } from 'rxjs/operators'\n\nimport { CustomModule, CustomOption, QuillBeforeRender, QuillModules } from 'ngx-quill/config'\n\nimport { getFormat, raf$ } from './helpers'\nimport { QuillService } from './quill.service'\n\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush,"},"desc":"Add `ChangeDetectionStrategy.OnPush`"}]},{"ruleId":"@angular-eslint/use-component-view-encapsulation","severity":2,"message":"Using `ViewEncapsulation.None` makes your styles global, which may have an unintended effect","line":34,"column":36,"nodeType":"Identifier","messageId":"useComponentViewEncapsulation","endLine":34,"endColumn":40,"suggestions":[{"messageId":"suggestRemoveViewEncapsulationNone","fix":{"range":[288,798],"text":",\n  inject,\n  input\n} from '@angular/core'\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop'\nimport { DomSanitizer } from '@angular/platform-browser'\nimport type { Subscription } from 'rxjs'\nimport { mergeMap } from 'rxjs/operators'\n\nimport { CustomModule, CustomOption, QuillBeforeRender, QuillModules } from 'ngx-quill/config'\n\nimport { getFormat, raf$ } from './helpers'\nimport { QuillService } from './quill.service'\n\n@Component({\n  "},"desc":"Remove `ViewEncapsulation.None`"}]},{"ruleId":"@angular-eslint/component-selector","severity":2,"message":"The selector should start with one of these prefixes: \"lib\" (https://angular.dev/style-guide#style-02-07)","line":35,"column":13,"nodeType":"Literal","messageId":"prefixFailure","endLine":35,"endColumn":25},{"ruleId":"@angular-eslint/consistent-component-styles","severity":2,"message":"Use a `string` instead of a `string[]` for the `styles` property","line":36,"column":11,"nodeType":"ArrayExpression","messageId":"useStylesString","endLine":40,"endColumn":3,"fix":{"range":[835,886],"text":"`\n.ql-container.ngx-quill-view {\n  border: 0;\n}\n`"}},{"ruleId":"@angular-eslint/prefer-output-readonly","severity":2,"message":"Prefer to declare `@Output` as `readonly` since they are not supposed to be reassigned","line":60,"column":13,"nodeType":"Identifier","messageId":"preferOutputReadonly","endLine":60,"endColumn":28,"suggestions":[{"messageId":"suggestAddReadonlyModifier","fix":{"range":[1667,1667],"text":"readonly "},"desc":"Add `readonly` modifier"}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { isPlatformServer } from '@angular/common'\nimport type QuillType from 'quill'\n\nimport {\n  AfterViewInit,\n  Component,\n  DestroyRef,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Output,\n  PLATFORM_ID,\n  Renderer2,\n  SecurityContext,\n  SimpleChanges,\n  ViewEncapsulation,\n  inject,\n  input\n} from '@angular/core'\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop'\nimport { DomSanitizer } from '@angular/platform-browser'\nimport type { Subscription } from 'rxjs'\nimport { mergeMap } from 'rxjs/operators'\n\nimport { CustomModule, CustomOption, QuillBeforeRender, QuillModules } from 'ngx-quill/config'\n\nimport { getFormat, raf$ } from './helpers'\nimport { QuillService } from './quill.service'\n\n@Component({\n  encapsulation: ViewEncapsulation.None,\n  selector: 'quill-view',\n  styles: [`\n.ql-container.ngx-quill-view {\n  border: 0;\n}\n`],\n  template: `\n  <div quill-view-element></div>\n`,\n})\nexport class QuillViewComponent implements AfterViewInit, OnChanges, OnDestroy {\n  readonly format = input<'object' | 'html' | 'text' | 'json' | undefined>(\n    undefined\n  )\n  readonly theme = input<string | undefined>(undefined)\n  readonly modules = input<QuillModules | undefined>(undefined)\n  readonly debug = input<'warn' | 'log' | 'error' | false>(false)\n  readonly formats = input<string[] | null | undefined>(undefined)\n  readonly sanitize = input<boolean | undefined>(undefined)\n  readonly beforeRender = input<QuillBeforeRender>()\n  readonly strict = input(true)\n  readonly content = input<any>()\n  readonly customModules = input<CustomModule[]>([])\n  readonly customOptions = input<CustomOption[]>([])\n\n  @Output() onEditorCreated = new EventEmitter<any>()\n\n  quillEditor!: QuillType\n  editorElem!: HTMLElement\n\n  private quillSubscription: Subscription | null = null\n\n  private destroyRef = inject(DestroyRef)\n\n  constructor(\n    public elementRef: ElementRef,\n    protected renderer: Renderer2,\n    protected zone: NgZone,\n    protected service: QuillService,\n    protected domSanitizer: DomSanitizer,\n    @Inject(PLATFORM_ID) protected platformId: any,\n  ) { }\n\n  valueSetter = (quillEditor: QuillType, value: any): any => {\n    const format = getFormat(this.format(), this.service.config.format)\n    let content = value\n    if (format === 'text') {\n      quillEditor.setText(content)\n    } else {\n      if (format === 'html') {\n        const sanitize = [true, false].includes(this.sanitize()) ? this.sanitize() : (this.service.config.sanitize || false)\n        if (sanitize) {\n          value = this.domSanitizer.sanitize(SecurityContext.HTML, value)\n        }\n        content = quillEditor.clipboard.convert({ html: value })\n      } else if (format === 'json') {\n        try {\n          content = JSON.parse(value)\n        } catch {\n          content = [{ insert: value }]\n        }\n      }\n      quillEditor.setContents(content)\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    if (!this.quillEditor) {\n      return\n    }\n    if (changes.content) {\n      this.valueSetter(this.quillEditor, changes.content.currentValue)\n    }\n  }\n\n  ngAfterViewInit() {\n    if (isPlatformServer(this.platformId)) {\n      return\n    }\n\n    this.quillSubscription = this.service.getQuill().pipe(\n      mergeMap((Quill) => this.service.beforeRender(Quill, this.customModules(), this.beforeRender()))\n    ).subscribe(Quill => {\n      const modules = Object.assign({}, this.modules() || this.service.config.modules)\n      modules.toolbar = false\n\n      this.customOptions().forEach((customOption) => {\n        const newCustomOption = Quill.import(customOption.import)\n        newCustomOption.whitelist = customOption.whitelist\n        Quill.register(newCustomOption, true)\n      })\n\n      let debug = this.debug()\n      if (!debug && debug !== false && this.service.config.debug) {\n        debug = this.service.config.debug\n      }\n\n      let formats = this.formats()\n      if (!formats && formats === undefined) {\n        formats = this.service.config.formats ? [...this.service.config.formats] : (this.service.config.formats === null ? null : undefined)\n      }\n      const theme = this.theme() || (this.service.config.theme ? this.service.config.theme : 'snow')\n\n      this.editorElem = this.elementRef.nativeElement.querySelector(\n        '[quill-view-element]'\n      ) as HTMLElement\n\n      this.zone.runOutsideAngular(() => {\n        this.quillEditor = new Quill(this.editorElem, {\n          debug,\n          formats,\n          modules,\n          readOnly: true,\n          strict: this.strict(),\n          theme\n        })\n      })\n\n      this.renderer.addClass(this.editorElem, 'ngx-quill-view')\n\n      if (this.content()) {\n        this.valueSetter(this.quillEditor, this.content())\n      }\n\n      // The `requestAnimationFrame` triggers change detection. There's no sense to invoke the `requestAnimationFrame` if anyone is\n      // listening to the `onEditorCreated` event inside the template, for instance `<quill-view (onEditorCreated)=\"...\">`.\n      if (!this.onEditorCreated.observed) {\n        return\n      }\n\n      // The `requestAnimationFrame` will trigger change detection and `onEditorCreated` will also call `markDirty()`\n      // internally, since Angular wraps template event listeners into `listener` instruction. We're using the `requestAnimationFrame`\n      // to prevent the frame drop and avoid `ExpressionChangedAfterItHasBeenCheckedError` error.\n      raf$().pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => {\n        this.onEditorCreated.emit(this.quillEditor)\n      })\n    })\n  }\n\n  ngOnDestroy(): void {\n    this.quillSubscription?.unsubscribe()\n    this.quillSubscription = null\n  }\n}\n","usedDeprecatedRules":[]}]
